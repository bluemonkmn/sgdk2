<?xml version="1.0" standalone="yes"?>
<ProjectDataset>
  <xs:schema id="ProjectDataset" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" xmlns:msprop="urn:schemas-microsoft-com:xml-msprop">
    <xs:element name="ProjectDataset" msdata:IsDataSet="true" msprop:SchemaVersion="1">
      <xs:complexType>
        <xs:choice maxOccurs="unbounded">
          <xs:element name="GraphicSheet">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Image" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="5" />
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Columns" type="xs:short" default="16" />
              <xs:attribute name="Rows" type="xs:short" default="8" />
              <xs:attribute name="CellWidth" msdata:Caption="Cell Width" type="xs:short" default="32" />
              <xs:attribute name="CellHeight" msdata:Caption="Cell Height" type="xs:short" default="32" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Frameset">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Frame" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="FrameValue" type="xs:int" use="required" />
                    <xs:attribute name="GraphicSheet" type="xs:string" use="required" />
                    <xs:attribute name="CellIndex" type="xs:short" use="required" />
                    <xs:attribute name="m11" type="xs:float" default="1" />
                    <xs:attribute name="m12" type="xs:float" default="0" />
                    <xs:attribute name="m21" type="xs:float" default="0" />
                    <xs:attribute name="m22" type="xs:float" default="1" />
                    <xs:attribute name="dx" type="xs:float" default="0" />
                    <xs:attribute name="dy" type="xs:float" default="0" />
                    <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="color" type="xs:int" default="-1" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Tileset">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Tile" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="TileFrame" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:attribute name="Sequence" type="xs:short" use="required" />
                          <xs:attribute name="FrameValue" type="xs:int" />
                          <xs:attribute name="Duration" type="xs:short" />
                          <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="TileValue" type="xs:int" msdata:AllowDBNull="false" use="prohibited" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="TileValue" type="xs:int" use="required" />
                    <xs:attribute name="Counter" type="xs:string" />
                    <xs:attribute name="Name" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Frameset" type="xs:string" />
              <xs:attribute name="TileWidth" type="xs:short" use="required" />
              <xs:attribute name="TileHeight" type="xs:short" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Counter">
            <xs:complexType>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="Value" type="xs:int" />
              <xs:attribute name="Max" type="xs:int" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Map">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Layer" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="Tiles" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="14" />
                      <xs:element name="Sprite" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="ParameterValue" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="SpriteName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="ParameterName" type="xs:string" use="required" />
                                <xs:attribute name="Value" type="xs:int" />
                                <xs:attribute name="DefinitionName" type="xs:string" use="prohibited" />
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Name" type="xs:string" use="required" />
                          <xs:attribute name="DefinitionName" type="xs:string" use="required" />
                          <xs:attribute name="StateName" type="xs:string" />
                          <xs:attribute name="CurrentFrame" type="xs:short" />
                          <xs:attribute name="X" type="xs:int" />
                          <xs:attribute name="Y" type="xs:int" />
                          <xs:attribute name="DX" type="xs:float" />
                          <xs:attribute name="DY" type="xs:float" />
                          <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Priority" type="xs:int" />
                          <xs:attribute name="Active" type="xs:boolean" default="true" />
                          <xs:attribute name="Solidity" type="xs:string" />
                          <xs:attribute name="Color" type="xs:int" default="-1" />
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="SpritePlan" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="Coordinate" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Sequence" type="xs:short" use="required" />
                                <xs:attribute name="X" type="xs:int" />
                                <xs:attribute name="Y" type="xs:int" />
                                <xs:attribute name="Weight" type="xs:int" />
                              </xs:complexType>
                            </xs:element>
                            <xs:element name="PlanRule" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Name" type="xs:string" use="required" />
                                <xs:attribute name="Sequence" type="xs:int" use="required" />
                                <xs:attribute name="Type" type="xs:string" use="required" />
                                <xs:attribute name="Function" type="xs:string" use="required" />
                                <xs:attribute name="Parameter1" type="xs:string" />
                                <xs:attribute name="Parameter2" type="xs:string" />
                                <xs:attribute name="Parameter3" type="xs:string" />
                                <xs:attribute name="ResultParameter" type="xs:string" />
                                <xs:attribute name="EndIf" type="xs:boolean" default="false" />
                                <xs:attribute name="Suspended" type="xs:boolean" default="false" />
                              </xs:complexType>
                            </xs:element>
                            <xs:element name="PlanParameterValue" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="PlanName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Name" type="xs:string" use="required" />
                                <xs:attribute name="Value" type="xs:string" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="LayerName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Name" type="xs:string" use="required" />
                          <xs:attribute name="Priority" type="xs:int" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="Width" type="xs:int" use="required" />
                    <xs:attribute name="Height" type="xs:int" use="required" />
                    <xs:attribute name="Tileset" type="xs:string" />
                    <xs:attribute name="BytesPerTile" type="xs:unsignedByte" use="required" />
                    <xs:attribute name="MapName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="OffsetX" type="xs:int" default="0" />
                    <xs:attribute name="OffsetY" type="xs:int" default="0" />
                    <xs:attribute name="ScrollRateX" type="xs:float" default="1" />
                    <xs:attribute name="ScrollRateY" type="xs:float" default="1" />
                    <xs:attribute name="ZIndex" type="xs:int" />
                    <xs:attribute name="Priority" type="xs:int" default="0" />
                    <xs:attribute name="VirtualWidth" type="xs:int" default="0" />
                    <xs:attribute name="VirtualHeight" type="xs:int" default="0" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="ScrollMarginLeft" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginTop" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginRight" type="xs:short" use="required" />
              <xs:attribute name="ScrollMarginBottom" type="xs:short" use="required" />
              <xs:attribute name="ScrollWidth" msdata:Caption="Scrollable pixel width of the map independent of its layers" type="xs:int" />
              <xs:attribute name="ScrollHeight" msdata:Caption="Scrollable pixel height of the map independent of its layers" type="xs:int" />
              <xs:attribute name="ViewLeft" type="xs:short" />
              <xs:attribute name="ViewTop" type="xs:short" />
              <xs:attribute name="ViewWidth" type="xs:short" />
              <xs:attribute name="ViewHeight" type="xs:short" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SpriteDefinition">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SpriteRule" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="Sequence" type="xs:int" use="required" />
                    <xs:attribute name="Type" type="xs:string" use="required" />
                    <xs:attribute name="Function" type="xs:string" use="required" />
                    <xs:attribute name="Parameter1" type="xs:string" />
                    <xs:attribute name="Parameter2" type="xs:string" />
                    <xs:attribute name="Parameter3" type="xs:string" />
                    <xs:attribute name="ResultParameter" type="xs:string" />
                    <xs:attribute name="EndIf" type="xs:boolean" default="false" />
                    <xs:attribute name="Suspended" type="xs:boolean" default="false" />
                  </xs:complexType>
                </xs:element>
                <xs:element name="SpriteParameter" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
                <xs:element name="SpriteState" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="SpriteFrame" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="StateName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Sequence" type="xs:short" use="required" />
                          <xs:attribute name="FrameValue" type="xs:int" />
                          <xs:attribute name="Duration" type="xs:short" />
                          <xs:attribute name="MaskAlphaLevel" type="xs:unsignedByte" default="0" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="DefinitionName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                    <xs:attribute name="FramesetName" type="xs:string" use="required" />
                    <xs:attribute name="SolidWidth" type="xs:short" use="required" />
                    <xs:attribute name="SolidHeight" type="xs:short" use="required" />
                    <xs:attribute name="Sequence" type="xs:short" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SpriteCategory">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SpriteCategorySprite" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="CategoryName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="DefinitionName" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Solidity">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SolidityShape" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="SolidityName" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                    <xs:attribute name="CategoryName" type="xs:string" use="required" />
                    <xs:attribute name="ShapeName" type="xs:string" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
          <xs:element name="SourceCode">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Text" type="xs:string" minOccurs="0" msdata:Ordinal="3" />
                <xs:element name="CustomObjectData" type="xs:base64Binary" minOccurs="0" msdata:Ordinal="4" />
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
              <xs:attribute name="IsCustomObject" type="xs:boolean" default="false" />
              <xs:attribute name="DependsOn" type="xs:string" />
            </xs:complexType>
          </xs:element>
          <xs:element name="Project">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Comments" type="xs:string" default="" msdata:Ordinal="8" />
              </xs:sequence>
              <xs:attribute name="DisplayMode" type="xs:string" use="required" />
              <xs:attribute name="Windowed" type="xs:boolean" use="required" />
              <xs:attribute name="TitleText" type="xs:string" />
              <xs:attribute name="StartMap" type="xs:string" />
              <xs:attribute name="OverlayMap" type="xs:string" />
              <xs:attribute name="MaxPlayers" type="xs:unsignedByte" default="1" />
              <xs:attribute name="MaxViews" type="xs:unsignedByte" default="1" />
              <xs:attribute name="Credits" type="xs:string" />
            </xs:complexType>
          </xs:element>
          <xs:element name="TileCategory">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CategorizedTileset" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="CategoryTile" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="CategoryFrame" minOccurs="0" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:attribute name="Tileset" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Category" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="TileValue" type="xs:int" msdata:AllowDBNull="false" use="prohibited" />
                                <xs:attribute name="Frame" type="xs:short" use="required" />
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attribute name="Tileset" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="Category" type="xs:string" msdata:AllowDBNull="false" use="prohibited" />
                          <xs:attribute name="TileValue" type="xs:int" use="required" />
                        </xs:complexType>
                      </xs:element>
                    </xs:sequence>
                    <xs:attribute name="Tileset" type="xs:string" use="required" />
                    <xs:attribute name="Name" type="xs:string" use="required" />
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="Name" type="xs:string" use="required" />
            </xs:complexType>
          </xs:element>
        </xs:choice>
      </xs:complexType>
      <xs:unique name="GraphicSheetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//GraphicSheet" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="FrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@FrameValue" />
      </xs:unique>
      <xs:unique name="FramesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Frameset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="TileFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//TileFrame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="TileKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
      </xs:unique>
      <xs:unique name="TilesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Tileset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CounterKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Counter" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="ParameterValueKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@SpriteName" />
        <xs:field xpath="@ParameterName" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="SpriteKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="SpriteKeyWithDefinition">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@MapName" />
      </xs:unique>
      <xs:unique name="CoordinateKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Coordinate" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="PlanRuleKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//PlanRule" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="PlanParameterValueKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//PlanParameterValue" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpritePlanKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpritePlan" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="LayerKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="MapKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Map" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteRuleKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteRule" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteParameterKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteParameter" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteFrame" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
        <xs:field xpath="@Sequence" />
      </xs:unique>
      <xs:unique name="SpriteStateKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteStateFramesetKey">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@FramesetName" />
      </xs:unique>
      <xs:unique name="SpriteDefinitionKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteDefinition" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SpriteCategorySpriteKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@CategoryName" />
        <xs:field xpath="@DefinitionName" />
      </xs:unique>
      <xs:unique name="SpriteCategoryKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SpriteCategory" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SolidityShapeKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@SolidityName" />
        <xs:field xpath="@CategoryName" />
      </xs:unique>
      <xs:unique name="SolidityKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//Solidity" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="SourceCodeKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//SourceCode" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CategoryFrameKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategoryFrame" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
        <xs:field xpath="@Frame" />
      </xs:unique>
      <xs:unique name="CategoryTileKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategoryTile" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
      </xs:unique>
      <xs:unique name="CategorizedTilesetKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:unique name="CategoryKey" msdata:PrimaryKey="true">
        <xs:selector xpath=".//TileCategory" />
        <xs:field xpath="@Name" />
      </xs:unique>
      <xs:keyref name="TilesetCategory" refer="TilesetKey">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Tileset" />
      </xs:keyref>
      <xs:keyref name="TileCategoryCategorizedTileset" refer="CategoryKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategorizedTileset" />
        <xs:field xpath="@Name" />
      </xs:keyref>
      <xs:keyref name="CategoryCategoryTile" refer="CategorizedTilesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategoryTile" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
      </xs:keyref>
      <xs:keyref name="CategoryTileCategoryFrame" refer="CategoryTileKey" msdata:IsNested="true">
        <xs:selector xpath=".//CategoryFrame" />
        <xs:field xpath="@Tileset" />
        <xs:field xpath="@Category" />
        <xs:field xpath="@TileValue" />
      </xs:keyref>
      <xs:keyref name="MapProject" refer="MapKey" msdata:ConstraintOnly="true" msdata:DeleteRule="SetNull">
        <xs:selector xpath=".//Project" />
        <xs:field xpath="@StartMap" />
      </xs:keyref>
      <xs:keyref name="CategorySolidityShape" refer="CategoryKey">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@CategoryName" />
      </xs:keyref>
      <xs:keyref name="SoliditySolidityShape" refer="SolidityKey" msdata:IsNested="true">
        <xs:selector xpath=".//SolidityShape" />
        <xs:field xpath="@SolidityName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionCategory" refer="SpriteDefinitionKey">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteCategorySpriteCategorySprite" refer="SpriteCategoryKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteCategorySprite" />
        <xs:field xpath="@CategoryName" />
      </xs:keyref>
      <xs:keyref name="FramesetSpriteState" refer="FramesetKey">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@FramesetName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionState" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteState" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteStateFrame" refer="SpriteStateKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteFrame" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSpriteParameter" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteParameter" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSpriteRule" refer="SpriteDefinitionKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpriteRule" />
        <xs:field xpath="@DefinitionName" />
      </xs:keyref>
      <xs:keyref name="TilesetLayer" refer="TilesetKey">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@Tileset" />
      </xs:keyref>
      <xs:keyref name="MapLayer" refer="MapKey" msdata:IsNested="true">
        <xs:selector xpath=".//Layer" />
        <xs:field xpath="@MapName" />
      </xs:keyref>
      <xs:keyref name="LayerSpritePlan" refer="LayerKey" msdata:IsNested="true">
        <xs:selector xpath=".//SpritePlan" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanPlanParameterValue" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//PlanParameterValue" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanPlanRule" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//PlanRule" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpritePlanCoordinate" refer="SpritePlanKey" msdata:IsNested="true">
        <xs:selector xpath=".//Coordinate" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@PlanName" />
      </xs:keyref>
      <xs:keyref name="SpriteDefinitionSprite" refer="SpriteStateKey">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@StateName" />
      </xs:keyref>
      <xs:keyref name="LayerSprite" refer="LayerKey" msdata:IsNested="true">
        <xs:selector xpath=".//Sprite" />
        <xs:field xpath="@MapName" />
        <xs:field xpath="@LayerName" />
      </xs:keyref>
      <xs:keyref name="SpriteParameterParameterValue" refer="SpriteParameterKey">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@ParameterName" />
      </xs:keyref>
      <xs:keyref name="SpriteParameterValue" refer="SpriteKeyWithDefinition" msdata:IsNested="true">
        <xs:selector xpath=".//ParameterValue" />
        <xs:field xpath="@DefinitionName" />
        <xs:field xpath="@LayerName" />
        <xs:field xpath="@SpriteName" />
        <xs:field xpath="@MapName" />
      </xs:keyref>
      <xs:keyref name="FramesetTileset" refer="FramesetKey">
        <xs:selector xpath=".//Tileset" />
        <xs:field xpath="@Frameset" />
      </xs:keyref>
      <xs:keyref name="CounterTile" refer="CounterKey" msdata:DeleteRule="SetNull">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Counter" />
      </xs:keyref>
      <xs:keyref name="TilesetTile" refer="TilesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//Tile" />
        <xs:field xpath="@Name" />
      </xs:keyref>
      <xs:keyref name="TileTileFrame" refer="TileKey" msdata:IsNested="true">
        <xs:selector xpath=".//TileFrame" />
        <xs:field xpath="@Name" />
        <xs:field xpath="@TileValue" />
      </xs:keyref>
      <xs:keyref name="GraphicSheetFrame" refer="GraphicSheetKey" msdata:ConstraintOnly="true" msdata:DeleteRule="None">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@GraphicSheet" />
      </xs:keyref>
      <xs:keyref name="FramesetFrame" refer="FramesetKey" msdata:IsNested="true">
        <xs:selector xpath=".//Frame" />
        <xs:field xpath="@Name" />
      </xs:keyref>
    </xs:element>
  </xs:schema>
  <Solidity Name="Standard">
    <SolidityShape CategoryName="Solid" ShapeName="SolidTileShape" />
  </Solidity>
  <SourceCode Name="Controls.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

/// &lt;summary&gt;
/// UI to support the player's customization of input device.
/// &lt;/summary&gt;
public class frmControls : System.Windows.Forms.Form
{
   #region Windows Form Designer Members
   private System.Windows.Forms.Label lblController;
   private System.Windows.Forms.ComboBox cboController;
   private System.Windows.Forms.RadioButton rdoController;
   private System.Windows.Forms.RadioButton rdoKeyboard;
   private System.Windows.Forms.TextBox txtButton4;
   private System.Windows.Forms.Label lblButton4;
   private System.Windows.Forms.TextBox txtButton3;
   private System.Windows.Forms.Label lblButton3;
   private System.Windows.Forms.TextBox txtButton2;
   private System.Windows.Forms.Label lblButton2;
   private System.Windows.Forms.TextBox txtButton1;
   private System.Windows.Forms.Label lblButton1;
   private System.Windows.Forms.TextBox txtDown;
   private System.Windows.Forms.Label lblDown;
   private System.Windows.Forms.TextBox txtRight;
   private System.Windows.Forms.Label lblRight;
   private System.Windows.Forms.TextBox txtLeft;
   private System.Windows.Forms.Label lblLeft;
   private System.Windows.Forms.TextBox txtUp;
   private System.Windows.Forms.Label lblUp;
   private System.Windows.Forms.ComboBox cboPlayer;
   private System.Windows.Forms.Label lblPlayer;

   /// &lt;summary&gt;
   /// Required designer variable.
   /// &lt;/summary&gt;
   private System.ComponentModel.Container components = null;
   #endregion
   
   public frmControls()
   {
      //
      // Required for Windows Form Designer support
      //
      InitializeComponent();

      if (Project.MaxPlayers &lt;= 1)
      {
         lblPlayer.Hide();
         cboPlayer.Hide();
         this.ClientSize = new System.Drawing.Size(298, 185);
      }

      for(int i = 0; i &lt; Project.GameWindow.ControllerCount; i++)
         cboController.Items.Add(Project.GameWindow.GetControllerName(i));
      rdoController.Enabled = (cboController.Items.Count &gt; 0);

      for (int i = 0; i&lt;Project.MaxPlayers; i++)
         cboPlayer.Items.Add("Player " + (i+1).ToString());
      cboPlayer.SelectedIndex = 0;
   }

   /// &lt;summary&gt;
   /// Clean up any resources being used.
   /// &lt;/summary&gt;
   protected override void Dispose( bool disposing )
   {
      if( disposing )
      {
         if(components != null)
         {
            components.Dispose();
         }
      }
      base.Dispose( disposing );
   }

   #region Windows Form Designer generated code
   private void InitializeComponent()
   {
      this.lblController = new System.Windows.Forms.Label();
      this.cboController = new System.Windows.Forms.ComboBox();
      this.rdoController = new System.Windows.Forms.RadioButton();
      this.rdoKeyboard = new System.Windows.Forms.RadioButton();
      this.txtButton4 = new System.Windows.Forms.TextBox();
      this.lblButton4 = new System.Windows.Forms.Label();
      this.txtButton3 = new System.Windows.Forms.TextBox();
      this.lblButton3 = new System.Windows.Forms.Label();
      this.txtButton2 = new System.Windows.Forms.TextBox();
      this.lblButton2 = new System.Windows.Forms.Label();
      this.txtButton1 = new System.Windows.Forms.TextBox();
      this.lblButton1 = new System.Windows.Forms.Label();
      this.txtDown = new System.Windows.Forms.TextBox();
      this.lblDown = new System.Windows.Forms.Label();
      this.txtRight = new System.Windows.Forms.TextBox();
      this.lblRight = new System.Windows.Forms.Label();
      this.txtLeft = new System.Windows.Forms.TextBox();
      this.lblLeft = new System.Windows.Forms.Label();
      this.txtUp = new System.Windows.Forms.TextBox();
      this.lblUp = new System.Windows.Forms.Label();
      this.cboPlayer = new System.Windows.Forms.ComboBox();
      this.lblPlayer = new System.Windows.Forms.Label();
      this.SuspendLayout();
      // 
      // lblController
      // 
      this.lblController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblController.Enabled = false;
      this.lblController.Location = new System.Drawing.Point(24, 184);
      this.lblController.Name = "lblController";
      this.lblController.Size = new System.Drawing.Size(64, 16);
      this.lblController.TabIndex = 43;
      this.lblController.Text = "Controller:";
      // 
      // cboController
      // 
      this.cboController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.cboController.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
      this.cboController.Enabled = false;
      this.cboController.Location = new System.Drawing.Point(88, 184);
      this.cboController.Name = "cboController";
      this.cboController.Size = new System.Drawing.Size(200, 21);
      this.cboController.TabIndex = 42;
      this.cboController.SelectedIndexChanged += new System.EventHandler(this.cboController_SelectedIndexChanged);
      // 
      // rdoController
      // 
      this.rdoController.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.rdoController.Location = new System.Drawing.Point(8, 160);
      this.rdoController.Name = "rdoController";
      this.rdoController.Size = new System.Drawing.Size(272, 16);
      this.rdoController.TabIndex = 41;
      this.rdoController.Text = "Game Controller";
      this.rdoController.CheckedChanged += new System.EventHandler(this.InputType_Changed);
      // 
      // rdoKeyboard
      // 
      this.rdoKeyboard.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.rdoKeyboard.Location = new System.Drawing.Point(8, 40);
      this.rdoKeyboard.Name = "rdoKeyboard";
      this.rdoKeyboard.Size = new System.Drawing.Size(272, 16);
      this.rdoKeyboard.TabIndex = 40;
      this.rdoKeyboard.Text = "Keyboard";
      this.rdoKeyboard.CheckedChanged += new System.EventHandler(this.InputType_Changed);
      // 
      // txtButton4
      // 
      this.txtButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton4.Enabled = false;
      this.txtButton4.Location = new System.Drawing.Point(224, 128);
      this.txtButton4.Name = "txtButton4";
      this.txtButton4.ReadOnly = true;
      this.txtButton4.Size = new System.Drawing.Size(64, 20);
      this.txtButton4.TabIndex = 39;
      this.txtButton4.Text = "";
      this.txtButton4.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblButton4
      // 
      this.lblButton4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton4.Enabled = false;
      this.lblButton4.Location = new System.Drawing.Point(160, 128);
      this.lblButton4.Name = "lblButton4";
      this.lblButton4.Size = new System.Drawing.Size(64, 20);
      this.lblButton4.TabIndex = 38;
      this.lblButton4.Text = "Button 4:";
      this.lblButton4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton3
      // 
      this.txtButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton3.Enabled = false;
      this.txtButton3.Location = new System.Drawing.Point(224, 104);
      this.txtButton3.Name = "txtButton3";
      this.txtButton3.ReadOnly = true;
      this.txtButton3.Size = new System.Drawing.Size(64, 20);
      this.txtButton3.TabIndex = 37;
      this.txtButton3.Text = "";
      this.txtButton3.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblButton3
      // 
      this.lblButton3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton3.Enabled = false;
      this.lblButton3.Location = new System.Drawing.Point(160, 104);
      this.lblButton3.Name = "lblButton3";
      this.lblButton3.Size = new System.Drawing.Size(64, 20);
      this.lblButton3.TabIndex = 36;
      this.lblButton3.Text = "Button 3:";
      this.lblButton3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton2
      // 
      this.txtButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton2.Enabled = false;
      this.txtButton2.Location = new System.Drawing.Point(224, 80);
      this.txtButton2.Name = "txtButton2";
      this.txtButton2.ReadOnly = true;
      this.txtButton2.Size = new System.Drawing.Size(64, 20);
      this.txtButton2.TabIndex = 35;
      this.txtButton2.Text = "";
      this.txtButton2.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblButton2
      // 
      this.lblButton2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton2.Enabled = false;
      this.lblButton2.Location = new System.Drawing.Point(160, 80);
      this.lblButton2.Name = "lblButton2";
      this.lblButton2.Size = new System.Drawing.Size(64, 20);
      this.lblButton2.TabIndex = 34;
      this.lblButton2.Text = "Button 2:";
      this.lblButton2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtButton1
      // 
      this.txtButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtButton1.Enabled = false;
      this.txtButton1.Location = new System.Drawing.Point(224, 56);
      this.txtButton1.Name = "txtButton1";
      this.txtButton1.ReadOnly = true;
      this.txtButton1.Size = new System.Drawing.Size(64, 20);
      this.txtButton1.TabIndex = 33;
      this.txtButton1.Text = "";
      this.txtButton1.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblButton1
      // 
      this.lblButton1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblButton1.Enabled = false;
      this.lblButton1.Location = new System.Drawing.Point(160, 56);
      this.lblButton1.Name = "lblButton1";
      this.lblButton1.Size = new System.Drawing.Size(64, 20);
      this.lblButton1.TabIndex = 32;
      this.lblButton1.Text = "Button 1:";
      this.lblButton1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtDown
      // 
      this.txtDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtDown.Enabled = false;
      this.txtDown.Location = new System.Drawing.Point(88, 128);
      this.txtDown.Name = "txtDown";
      this.txtDown.ReadOnly = true;
      this.txtDown.Size = new System.Drawing.Size(64, 20);
      this.txtDown.TabIndex = 31;
      this.txtDown.Text = "";
      this.txtDown.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblDown
      // 
      this.lblDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblDown.Enabled = false;
      this.lblDown.Location = new System.Drawing.Point(24, 128);
      this.lblDown.Name = "lblDown";
      this.lblDown.Size = new System.Drawing.Size(64, 20);
      this.lblDown.TabIndex = 30;
      this.lblDown.Text = "Down:";
      this.lblDown.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtRight
      // 
      this.txtRight.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtRight.Enabled = false;
      this.txtRight.Location = new System.Drawing.Point(88, 104);
      this.txtRight.Name = "txtRight";
      this.txtRight.ReadOnly = true;
      this.txtRight.Size = new System.Drawing.Size(64, 20);
      this.txtRight.TabIndex = 29;
      this.txtRight.Text = "";
      this.txtRight.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblRight
      // 
      this.lblRight.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblRight.Enabled = false;
      this.lblRight.Location = new System.Drawing.Point(24, 104);
      this.lblRight.Name = "lblRight";
      this.lblRight.Size = new System.Drawing.Size(64, 20);
      this.lblRight.TabIndex = 28;
      this.lblRight.Text = "Right:";
      this.lblRight.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtLeft
      // 
      this.txtLeft.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtLeft.Enabled = false;
      this.txtLeft.Location = new System.Drawing.Point(88, 80);
      this.txtLeft.Name = "txtLeft";
      this.txtLeft.ReadOnly = true;
      this.txtLeft.Size = new System.Drawing.Size(64, 20);
      this.txtLeft.TabIndex = 27;
      this.txtLeft.Text = "";
      this.txtLeft.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblLeft
      // 
      this.lblLeft.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblLeft.Enabled = false;
      this.lblLeft.Location = new System.Drawing.Point(24, 80);
      this.lblLeft.Name = "lblLeft";
      this.lblLeft.Size = new System.Drawing.Size(64, 20);
      this.lblLeft.TabIndex = 26;
      this.lblLeft.Text = "Left:";
      this.lblLeft.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // txtUp
      // 
      this.txtUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.txtUp.Enabled = false;
      this.txtUp.Location = new System.Drawing.Point(88, 56);
      this.txtUp.Name = "txtUp";
      this.txtUp.ReadOnly = true;
      this.txtUp.Size = new System.Drawing.Size(64, 20);
      this.txtUp.TabIndex = 25;
      this.txtUp.Text = "";
      this.txtUp.KeyDown += new System.Windows.Forms.KeyEventHandler(this.KeyBox_KeyDown);
      // 
      // lblUp
      // 
      this.lblUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblUp.Enabled = false;
      this.lblUp.Location = new System.Drawing.Point(24, 56);
      this.lblUp.Name = "lblUp";
      this.lblUp.Size = new System.Drawing.Size(64, 20);
      this.lblUp.TabIndex = 24;
      this.lblUp.Text = "Up:";
      this.lblUp.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // cboPlayer
      // 
      this.cboPlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.cboPlayer.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
      this.cboPlayer.Location = new System.Drawing.Point(88, 8);
      this.cboPlayer.Name = "cboPlayer";
      this.cboPlayer.Size = new System.Drawing.Size(200, 21);
      this.cboPlayer.TabIndex = 23;
      this.cboPlayer.SelectedIndexChanged += new System.EventHandler(this.cboPlayer_SelectedIndexChanged);
      // 
      // lblPlayer
      // 
      this.lblPlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
      this.lblPlayer.Location = new System.Drawing.Point(8, 8);
      this.lblPlayer.Name = "lblPlayer";
      this.lblPlayer.Size = new System.Drawing.Size(80, 21);
      this.lblPlayer.TabIndex = 22;
      this.lblPlayer.Text = "Player:";
      this.lblPlayer.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // frmControls
      // 
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(298, 215);
      this.Controls.Add(this.lblController);
      this.Controls.Add(this.cboController);
      this.Controls.Add(this.rdoController);
      this.Controls.Add(this.rdoKeyboard);
      this.Controls.Add(this.txtButton4);
      this.Controls.Add(this.txtButton3);
      this.Controls.Add(this.txtButton2);
      this.Controls.Add(this.txtButton1);
      this.Controls.Add(this.txtDown);
      this.Controls.Add(this.txtRight);
      this.Controls.Add(this.txtLeft);
      this.Controls.Add(this.txtUp);
      this.Controls.Add(this.lblButton4);
      this.Controls.Add(this.lblButton3);
      this.Controls.Add(this.lblButton2);
      this.Controls.Add(this.lblButton1);
      this.Controls.Add(this.lblDown);
      this.Controls.Add(this.lblRight);
      this.Controls.Add(this.lblLeft);
      this.Controls.Add(this.lblUp);
      this.Controls.Add(this.cboPlayer);
      this.Controls.Add(this.lblPlayer);
      this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
      this.MaximizeBox = false;
      this.Name = "frmControls";
      this.Text = "Customize Controls";
      this.ResumeLayout(false);

   }
   #endregion

   private void InputType_Changed(object sender, System.EventArgs e)
   {
      if (((RadioButton)sender).Checked)
      {
         lblUp.Enabled = txtUp.Enabled =
            lblLeft.Enabled = txtLeft.Enabled =
            lblRight.Enabled = txtRight.Enabled =
            lblDown.Enabled = txtDown.Enabled =
            lblButton1.Enabled = txtButton1.Enabled = 
            lblButton2.Enabled = txtButton2.Enabled = 
            lblButton3.Enabled = txtButton3.Enabled = 
            lblButton4.Enabled = txtButton4.Enabled =
            sender == rdoKeyboard;

         lblController.Enabled = cboController.Enabled = 
            (sender != rdoKeyboard);

         if (sender == rdoKeyboard)
            Project.GameWindow.Players[SelectedPlayer] = new KeyboardPlayer(SelectedPlayer);
         else
            Project.GameWindow.Players[SelectedPlayer] = new ControllerPlayer(SelectedPlayer % cboController.Items.Count);

         LoadCurrentControls();
      }
   }

   private int SelectedPlayer
   {
      get
      {
         return cboPlayer.SelectedIndex;
      }
   }

   private void KeyBox_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
   {
      Microsoft.DirectX.DirectInput.Key[] pressed;
      do
      {
         pressed = Project.GameWindow.GetPressedKeys();
      } while(pressed.Length == 0);

      ((TextBox)sender).Text = System.Enum.Format(typeof(
         Microsoft.DirectX.DirectInput.Key), pressed[0], "g");

      KeyboardPlayer player = (KeyboardPlayer)Project.GameWindow.Players[SelectedPlayer];
      if (sender == txtUp)
         player.key_up = pressed[0];
      else if (sender == txtLeft)
         player.key_left = pressed[0];
      else if (sender == txtRight)
         player.key_right = pressed[0];
      else if (sender == txtDown)
         player.key_down = pressed[0];
      else if (sender == txtButton1)
         player.key_button1 = pressed[0];
      else if (sender == txtButton2)
         player.key_button2 = pressed[0];
      else if (sender == txtButton3)
         player.key_button3 = pressed[0];
      else if (sender == txtButton4)
         player.key_button4 = pressed[0];
   }

   private void cboController_SelectedIndexChanged(object sender, System.EventArgs e)
   {
      if (cboController.SelectedIndex &gt;= 0)
         ((ControllerPlayer)Project.GameWindow.Players[SelectedPlayer]).deviceNumber = cboController.SelectedIndex;
   }

   private void cboPlayer_SelectedIndexChanged(object sender, System.EventArgs e)
   {
      LoadCurrentControls();
   }

   private void LoadCurrentControls()
   {
      if (Project.GameWindow.Players[SelectedPlayer] is KeyboardPlayer)
      {
         KeyboardPlayer player = (KeyboardPlayer)Project.GameWindow.Players[SelectedPlayer];
         rdoKeyboard.Checked = true;
         txtUp.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_up, "g");
         txtLeft.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_left, "g");
         txtRight.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_right, "g");
         txtDown.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_down, "g");
         txtButton1.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_button1, "g");
         txtButton2.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_button2, "g");
         txtButton3.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_button3, "g");
         txtButton4.Text = System.Enum.Format(typeof(Microsoft.DirectX.DirectInput.Key), player.key_button4, "g");
      }
      else
      {
         rdoController.Checked = true;
         int devNum = ((ControllerPlayer)Project.GameWindow.Players[SelectedPlayer]).deviceNumber;
         if (cboController.Items.Count &gt; devNum)
            cboController.SelectedIndex = devNum;
         else
            cboController.SelectedIndex = -1;
      }
   }
}

</Text>
  </SourceCode>
  <SourceCode Name="Project.cs" IsCustomObject="false">
    <Text>/*
 * Scrolling Game Development Kit 2.0
 * Generated Project Template Code
 * 
 * Copyright  2000 - 2007 Benjamin Marty &lt;bluemonkmn@users.sourceforge.net&gt;
 * 
 * Distributed under the GNU General Public License (GPL)
 *   - see included file COPYING.txt for details, or visit:
 *     http://www.fsf.org/copyleft/gpl.html
 */
using System;

/// &lt;summary&gt;
/// This class provides global, static data. No instances are created.
/// &lt;/summary&gt;
/// &lt;remarks&gt;This class was created to serve as an interface between
/// generated code and project custom code.  It exists so that the
/// Highest level code (including the entry point) can be customized
/// while still allowing the code generator to provide some high level
/// global properties in the Project.resx file.&lt;/remarks&gt;
public class Project
{
   private static System.Resources.ResourceManager m_res;
   private static GameForm game;

   /// &lt;summary&gt;
   /// Defines the maximum number of players that can be active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This determines primarily how many players the user can customize
   /// in the options dialog at runtime. If there is only 1 player, there will be
   /// no dowpdown list to select which player to customize. Note that the actual
   /// number of active players is determined by the rules defined in the project.
   /// &lt;seealso cref="PlanBase.MapPlayerToInputs"/&gt;&lt;/remarks&gt;
   public static readonly System.Byte MaxPlayers;
   /// &lt;summary&gt;
   /// Defines the maxmimum number of views that can be active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This determines which view layouts can be selected with
   /// &lt;see cref="MapBase.ViewLayout"/&gt; and related functions.&lt;/remarks&gt;
   public static readonly System.Byte MaxViews;
   /// &lt;summary&gt;
   /// Contains a string to display in the game's about dialog.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The IDE will automatically merge credits from imported objects
   /// into this string.&lt;/remarks&gt;
   public static readonly string GameCredits;

   /// &lt;summary&gt;
   /// Initializes the project's read-only properties from the resource file
   /// provided by the code generator.
   /// &lt;/summary&gt;
   static Project()
   {
      Project.m_res = new System.Resources.ResourceManager(typeof(Project));
      MaxPlayers = byte.Parse(m_res.GetString("_MaxPlayers"));
      MaxViews = byte.Parse(m_res.GetString("_MaxViews"));
      GameCredits = m_res.GetString("_GameCredits");
   }

   /// &lt;summary&gt;
   /// Returns the object that contains all the graphic sheet resources for the project
   /// (among other things)
   /// &lt;/summary&gt;
   /// &lt;example&gt;A graphic sheet's image can be retrieved from this object using code
   /// like this:
   /// &lt;code&gt;System.Drawing.Bitmap bmpGfx = (System.Drawing.Bitmap)Project.Resources.GetObject("My Sheet")&lt;/code&gt;
   /// &lt;/example&gt;
   public static System.Resources.ResourceManager Resources
   {
      get
      {
         return m_res;
      }
   }

   /// &lt;summary&gt;
   /// Returns the main window object.
   /// &lt;/summary&gt;
   public static GameForm GameWindow
   {
      get
      {
         return Project.game;
      }
   }

   /// &lt;summary&gt;
   /// Represents the main entry point of the program.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This creates the main window, initializing it with the game's startup
   /// map, overlay map, title, and default window mode (windowed or full screen), then
   /// calls &lt;see cref="GameForm.Run"/&gt; and lets it run until the game quits.&lt;/remarks&gt;
   public static void Main()
   {
      try
      {
         GameDisplayMode mode = (GameDisplayMode)System.Enum.Parse(typeof(GameDisplayMode), m_res.GetString("_DisplayMode"));
         bool windowed = bool.Parse(m_res.GetString("_Windowed"));
         string windowTitle = m_res.GetString("_WindowTitle");
         System.Type startupMapType = System.Reflection.Assembly.GetExecutingAssembly().GetType(m_res.GetString("_StartupMapType").Replace(" ","_") + "_Map", true);
         System.Type overlayMapType = null;
         if (m_res.GetString("_OverlayMapType") != null)
             overlayMapType = System.Reflection.Assembly.GetExecutingAssembly().GetType(m_res.GetString("_OverlayMapType").Replace(" ","_") + "_Map", true);

         Project.game = new GameForm(mode, windowed, windowTitle, startupMapType, overlayMapType);
         game.Show();
         game.Run();
      }
      catch (System.Exception ex)
      {
         GameForm.HandleException(ex);
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="Display.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;
using System.Windows.Forms;
using System.Collections;

/// &lt;summary&gt;
/// Specifies a size and color depth for a display.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Color depth only applies when the display is in full screen mode.&lt;/remarks&gt;
public enum GameDisplayMode
{
   m320x240x16,
   m640x480x16,
   m800x600x16,
   m1024x768x16,
   m1280x1024x16,
   m320x240x24,
   m640x480x24,
   m800x600x24,
   m1024x768x24,
   m1280x1024x24
}

/// &lt;summary&gt;
/// Manages the display device on which real-time game graphics are drawn
/// &lt;/summary&gt;
[Serializable()]
public class Display : ScrollableControl, System.Runtime.Serialization.ISerializable
{
   #region Win32 API Constants
   public const int WS_EX_CLIENTEDGE = unchecked((int)0x00000200);
   public const int WS_BORDER = unchecked((int)0x00800000);
   #endregion

   #region Events
   public event EventHandler WindowedChanged;
   #endregion

   #region Embedded Classes
   private class CoverWindow : Form
   {
      public Display m_LinkedControl;

      public CoverWindow(Display LinkedControl)
      {
         m_LinkedControl = LinkedControl;
         FormBorderStyle = FormBorderStyle.None;
         System.Drawing.Size sz = Display.GetScreenSize(LinkedControl.GameDisplayMode);
         SetBounds(0,0,sz.Width,sz.Height);
         ShowInTaskbar = false;
         Show();
      }

      protected override void OnMouseMove(MouseEventArgs e)
      {
         m_LinkedControl.OnMouseMove(e);
      }
      protected override void OnKeyDown(KeyEventArgs e)
      {
         m_LinkedControl.OnKeyDown(e);
      }
   }

   /// &lt;summary&gt;
   /// Manages a reference to a graphic sheet ("texture") in the hardware.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This class tracks an instance of a Direct3D texture and provides
   /// a layer of indirection, allowing a frameset to refer to a texture (via this
   /// object) while the texture (and even the whole display) are destroyed and
   /// re-created, without losing track of which graphics it is associated with.
   /// &lt;/remarks&gt;
   public class TextureRef : IDisposable
   {
      private string m_Name;
      private Texture m_Texture = null;
      private Display m_Display;
      
      public TextureRef(Display Disp, string Name)
      {
         m_Display = Disp;
         m_Name = Name;
      }

      public string Name
      {
         get
         {
            return m_Name;
         }
      }

      public void Reset()
      {
         m_Texture = null;
      }

      public Texture Texture
      {
         get
         {
            if (m_Texture == null)
               m_Texture = m_Display.GetTexture(m_Name);
            return m_Texture;
         }
      }

      #region IDisposable Members
      public void Dispose()
      {
         if (m_Texture != null)
         {
            m_Texture.Dispose();
            m_Texture = null;
         }
      }
      #endregion
   }
   #endregion

   #region Fields
   private System.Collections.Specialized.HybridDictionary m_TextureRefs = null;
   private Device m_d3d = null;
   private PresentParameters m_pp;
   private GameDisplayMode m_GameDisplayMode;
   private BorderStyle m_BorderStyle;
   private CoverWindow m_CoverWindow = null;
   private Sprite m_Sprite = null;
   private Font m_Font = null;
   private Line m_Line = null;
   private string fontName = null;
   private int fontSize = 0;
   #endregion

   #region Initialization and clean-up
   public Display() : this(GameDisplayMode.m640x480x24, true)
   {
   }

   public Display(GameDisplayMode mode, bool windowed)
   {
      this.SetStyle(ControlStyles.ResizeRedraw, true);
      this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
      this.SetStyle(ControlStyles.UserPaint, true);
      this.SetStyle(ControlStyles.Opaque, true);

      m_pp = new PresentParameters();
      m_pp.Windowed = windowed;
      m_pp.SwapEffect = SwapEffect.Copy; // Allows ScissorTestEnable to work in full screen
      // Allow GetGraphics
      m_pp.PresentFlag = PresentFlag.LockableBackBuffer;
      MakeValidPresentParameters(mode, m_pp);
      if (!windowed)
      {
         m_CoverWindow = new CoverWindow(this);
         Recreate();
      }
      m_GameDisplayMode = mode;
   }

   protected override void Dispose(bool disposing)
   {
      if (disposing)
      {
         DisposeAllTextures();
         if (m_Sprite != null)
         {
            m_Sprite.Dispose();
            m_Sprite = null;
         }
         if (m_Font != null)
         {
            m_Font.Dispose();
            m_Font = null;
         }
         if (m_Line != null)
         {
            m_Line.Dispose();
            m_Line = null;
         }
         if (m_d3d != null)
         {
            m_d3d.Dispose();
            m_d3d = null;
         }
         if (m_CoverWindow != null)
         {
            m_CoverWindow.m_LinkedControl = null;
            m_CoverWindow.Close();
            m_CoverWindow.Dispose();
            m_CoverWindow = null;
         }
      }
      base.Dispose (disposing);
   }
   #endregion

   #region Overrides
   protected override void OnCreateControl()
   {
      m_pp.DeviceWindow = this;
      m_pp.SwapEffect = SwapEffect.Copy; // Allows ScissorTestEnable to work in full screen

      try
      {
         if (m_d3d == null)
         {
            Recreate();
         }
      }
      catch(Exception ex)
      {
         MessageBox.Show(this, "Error creating display device: " + ex.ToString(), "Error Creating Device", MessageBoxButtons.OK, MessageBoxIcon.Error);
      }

      base.OnCreateControl ();
   }

   protected override void OnKeyDown(KeyEventArgs e)
   {
      if ((e.KeyCode == Keys.Enter) &amp;&amp; e.Alt)
         Windowed = !Windowed;
      base.OnKeyDown (e);
   }

   protected override CreateParams CreateParams
   {
      get
      {
         CreateParams cp = base.CreateParams;
         cp.ExStyle &amp;= ~WS_EX_CLIENTEDGE;
         cp.Style &amp;= ~WS_BORDER;

         if (!m_pp.Windowed)
            return cp;

         switch (m_BorderStyle)
         {
            case BorderStyle.Fixed3D:
               cp.ExStyle |= WS_EX_CLIENTEDGE;
               break;
            case BorderStyle.FixedSingle:
               cp.Style |= WS_BORDER;
               break;
         }

         return cp;
      }
   }

   protected override void OnResize(EventArgs e)
   {
      if (this.Size.IsEmpty)
      {
         DisposeAllTextures();
         if (m_Sprite != null)
         {
            m_Sprite.Dispose();
            m_Sprite = null;
         }
         if (m_Font != null)
         {
            m_Font.Dispose();
            m_Font = null;
         }
         if (m_Line != null)
         {
            m_Line.Dispose();
            m_Line = null;
         }
         if (m_d3d != null)
         {
            m_d3d.Dispose();
            m_d3d = null;
         }
      }
      else if ((m_d3d == null) &amp;&amp; Created)
      {
         Recreate();
      }
      else if ((m_d3d != null) &amp;&amp; (m_pp != null) &amp;&amp; (m_pp.Windowed))
      {
         m_pp.BackBufferHeight = m_pp.BackBufferWidth = 0;
         if (m_Sprite != null)
         {
            m_Sprite.Dispose();
            m_Sprite = null;
         }
         if (m_Font != null)
         {
            m_Font.Dispose();
            m_Font = null;
         }
         if (m_Line != null)
         {
            m_Line.Dispose();
            m_Line = null;
         }
         m_d3d.Reset(m_pp);
      }
      base.OnResize (e);
   }

   protected override void OnPaint(PaintEventArgs e)
   {
      if ((m_d3d == null) || (m_d3d.Disposed))
         return;
      int coop;
      if (!m_d3d.CheckCooperativeLevel(out coop))
      {
         Microsoft.DirectX.Direct3D.ResultCode coopStatus = (Microsoft.DirectX.Direct3D.ResultCode)System.Enum.Parse(typeof(Microsoft.DirectX.Direct3D.ResultCode), coop.ToString());
         if (coopStatus == Microsoft.DirectX.Direct3D.ResultCode.DeviceNotReset)
            Recreate();
         else
            return;
      }
      base.OnPaint (e);
   }
   #endregion

   #region Private members
   private Texture GetTexture(string Name)
   {
      return Texture.FromBitmap(m_d3d,
         (System.Drawing.Bitmap)Project.Resources.GetObject(Name), 0, Pool.Managed);
   }

   #endregion

   #region Public members
   /// &lt;summary&gt;
   /// Defines how the edges of teh display appear when embedded in a window.
   /// &lt;/summary&gt;
   public BorderStyle BorderStyle
   {
      get
      {
         return m_BorderStyle;
      }
      set
      {
         m_BorderStyle = value;
         UpdateStyles();
      }
   }

   /// &lt;summary&gt;
   /// Retrieve a reference to a hardware-supported graphic sheet ("texture") given its name
   /// &lt;/summary&gt;
   /// &lt;param name="Name"&gt;The name of a graphic sheet defined by the game&lt;/param&gt;
   /// &lt;returns&gt;Object that manages graphics on the hardware for this graphic sheet&lt;/returns&gt;
   public TextureRef GetTextureRef(string Name)
   {
      if (m_TextureRefs == null)
         m_TextureRefs = new System.Collections.Specialized.HybridDictionary();

      if (m_TextureRefs.Contains(Name))
      {
         WeakReference wr = (WeakReference)m_TextureRefs[Name];
         if (wr.IsAlive)
            return (TextureRef)wr.Target;
      }

      TextureRef tex = new TextureRef(this, Name);
      m_TextureRefs[Name] = new WeakReference(tex);
      return tex;
   }

   /// &lt;summary&gt;
   /// Release resources used by all hardware copies of graphic sheets
   /// &lt;/summary&gt;
   public void DisposeAllTextures()
   {
      if (m_TextureRefs != null)
      {
         foreach (DictionaryEntry de in m_TextureRefs)
         {
            if (((WeakReference)de.Value).IsAlive)
               ((TextureRef)((WeakReference)de.Value).Target).Dispose();
         }
      }
   }

   /// &lt;summary&gt;
   /// Returns the Direct3D device supporting this display object
   /// &lt;/summary&gt;
   public Device Device
   {
      get
      {
         return m_d3d;
      }
   }

   /// &lt;summary&gt;
   /// Gets or sets whether the display is running in windowed mode versus full screen mode.
   /// &lt;/summary&gt;
   public bool Windowed
   {
      set
      {
         if ((DesignMode) &amp;&amp; (!value))
            throw new InvalidOperationException("Cannot use full screen in design mode");

         if (value != m_pp.Windowed)
         {
            DisposeAllTextures();
            if (m_Sprite != null)
            {
               m_Sprite.Dispose();
               m_Sprite = null;
            }
            if (m_Font != null)
            {
               m_Font.Dispose();
               m_Font = null;
            }
            if (m_Line != null)
            {
               m_Line.Dispose();
               m_Line = null;
            }
            if (m_d3d != null)
            {
               m_d3d.Dispose();
               m_d3d = null;
            }
         }
         else
            return;

         m_pp.Windowed = value;
         m_pp.SwapEffect = SwapEffect.Copy; // Allows ScissorTestEnable to work in full screen

         if (value)
         {
            m_pp.DeviceWindow = this;
            MakeValidPresentParameters(GameDisplayMode, m_pp);
            if (m_CoverWindow != null)
            {
               m_CoverWindow.m_LinkedControl = null;
               m_CoverWindow.Close();
               m_CoverWindow.Dispose();
               m_CoverWindow = null;
            }
            Recreate();
         }
         else
         {
            m_CoverWindow = new CoverWindow(this);
            m_pp.DeviceWindow = m_CoverWindow;
            MakeValidPresentParameters(GameDisplayMode, m_pp);
            Recreate();
         }
         if (WindowedChanged != null)
            WindowedChanged(this, null);
      }
      get
      {
         return m_pp.Windowed;
      }
   }

   /// &lt;summary&gt;
   /// Get the size of a display based on the specified mode
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Game display mode used for the display&lt;/param&gt;
   /// &lt;returns&gt;Width and height in pixels&lt;/returns&gt;
   public static System.Drawing.Size GetScreenSize(GameDisplayMode mode)
   {
      switch(mode)
      {
         case GameDisplayMode.m320x240x16:
         case GameDisplayMode.m320x240x24:
            return new System.Drawing.Size(320,240);
         case GameDisplayMode.m640x480x16:
         case GameDisplayMode.m640x480x24:
            return new System.Drawing.Size(640,480);
         case GameDisplayMode.m800x600x16:
         case GameDisplayMode.m800x600x24:
            return new System.Drawing.Size(800,600);
         case GameDisplayMode.m1024x768x16:
         case GameDisplayMode.m1024x768x24:
            return new System.Drawing.Size(1024,768);
         case GameDisplayMode.m1280x1024x16:
         case GameDisplayMode.m1280x1024x24:
            return new System.Drawing.Size(1280,1024);
      }
      return new System.Drawing.Size(0,0);
   }

   /// &lt;summary&gt;
   /// Completes the presentation parameter structure by filling out a back buffer
   /// width, height, and format.
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Game requested display mode&lt;/param&gt;
   /// &lt;param name="pp"&gt;Object to finish populating&lt;/param&gt;
   public static void MakeValidPresentParameters(GameDisplayMode mode, PresentParameters pp)
   {
      if (pp.Windowed)
      {
         pp.BackBufferFormat = Format.Unknown;
         pp.BackBufferWidth = pp.BackBufferHeight = 0;
         pp.FullScreenRefreshRateInHz = 0;

         if (!Manager.CheckDeviceType(Manager.Adapters.Default.Adapter, DeviceType.Hardware, Manager.Adapters.Default.CurrentDisplayMode.Format, pp.BackBufferFormat, pp.Windowed))
            throw new ApplicationException("No hardware support for windowed mode on default display adapter");
      }
      else
      {
         foreach(DisplayMode dm in Manager.Adapters.Default.SupportedDisplayModes)
         {
            System.Drawing.Size s = GetScreenSize(mode);
            if ((dm.Width != s.Width) || (dm.Height != s.Height))
               continue;

            switch (mode)
            {
               case GameDisplayMode.m320x240x16:
               case GameDisplayMode.m640x480x16:
               case GameDisplayMode.m800x600x16:
               case GameDisplayMode.m1024x768x16:
               case GameDisplayMode.m1280x1024x16:
               switch (dm.Format)
               {
                  case Format.A4R4G4B4:
                  case Format.A1R5G5B5:
                  case Format.R5G6B5:
                  case Format.X1R5G5B5:
                  case Format.X4R4G4B4:
                     // These are OK 16-bit formats. Break out of the switch and proceed
                     break;
                  default:
                     // Not a 16-bit format, continue to the next mode
                     continue;
               }
                  break;
               default:
               switch (dm.Format)
               {
                  case Format.A2B10G10R10:
                  case Format.A2R10G10B10:
                  case Format.A8B8G8R8:
                  case Format.A8R8G8B8:
                  case Format.R8G8B8:
                  case Format.X8B8G8R8:
                  case Format.X8R8G8B8:
                     // These are OK 32-bit formats. Break out of the switch and proceed
                     break;
                  default:
                     // Not a 32-bit format, continue to the next mode
                     continue;
               }
                  break;
            }

            if (Manager.CheckDeviceType(Manager.Adapters.Default.Adapter, DeviceType.Hardware, dm.Format, dm.Format, pp.Windowed))
            {
               // This can improve performance in some cases, but I have not
               // observed much difference in my testing.
               //m_pp.BackBufferCount = 2; 
               pp.BackBufferWidth = dm.Width;
               pp.BackBufferHeight = dm.Height;
               pp.BackBufferFormat = dm.Format;
               if (dm.RefreshRate &gt; pp.FullScreenRefreshRateInHz)
                  pp.FullScreenRefreshRateInHz = dm.RefreshRate;
            }
         }
         if (pp.FullScreenRefreshRateInHz == 0)
            throw new ApplicationException("Current display does not support mode " + mode.ToString() +".");
      }

      string errMsg = ValidateAdapter(Manager.Adapters.Default);
      if (errMsg != null)
         throw new ApplicationException("Default display adapter is inadequate: " + errMsg);
   }

   /// &lt;summary&gt;
   /// Gets or sets the size/resolution and color depth of the display
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the display is windowed, this only affects the size. The color depth
   /// will match that of the user's desktop. In full screen mode this affects the
   /// resolution and color depth of the display.&lt;/remarks&gt;
   public GameDisplayMode GameDisplayMode
   {
      get
      {
         return m_GameDisplayMode;
      }
      set
      {
         m_GameDisplayMode = value;
         ClientSize = GetScreenSize(value);
         if (!m_pp.Windowed)
         {
            MakeValidPresentParameters(m_GameDisplayMode, m_pp);
            if (m_Sprite != null)
            {
               m_Sprite.Dispose();
               m_Sprite = null;
            }
            if (m_Font != null)
            {
               m_Font.Dispose();
               m_Font = null;
            }
            if (m_Line != null)
            {
               m_Line.Dispose();
               m_Line = null;
            }
            m_d3d.Reset(m_pp);
         }
      }
   }

   /// &lt;summary&gt;
   /// Frees and re-creates all resources managed by the display
   /// &lt;/summary&gt;
   public void Recreate()
   {
      DisposeAllTextures();
      if (m_Sprite != null)
      {
         m_Sprite.Dispose();
         m_Sprite = null;
      }
      if (m_Font != null)
      {
         m_Font.Dispose();
         m_Font = null;
      }
      if (m_Line != null)
      {
         m_Line.Dispose();
         m_Line = null;
      }
      if (m_d3d != null)
         m_d3d.Dispose();
      if (Windowed || (m_CoverWindow == null))
         m_d3d = new Device(Manager.Adapters.Default.Adapter, DeviceType.Hardware, this, CreateFlags.SoftwareVertexProcessing, m_pp);
      else
         m_d3d = new Device(Manager.Adapters.Default.Adapter, DeviceType.Hardware, m_CoverWindow, CreateFlags.SoftwareVertexProcessing, m_pp);
      m_d3d.DeviceReset += new EventHandler(d3d_DeviceReset);
   }
   
   private static string ValidateAdapter(AdapterInformation adapter)
   {
      Caps caps = Manager.GetDeviceCaps(adapter.Adapter, DeviceType.Hardware);
      if (!caps.PrimitiveMiscCaps.SupportsBlendOperation)
         return "Inadequate hardware support for alpha blending";
      if (!caps.TextureCaps.SupportsAlpha)
         return "Hardware does not support textures with alpha";
      if (!caps.RasterCaps.SupportsScissorTest)
         return "No hardware support for clipping";
      if (!caps.TextureOperationCaps.SupportsModulate)
         return "No hardware support for color modulation";
      return null;
   }
   
   /// &lt;summary&gt;
   /// Returns the Direct3D Sprite object implementing this display's ability to draw graphics.
   /// &lt;/summary&gt;
   public Sprite Sprite
   {
      get
      {
         if ((m_Sprite == null) &amp;&amp; (m_d3d != null))
            m_Sprite = new Sprite(m_d3d);
         return m_Sprite;
      }
   }

   /// &lt;summary&gt;
   /// Returns the Direct3D Font object implementing this display's ability to draw text.
   /// &lt;/summary&gt;
   public Font D3DFont
   {
      get
      {
         if ((m_Font == null) &amp;&amp; (m_d3d != null))
         {
            if (fontName == null)
            {
               m_Font = new Microsoft.DirectX.Direct3D.Font(m_d3d, Font);
            }
            else
            {
               Microsoft.DirectX.Direct3D.FontDescription desc = new Microsoft.DirectX.Direct3D.FontDescription();
               desc.FaceName = fontName;
               desc.Height = fontSize;
               m_Font = new Microsoft.DirectX.Direct3D.Font(m_d3d, desc);
            }
         }
         return m_Font;
      }
   }

   /// &lt;summary&gt;
   /// Change the font used for drawing text on the display.
   /// &lt;/summary&gt;
   /// &lt;param name="font"&gt;Specifies a font to use&lt;/param&gt;
   public void SetFont(string name, int size)
   {
      if (m_Font != null)
      {
         m_Font.Dispose();
         m_Font = null;
      }
      fontName = name;
      fontSize = size;      
   }
   
   /// &lt;summary&gt;
   /// Returns the Direct3D Line object implementing this displays ability to perform simple line
   /// drawing operations.
   /// &lt;/summary&gt;
   public Line D3DLine
   {
      get
      {
         if ((m_Line == null) &amp;&amp; (m_d3d != null))
            m_Line = new Microsoft.DirectX.Direct3D.Line(m_d3d);
         return m_Line;
      }
   }
   #endregion

   #region Event Handlers
   private void d3d_DeviceReset(object sender, EventArgs e)
   {
      DisposeAllTextures();
   }
   #endregion

   #region ISerializable Members

   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.SetType(typeof(DisplayRef));
   }

   #endregion
}

/// &lt;summary&gt;
/// Provides serialization "services" for the &lt;see cref="Display"/&gt; object, preventing
/// attempts to save or load data for the display object when the game is saved/loaded.
/// &lt;/summary&gt;
[Serializable()]
public class DisplayRef : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
{

   private DisplayRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
   }

   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      throw new System.NotImplementedException("Unexpected serialization call");
   }

   #region IObjectReference Members
   public object GetRealObject(System.Runtime.Serialization.StreamingContext context)
   {
      return Project.GameWindow.GameDisplay;
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="GameForm.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Windows.Forms;

/// &lt;summary&gt;
/// UI that contains and manages the main display for the game.
/// &lt;/summary&gt;
public class GameForm : Form
{
   /// &lt;summary&gt;
   /// Hardware-backed display object embedded in the main window.
   /// &lt;/summary&gt;
   public Display GameDisplay = null;
   private Microsoft.DirectX.DirectInput.Device keyboard = null;
   private Microsoft.DirectX.DirectInput.KeyboardState m_keyboardState;
   private Microsoft.DirectX.DirectInput.Device[] controllers = null;
   private Microsoft.DirectX.DirectInput.JoystickState[] m_controllerState;
   private System.Collections.BitArray controllerEnabled;
   private System.Collections.BitArray controllerAcquired;
   /// &lt;summary&gt;
   /// Refers to the currently active primary map that is being drawn on the display
   /// &lt;/summary&gt;
   public MapBase CurrentMap;
   /// &lt;summary&gt;
   /// Refers to the currently active overlay map being drawn in front of the primary map
   /// &lt;/summary&gt;
   /// &lt;value&gt;This is a null reference if no overlay is active&lt;/value&gt;
   public MapBase OverlayMap;
   /// &lt;summary&gt;
   /// Contains a collection of all currently loaded maps.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The key of this collection is the type of the map class. The value is an
   /// instance of the map.
   /// &lt;seealso cref="UnloadMap"/&gt;
   /// &lt;seealso cref="GeneralRules.SwitchToMap"/&gt;&lt;/remarks&gt;
   public System.Collections.Hashtable LoadedMaps = new System.Collections.Hashtable();
   private int m_fps = 0;
   private int m_frameCount = 0;
   private DateTime m_frameStart;
   /// &lt;summary&gt;
   /// Used to write debug text that will be displayed for the current frame.
   /// &lt;/summary&gt;
   public System.IO.StringWriter debugText = new System.IO.StringWriter();
   private bool m_quit = false;
   /// &lt;summary&gt;
   /// Provides access to the input currently coming from the players' input devices.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each of these objects can refer to a &lt;see cref="KeyboardPlayer"/&gt;
   /// or a &lt;see cref="ControllerPlayer"/&gt;, or you can create your own player input.&lt;/remarks&gt;
   public IPlayer[] Players = new IPlayer[Project.MaxPlayers];

   #region Events
   /// &lt;summary&gt;
   /// Defines a mechanism by which simple notifications without any data can be triggered.
   /// &lt;/summary&gt;
   public delegate void SimpleNotification();
   /// &lt;summary&gt;
   /// Event fires every frame even when the game is not advancing.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The game may not be moving because the window may be minimized, but
   /// this event will still be raised. This might be useful for monitoring sounds that
   /// might continue to play while the window is minimized.&lt;/remarks&gt;
   public event SimpleNotification OnFrameStart;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing right before the scene is started.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeBeginScene;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing right before executing rules.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeExecuteRules;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing while the scene is being
   /// generated, right before the overlay map is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnBeforeDrawOverlay;
   /// &lt;summary&gt;
   /// Event fires every frame that the game is advancing after the overlay map is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This event does not occur if the game is minimized/paused.&lt;/remarks&gt;
   public event SimpleNotification OnAfterDrawOverlay;
   #endregion


   #region Windows Forms Components
   private System.Windows.Forms.MainMenu mnuGame;
   private System.Windows.Forms.MenuItem mnuFile;
   private System.Windows.Forms.MenuItem mnuFileExit;
   private System.Windows.Forms.MenuItem mnuTools;
   private System.Windows.Forms.MenuItem mnuToolsOptions;
   private System.Windows.Forms.MenuItem mnuHelp;
   private System.Windows.Forms.MenuItem mnuHelpAbout;
   #endregion

   /// &lt;summary&gt;
   /// Constructs the main form for containing the game display.
   /// &lt;/summary&gt;
   /// &lt;param name="mode"&gt;Defines the size of the form in windowed mode and the resolution and
   /// color depth of the display in full screen mode.&lt;/param&gt;
   /// &lt;param name="windowed"&gt;Determines whether the display is initially windowed or full screen.&lt;/param&gt;
   /// &lt;param name="title"&gt;Supplies a title for the window when the game is in windowed mode.&lt;/param&gt;
   /// &lt;param name="initMapType"&gt;Defines the map that is initially active when the game starts.&lt;/param&gt;
   /// &lt;param name="overlayMapType"&gt;Defines the map that in initially set as the
   /// &lt;seealso cref="OverlayMap"/&gt; or null if there is no overlay initially.&lt;/param&gt;
   public GameForm(GameDisplayMode mode, bool windowed, string title, System.Type initMapType, System.Type overlayMapType)
   {
      InitializeComponent();
#if DEBUG
      MessageBox.Show("You are running in debug mode.  Unexpected runtime conditions may cause the game to halt, and if an error occurs you will have the opportunity to debug into it if you have a debugger installed and the project's source code handy", "Debug Mode Active");
#endif
      AutoScale = false;
      ClientSize = Display.GetScreenSize(mode);
      GameDisplay = new Display(mode, windowed);
      GameDisplay.BorderStyle = System.Windows.Forms.BorderStyle.None;
      GameDisplay.Location = new System.Drawing.Point(0, 0);
      GameDisplay.Name = "GameDisplay";
      GameDisplay.Size = Display.GetScreenSize(mode);
      Controls.Add(this.GameDisplay);
      Name = "GameForm";
      Text = title;
      KeyPreview = true;
      FormBorderStyle = FormBorderStyle.FixedSingle;
      CurrentMap = GetMap(initMapType);
      if (overlayMapType != null)
         OverlayMap = GetMap(overlayMapType);
      else
         OverlayMap = null;
      GameDisplay.WindowedChanged += new EventHandler(GameDisplay_WindowedChanged);
   }

   /// &lt;summary&gt;
   /// Clean up any resources being used.
   /// &lt;/summary&gt;
   protected override void Dispose( bool disposing )
   {
      if( disposing )
      {
         if (GameDisplay != null)
         {
            GameDisplay.Dispose();
            GameDisplay = null;
         }
      }
      base.Dispose( disposing );
   }

   /// &lt;summary&gt;
   /// Main game loop initializes input devices and runs the game.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The general sequence of steps performed in this loop are:
   /// &lt;list type="number"&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnFrameStart"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Check if game has been closed/quit, and exit if necessary.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;If game is inactive draw the screen as it was when it
   /// was last active, and skip the rest of the loop.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeBeginScene"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Draw the main map.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Read players' input devices.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeExecuteRules"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Execute the main map's rules.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnBeforeDrawOverlay"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;If an overlay map is active, draw it and execute its rules.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Draw the current debug output if debug mode is active, and clear the debug text buffer.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;description&gt;Trigger &lt;see cref="OnAfterDrawOverlay"/&gt;.&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// &lt;/remarks&gt;
   public void Run()
   {
      int coopCode;

      System.Collections.ArrayList controllersBuilder = new System.Collections.ArrayList();
      foreach(Microsoft.DirectX.DirectInput.DeviceInstance dev in Microsoft.DirectX.DirectInput.Manager.Devices)
      {
         switch (dev.DeviceType)
         {
            case Microsoft.DirectX.DirectInput.DeviceType.Keyboard:
               if (keyboard == null)
               {
                  keyboard = new Microsoft.DirectX.DirectInput.Device(dev.InstanceGuid);
                  keyboard.SetCooperativeLevel(this, Microsoft.DirectX.DirectInput.CooperativeLevelFlags.Background |
                     Microsoft.DirectX.DirectInput.CooperativeLevelFlags.NonExclusive); 
                  keyboard.SetDataFormat(Microsoft.DirectX.DirectInput.DeviceDataFormat.Keyboard);
                  keyboard.Acquire();
               }
               break;
            case Microsoft.DirectX.DirectInput.DeviceType.Gamepad:
            case Microsoft.DirectX.DirectInput.DeviceType.Joystick:
            {
               Microsoft.DirectX.DirectInput.Device controller =
                  new Microsoft.DirectX.DirectInput.Device(dev.InstanceGuid);
               controller.SetCooperativeLevel(this, Microsoft.DirectX.DirectInput.CooperativeLevelFlags.Background |
                  Microsoft.DirectX.DirectInput.CooperativeLevelFlags.NonExclusive);
               controller.SetDataFormat(Microsoft.DirectX.DirectInput.DeviceDataFormat.Joystick);
               controllersBuilder.Add(controller);
               break;
            }
         }
      }
      if (controllersBuilder.Count &gt; 0)
      {
         controllers = (Microsoft.DirectX.DirectInput.Device[])controllersBuilder.ToArray(typeof(Microsoft.DirectX.DirectInput.Device));
         controllerEnabled = new System.Collections.BitArray(controllers.Length, false);
         controllerAcquired = new System.Collections.BitArray(controllers.Length, false);
         m_controllerState = new Microsoft.DirectX.DirectInput.JoystickState[controllers.Length];
      }
      else
      {
         controllers = null;
         controllerEnabled = controllerAcquired = null;
      }

      // Player 0 always uses keyboard by default
      Players[0] = new KeyboardPlayer(0);

      // Players 1 through (M-N) use keyboard while players (M-N+1) through M use controllers
      // where M is max player number and N is number of controllers.
      for (int playerIdx = 1; playerIdx&lt;Project.MaxPlayers; playerIdx++)
      {
         if ((controllers != null) &amp;&amp; (Project.MaxPlayers - playerIdx &lt;= controllers.Length))
            Players[playerIdx] = new ControllerPlayer(playerIdx - (Project.MaxPlayers - controllers.Length));
         else
            Players[playerIdx] = new KeyboardPlayer(playerIdx);
      }

      while(true)
      {
         if (OnFrameStart != null)
            OnFrameStart();
         if ((GameDisplay == null) || GameDisplay.Device.Disposed || m_quit)
         {
            Close();
            return;
         }
         bool isActive = true;
         if (GameDisplay.Windowed)
            isActive = (System.Windows.Forms.Form.ActiveForm == this);
         if (!isActive || (GameDisplay != null) &amp;&amp; (GameDisplay.Device == null))
         {
            // Display is minimized or inactive, wait until it is restored
            Application.DoEvents();
            if ((GameDisplay != null) &amp;&amp; (GameDisplay.Device != null))
               GameDisplay.Device.Present();
            System.Threading.Thread.Sleep(0);
            continue;
         }
         if (!GameDisplay.Device.CheckCooperativeLevel(out coopCode))
         {
            Microsoft.DirectX.Direct3D.ResultCode coop = (Microsoft.DirectX.Direct3D.ResultCode)System.Enum.Parse(typeof(Microsoft.DirectX.Direct3D.ResultCode), coopCode.ToString());
            if (coop == Microsoft.DirectX.Direct3D.ResultCode.DeviceNotReset)
               GameDisplay.Recreate();
            else
               System.Threading.Thread.Sleep(0);
         }
         else
         {
            if (OnBeforeBeginScene != null)
               OnBeforeBeginScene();
            GameDisplay.Device.BeginScene();
            GameDisplay.Sprite.Begin(Microsoft.DirectX.Direct3D.SpriteFlags.AlphaBlend);
            CurrentMap.DrawAllViews();
            if (keyboard != null)
               m_keyboardState = keyboard.GetCurrentKeyboardState();
            ReadControllers();
            if (OnBeforeExecuteRules != null)
               OnBeforeExecuteRules();
            CurrentMap.ExecuteRules();
            if (OnBeforeDrawOverlay != null)
               OnBeforeDrawOverlay();
            if (OverlayMap != null)
            {
               OverlayMap.DrawAllViews();
               OverlayMap.ExecuteRules();
            }
            OutputDebugInfo();
            if (OnAfterDrawOverlay != null)
               OnAfterDrawOverlay();
            GameDisplay.Sprite.End();
            GameDisplay.Device.EndScene();
            GameDisplay.Device.Present();
         }
         Application.DoEvents();
      }
   }

   /// &lt;summary&gt;
   /// Draw the text currently in the &lt;see cref="debugText"/&gt; buffer and clear the buffer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This will only execute in debug mode.&lt;/remarks&gt;
   [System.Diagnostics.Conditional("DEBUG")]
   public void OutputDebugInfo()
   {
      GameDisplay.Sprite.Transform = Microsoft.DirectX.Matrix.Identity;
      GameDisplay.Device.RenderState.ScissorTestEnable = false;
      GameDisplay.D3DFont.DrawText(GameDisplay.Sprite, debugText.ToString(), GameDisplay.DisplayRectangle, Microsoft.DirectX.Direct3D.DrawTextFormat.Left, Color.White);

      debugText.GetStringBuilder().Length = 0;
      debugText.WriteLine("fps=" + m_fps.ToString());
      m_frameCount++;
      if (DateTime.Now.Subtract(m_frameStart).TotalSeconds &gt;= 1f)
      {
         m_fps = m_frameCount;
         m_frameCount=0;
         m_frameStart = DateTime.Now;
      }
   }

   protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
   {
      GameDisplay.Dispose();
      GameDisplay = null;
      base.OnClosing(e);
   }

   /// &lt;summary&gt;
   /// Retrieves an instance of the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="mapType"&gt;Specifies which map to retrieve by its type&lt;/param&gt;
   /// &lt;returns&gt;A newly initialized map if the map was not loaded, or the existing
   /// map if it was already loaded.&lt;/returns&gt;
   /// &lt;remarks&gt;Loaded maps are stored in &lt;see cref="LoadedMaps"/&gt;.
   /// &lt;seealso cref="GeneralRules.UnloadMap"/&gt;
   /// &lt;seealso cref="GeneralRules.SwitchToMap"/&gt;&lt;/remarks&gt;
   public MapBase GetMap(System.Type mapType)
   {
      if (!LoadedMaps.ContainsKey(mapType))
      {
         MapBase result = (MapBase)mapType.GetConstructor(new System.Type[] {typeof(Display)}).Invoke(new object[] {GameDisplay});
         LoadedMaps[mapType] = result;
         return result;
      }
      else
         return (MapBase)(LoadedMaps[mapType]);
   }

   /// &lt;summary&gt;
   /// Unloads the currently loaded instance of the specified map type if it is loaded.
   /// &lt;/summary&gt;
   /// &lt;param name="mapType"&gt;Specifies which map to unload.&lt;/param&gt;
   /// &lt;remarks&gt;This is called by &lt;see cref="GeneralRules.UnloadMap"/&gt;.&lt;/remarks&gt;
   public void UnloadMap(System.Type mapType)
   {
      LoadedMaps.Remove(mapType);
   }

   /// &lt;summary&gt;
   /// Unload all maps that are not the current primary map or overlay map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is called by &lt;see cref="GeneralRules.UnloadBackgroundMaps"/&gt;.
   /// &lt;seealso cref="UnloadMap"/&gt;&lt;/remarks&gt;
   public void UnloadBackgroundMaps()
   {
      System.Collections.ArrayList toRemove = new System.Collections.ArrayList();
      foreach(System.Collections.DictionaryEntry de in LoadedMaps)
      {
         if ((de.Value != CurrentMap) &amp;&amp; (de.Value != OverlayMap))
            toRemove.Add(de.Key);
      }
      foreach(System.Type removeKey in toRemove)
      {
         LoadedMaps.Remove(removeKey);
      }
   }

   private void InitializeComponent()
   {
      this.mnuGame = new System.Windows.Forms.MainMenu();
      this.mnuFile = new System.Windows.Forms.MenuItem();
      this.mnuFileExit = new System.Windows.Forms.MenuItem();
      this.mnuTools = new System.Windows.Forms.MenuItem();
      this.mnuToolsOptions = new System.Windows.Forms.MenuItem();
      this.mnuHelp = new System.Windows.Forms.MenuItem();
      this.mnuHelpAbout = new System.Windows.Forms.MenuItem();
      // 
      // mnuGame
      // 
      this.mnuGame.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                             this.mnuFile,
                                                                             this.mnuTools,
                                                                             this.mnuHelp});
      // 
      // mnuFile
      // 
      this.mnuFile.Index = 0;
      this.mnuFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                             this.mnuFileExit});
      this.mnuFile.Text = "&amp;File";
      // 
      // mnuFileExit
      // 
      this.mnuFileExit.Index = 0;
      this.mnuFileExit.Shortcut = System.Windows.Forms.Shortcut.AltF4;
      this.mnuFileExit.Text = "E&amp;xit";
      this.mnuFileExit.Click += new System.EventHandler(this.mnuFileExit_Click);
      // 
      // mnuTools
      // 
      this.mnuTools.Index = 1;
      this.mnuTools.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                              this.mnuToolsOptions});
      this.mnuTools.Text = "&amp;Tools";
      // 
      // mnuToolsOptions
      // 
      this.mnuToolsOptions.Index = 0;
      this.mnuToolsOptions.Text = "&amp;Options";
      this.mnuToolsOptions.Click += new System.EventHandler(this.mnuToolsOptions_Click);
      // 
      // mnuHelp
      // 
      this.mnuHelp.Index = 2;
      this.mnuHelp.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                               this.mnuHelpAbout});
      this.mnuHelp.Text = "&amp;Help";
      // 
      // mnuHelpAbout
      // 
      this.mnuHelpAbout.Index = 0;
      this.mnuHelpAbout.Text = "&amp;About...";
      this.mnuHelpAbout.Click += new System.EventHandler(this.mnuHelpAbout_Click);
      // 
      // GameForm
      // 
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(292, 273);
      this.MaximizeBox = false;
      this.Menu = this.mnuGame;
      this.Name = "GameForm";

   }

   /// &lt;summary&gt;
   /// Represents the current state of the keyboard.
   /// &lt;/summary&gt;
   public Microsoft.DirectX.DirectInput.KeyboardState KeyboardState
   {
      get
      {
         return m_keyboardState;
      }
   }

   /// &lt;summary&gt;
   /// Retrieve information about which keys are pressed.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;Array of keys that are currently pressed.&lt;/returns&gt;
   public Microsoft.DirectX.DirectInput.Key[] GetPressedKeys()
   {
      return keyboard.GetPressedKeys();
   }

   /// &lt;summary&gt;
   /// Reads the state of all relevant game controller devices into the respective
   /// objects in &lt;see cref="Players"/&gt;.
   /// &lt;/summary&gt;
   public void ReadControllers()
   {
      if (controllerEnabled == null)
         return;

      foreach(IPlayer plr in Players)
      {
         if (plr is ControllerPlayer)
            controllerEnabled[((ControllerPlayer)plr).deviceNumber] = true;
      }

      for (int i=0; i&lt;controllerEnabled.Count; i++)
      {
         if (controllerEnabled[i])
         {
            if (!controllerAcquired[i])
            {
               controllers[i].Acquire();
               controllerAcquired[i] = true;
            }
            m_controllerState[i] = controllers[i].CurrentJoystickState;
         }
         else if (controllerAcquired[i])
         {
            controllers[i].Unacquire();
            controllerAcquired[i] = false;
         }
      }
   }

   /// &lt;summary&gt;
   /// Return the number of available controllers connected to the system
   /// &lt;/summary&gt;
   public int ControllerCount
   {
      get
      {
         if (controllers == null)
            return 0;
         return controllers.Length;
      }
   }

   /// &lt;summary&gt;
   /// Return the name of a specific game controller as displayed in the options window.
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Zero-based index of the game controller&lt;/param&gt;
   /// &lt;returns&gt;String containing the display name for the device&lt;/returns&gt;
   public string GetControllerName(int deviceNumber)
   {
      return controllers[deviceNumber].DeviceInformation.InstanceName;
   }

   /// &lt;summary&gt;
   /// Reads the current state of a game controller
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Zero-based index of the game controller&lt;/param&gt;
   public Microsoft.DirectX.DirectInput.JoystickState GetControllerState(int deviceNumber)
   {
      return m_controllerState[deviceNumber];
   }

   /// &lt;summary&gt;
   /// Returns true if the controller is currently enabled for input.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A controller is enabled when a player is using it.&lt;/remarks&gt;
   public System.Collections.BitArray ControllerEnabled
   {
      get
      {
         return controllerEnabled;
      }
   }

   private void GameDisplay_WindowedChanged(object sender, EventArgs e)
   {
      if (GameDisplay.Windowed)
         ClientSize = Display.GetScreenSize(GameDisplay.GameDisplayMode);
   }

   private void mnuFileExit_Click(object sender, System.EventArgs e)
   {
      Quit();
   }
   
   private void mnuToolsOptions_Click(object sender, System.EventArgs e)
   {
      frmControls frm = new frmControls();
      frm.ShowDialog();
   }

   private void mnuHelpAbout_Click(object sender, System.EventArgs e)
   {
      using (frmAbout frm = new frmAbout())
         frm.ShowDialog();
   }

   /// &lt;summary&gt;
   /// Sets an indicator that causes the game to quit at the beginning of the
   /// next game loop.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is checked during &lt;see cref="Run"/&gt;.&lt;/remarks&gt;
   public void Quit()
   {
      m_quit = true;
   }

   /// &lt;summary&gt;
   /// This function is called by the SGDK2 generated code when a top-level
   /// exception occurs.
   /// &lt;/summary&gt;
   /// &lt;param name="ex"&gt;Refers to the exception that was received at the top level&lt;/param&gt;
   public static void HandleException(System.Exception ex)
   {
      Project.GameWindow.Close();
      MessageBox.Show("A fatal error occurred initializing or running the game:\r\n" + ex.ToString(), "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
   }
}</Text>
  </SourceCode>
  <SourceCode Name="About.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

/// &lt;summary&gt;
/// About dialog displayed from game's help menu.
/// &lt;/summary&gt;
public class frmAbout : System.Windows.Forms.Form
{
   private System.Windows.Forms.Button btnOK;
   private System.Windows.Forms.Label lblHeader;
   private System.Windows.Forms.Label lblSGDK2;
   private System.Windows.Forms.LinkLabel llbURL;
   private System.Windows.Forms.Label lblCredits;
   private System.Windows.Forms.TextBox txtCredits;
	/// &lt;summary&gt;
	/// Required designer variable.
	/// &lt;/summary&gt;
	private System.ComponentModel.Container components = null;

	public frmAbout()
	{
		//
		// Required for Windows Form Designer support
		//
		InitializeComponent();

      txtCredits.Text = Project.GameCredits;
	}

	/// &lt;summary&gt;
	/// Clean up any resources being used.
	/// &lt;/summary&gt;
	protected override void Dispose( bool disposing )
	{
		if( disposing )
		{
			if(components != null)
			{
				components.Dispose();
			}
		}
		base.Dispose( disposing );
	}

	#region Windows Form Designer generated code
	/// &lt;summary&gt;
	/// Required method for Designer support - do not modify
	/// the contents of this method with the code editor.
	/// &lt;/summary&gt;
	private void InitializeComponent()
	{
      this.btnOK = new System.Windows.Forms.Button();
      this.lblHeader = new System.Windows.Forms.Label();
      this.lblSGDK2 = new System.Windows.Forms.Label();
      this.llbURL = new System.Windows.Forms.LinkLabel();
      this.lblCredits = new System.Windows.Forms.Label();
      this.txtCredits = new System.Windows.Forms.TextBox();
      this.SuspendLayout();
      // 
      // btnOK
      // 
      this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
      this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
      this.btnOK.Location = new System.Drawing.Point(206, 168);
      this.btnOK.Name = "btnOK";
      this.btnOK.Size = new System.Drawing.Size(72, 24);
      this.btnOK.TabIndex = 0;
      this.btnOK.Text = "OK";
      // 
      // lblHeader
      // 
      this.lblHeader.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblHeader.Location = new System.Drawing.Point(8, 8);
      this.lblHeader.Name = "lblHeader";
      this.lblHeader.Size = new System.Drawing.Size(272, 16);
      this.lblHeader.TabIndex = 1;
      this.lblHeader.Text = "This game was created with:";
      // 
      // lblSGDK2
      // 
      this.lblSGDK2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblSGDK2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
      this.lblSGDK2.Location = new System.Drawing.Point(8, 24);
      this.lblSGDK2.Name = "lblSGDK2";
      this.lblSGDK2.Size = new System.Drawing.Size(272, 16);
      this.lblSGDK2.TabIndex = 2;
      this.lblSGDK2.Text = "Scrolling Game Development Kit 2";
      this.lblSGDK2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
      // 
      // llbURL
      // 
      this.llbURL.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.llbURL.Location = new System.Drawing.Point(8, 40);
      this.llbURL.Name = "llbURL";
      this.llbURL.Size = new System.Drawing.Size(272, 16);
      this.llbURL.TabIndex = 3;
      this.llbURL.TabStop = true;
      this.llbURL.Text = "http://sgdk2.sf.net/";
      this.llbURL.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.Link_Clicked);
      // 
      // lblCredits
      // 
      this.lblCredits.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.lblCredits.Location = new System.Drawing.Point(8, 64);
      this.lblCredits.Name = "lblCredits";
      this.lblCredits.Size = new System.Drawing.Size(272, 16);
      this.lblCredits.TabIndex = 4;
      this.lblCredits.Text = "Game Credits:";
      // 
      // txtCredits
      // 
      this.txtCredits.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
         | System.Windows.Forms.AnchorStyles.Left) 
         | System.Windows.Forms.AnchorStyles.Right)));
      this.txtCredits.Location = new System.Drawing.Point(8, 80);
      this.txtCredits.Multiline = true;
      this.txtCredits.Name = "txtCredits";
      this.txtCredits.ReadOnly = true;
      this.txtCredits.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
      this.txtCredits.Size = new System.Drawing.Size(270, 80);
      this.txtCredits.TabIndex = 5;
      this.txtCredits.Text = "";
      // 
      // frmAbout
      // 
      this.AcceptButton = this.btnOK;
      this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
      this.ClientSize = new System.Drawing.Size(290, 199);
      this.Controls.Add(this.txtCredits);
      this.Controls.Add(this.lblCredits);
      this.Controls.Add(this.llbURL);
      this.Controls.Add(this.lblSGDK2);
      this.Controls.Add(this.lblHeader);
      this.Controls.Add(this.btnOK);
      this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
      this.Name = "frmAbout";
      this.Text = "About ";
      this.ResumeLayout(false);

   }
	#endregion

   private void Link_Clicked(object sender, System.Windows.Forms.LinkLabelLinkClickedEventArgs e)
   {
      System.Diagnostics.Process.Start(((LinkLabel)sender).Text);
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="CollisionMask.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;

/// &lt;summary&gt;
/// Defines the shape of a sprite for the purpose of collision detection with other sprites
/// &lt;/summary&gt;
/// &lt;remarks&gt;An instance of this object is associated with each sprite frame that contains any
/// sub-frames with non-zero mask alpha levels. When testing for collisions between two sprites,
/// if both sprites have a collision mask, the masks will be used to determine if "solid"
/// pixels of the two sprites overlap.&lt;/remarks&gt;
public class CollisionMask
{
   private int[,] m_Mask;
   private int m_Width;
   private int m_Height;
   private Point m_Origin;
   private static System.Collections.Hashtable m_RectangularMasks = new System.Collections.Hashtable(10);
	
   /// &lt;summary&gt;
   /// Create a collision mask of the specified size for a combination of the specified frames
   /// from a frameset based on the respective alpha levels of those frames.
   /// &lt;/summary&gt;
   /// &lt;param name="localBounds"&gt;A rectangle relative to the frame's origin for which the
   /// mask is generated. This is generally generated by determining the rectangle that
   /// encloses all the graphics of all the transformed frames.&lt;/param&gt;
   /// &lt;param name="frameset"&gt;Frameset containing all the frames referenced for the creation
   /// of this mask.&lt;/param&gt;
   /// &lt;param name="subFrames"&gt;Indexes of the frames to be overlayed before generating the mask.&lt;/param&gt;
   /// &lt;param name="alphas"&gt;Respective alpha values for the frames in &lt;paramref name="subFrames"/&gt;&lt;/param&gt;
   public CollisionMask(Rectangle localBounds, Frameset frameset, int[] subFrames, byte[] alphas)
   {
      m_Mask = GenerateMaskFromFrame(localBounds, frameset, subFrames, alphas);
      m_Width = localBounds.Width;
      m_Height = localBounds.Height;
      m_Origin = new Point(-localBounds.X, -localBounds.Y);
   }

   private CollisionMask(Size size)
   {
      m_Mask = new int[size.Height, (int)Math.Ceiling(size.Width / 32f)];
      for (int x = 0; x &lt; (int)(size.Width / 32); x++)
      {
         for (int y = 0; y &lt; size.Height; y++)
         {
            m_Mask[y,x] = unchecked((int)0xFFFFFFFF);
         }
      }
      if (size.Width % 32 &gt; 0)
      {
         int lastColMask = 0;
         lastColMask |= (-1) &lt;&lt; (32 - (size.Width % 32));
         int lastColIdx = (int)Math.Ceiling(size.Width / 32f)-1;
         for (int y = 0; y &lt; size.Height; y++)
         {
            m_Mask[y, lastColIdx] = lastColMask;
         }
      }
      m_Width = size.Width;
      m_Height = size.Height;
      m_Origin = new Point(0,0);
   }

   /// &lt;summary&gt;
   /// Retrieve a solid rectangular collision mask of the specified size
   /// &lt;/summary&gt;
   /// &lt;param name="size"&gt;Size of the mask&lt;/param&gt;
   /// &lt;returns&gt;A rectangular masks is used when testing a collision
   /// between a sprite that has a mask and a sprite that doesn't.
   /// Once a rectangualar mask is generated, it is cached and returned for
   /// all requests for a mask of the same size. These
   /// masks are generally based on the solidity size of the sprite that
   /// does not have the mask (mask alpha level = 0).&lt;/returns&gt;
   public static CollisionMask GetRectangularMask(Size size)
   {
      CollisionMask result = m_RectangularMasks[size] as CollisionMask;
      if (result != null)
         return result;
      m_RectangularMasks[size] = result = new CollisionMask(size);
      return result;
   }

   /// &lt;summary&gt;
   /// Determine if this mask is colliding with the specified target mask
   /// &lt;/summary&gt;
   /// &lt;param name="target"&gt;Mask to test against&lt;/param&gt;
   /// &lt;param name="offsetX"&gt;Horizontal offset from this mask's position to the target mask's position&lt;/param&gt;
   /// &lt;param name="offsetY"&gt;Vertical offset from this mask's position to the target mask's position&lt;/param&gt;
   /// &lt;returns&gt;True if solid bits in the masks collide when positioned at the specified offset&lt;/returns&gt;
   public bool TestCollisionWith(CollisionMask target, int offsetX, int offsetY)
   {
      offsetX += m_Origin.X - target.m_Origin.X;
      offsetY += m_Origin.Y - target.m_Origin.Y;

      if ((offsetY &gt;= m_Height) || (offsetY &lt;= -target.m_Height) ||
         (offsetX &gt;= m_Width) || (offsetX &lt;= -target.m_Width))
         return false;

      int maxY;
      int myMinY, targetMinY;
      if (offsetY &gt; 0)
      {
         myMinY = offsetY;
         targetMinY = 0;
         if (target.m_Height &gt;= m_Height - offsetY)
            maxY = m_Height - offsetY;
         else
            maxY = target.m_Height;
      }
      else
      {
         myMinY = 0;
         targetMinY = -offsetY;
         if (m_Height &gt;= target.m_Height + offsetY)
            maxY = target.m_Height + offsetY;
         else
            maxY = m_Height;
      }

      int maxX;
      int myMinX, targetMinX;
      if (offsetX &gt; 0)
      {
         myMinX = offsetX;
         targetMinX = 0;
         if (target.m_Width &gt;= m_Width - offsetX)
            maxX = m_Width - offsetX;
         else
            maxX = target.m_Width;
      }
      else
      {
         myMinX = 0;
         targetMinX = -offsetX;
         if (m_Width &gt;= target.m_Width + offsetX)
            maxX = target.m_Width + offsetX;
         else
            maxX = m_Width;
      }

      for(int y=0; y &lt; maxY; y++)
      {
         for(int x=0; x &lt; maxX; x+=32)
         {
            int myColIdx = (int)((x+myMinX)/32);
            int myColOff = myMinX % 32;
            int targetColIdx = (int)((x+targetMinX)/32);
            int targetColOff = targetMinX % 32;
            int myMask = m_Mask[y+myMinY,myColIdx] &lt;&lt; myColOff;
            int targetMask = target.m_Mask[y+targetMinY,targetColIdx] &lt;&lt; targetColOff;
            if (myColOff != 0)
            {
               if (myColIdx + 1 &lt; m_Mask.GetUpperBound(1))
                  myMask |= (m_Mask[y+myMinY,myColIdx+1] &gt;&gt; (32-myColOff)) &amp;
                     ~(unchecked((int)0x80000000) &gt;&gt; (31-myColOff));
            }
            else if (targetColOff != 0)
            {
               if (targetColIdx + 1 &lt; target.m_Mask.GetUpperBound(1))
                  targetMask |= (target.m_Mask[y+targetMinY,targetColIdx+1] &gt;&gt; (32-targetColOff)) &amp;
                     ~(unchecked((int)0x80000000) &gt;&gt; (31-targetColOff));
            }
            if ((myMask &amp; targetMask) != 0)
               return true;
         }
      }
      return false;
   }

   private static int[,] GenerateMaskFromFrame(Rectangle rcBound, Frameset frameset, int[] subFrames, byte[] alphas)
   {
      BitmapData bmpData;
      int[] pixels;

      using (Bitmap bmpSingle = new Bitmap(rcBound.Width, rcBound.Height, PixelFormat.Format32bppArgb))
      {
         int maskColumns = (int)Math.Ceiling(bmpSingle.Width / 32f);
         int[,] arbt = new int[bmpSingle.Height, maskColumns];
         using (Graphics gfxSingle = Graphics.FromImage(bmpSingle))
         {
            gfxSingle.CompositingMode = CompositingMode.SourceCopy;
            gfxSingle.PixelOffsetMode = PixelOffsetMode.Half;

            for(int subFrameIdx = 0; subFrameIdx &lt; subFrames.Length; subFrameIdx++)
            {
               int subFrame = subFrames[subFrameIdx];
               gfxSingle.Clear(Color.Transparent);
               Frame SFrame = frameset[subFrame];
               using(Matrix mtx = new Matrix(SFrame.Transform.M11, SFrame.Transform.M12, SFrame.Transform.M21, SFrame.Transform.M22, SFrame.Transform.M41, SFrame.Transform.M42))
               {
                  gfxSingle.Transform = mtx;
                  Bitmap bmpGfxSheet = (Bitmap)Project.Resources.GetObject(SFrame.GraphicSheetTexture.Name);
                  gfxSingle.TranslateTransform(-rcBound.X, -rcBound.Y, MatrixOrder.Append);
                  gfxSingle.DrawImage(bmpGfxSheet, 0, 0, SFrame.SourceRect, GraphicsUnit.Pixel);
                  bmpData = bmpSingle.LockBits(new Rectangle(Point.Empty, rcBound.Size), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
                  pixels = new int[bmpSingle.Height * Math.Abs(bmpData.Stride) / 4];
                  System.Runtime.InteropServices.Marshal.Copy(bmpData.Scan0, pixels, 0, bmpSingle.Height * Math.Abs(bmpData.Stride) / 4);
                  bmpSingle.UnlockBits(bmpData);
                  for (int rowIdx = 0; rowIdx &lt; bmpSingle.Height; rowIdx++)
                  {
                     for (int pixIdx = 0; pixIdx &lt; bmpSingle.Width; pixIdx++)
                     {
                        if (Color.FromArgb(pixels[rowIdx * bmpData.Stride / 4 + pixIdx]).A &gt; alphas[subFrameIdx])
                           arbt[rowIdx, pixIdx / 32] |= 1 &lt;&lt; (31 - (pixIdx % 32));
                     }
                  }
               }
            }
         }
         return arbt;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="Frame.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;
using System.Drawing;

/// &lt;summary&gt;
/// An instance of the Frame class represents one image from a frameset.
/// &lt;/summary&gt;
public struct Frame
{
   /// &lt;summary&gt;
   /// References the un-transformed graphics on which this frame is based
   /// &lt;/summary&gt;
   public Display.TextureRef GraphicSheetTexture;
   /// &lt;summary&gt;
   /// Refers to an index into the graphic sheet of the individual graphic on which this frame is based
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is informational only. The actual graphic is obtained using
   /// &lt;see cref="SourceRect"/&gt;.&lt;/remarks&gt;
   public short CellIndex;
   /// &lt;summary&gt;
   /// Defines the transformation that is applied to the graphic cell to yield this frame
   /// &lt;/summary&gt;
   public Matrix Transform;
   /// &lt;summary&gt;
   /// Specifies color channel modulations that are applied to this frame
   /// &lt;/summary&gt;
   public int Color;
   /// &lt;summary&gt;
   /// Specifies the area on the graphic sheet which is used to form the graphic cell on which
   /// this frame is based.
   /// &lt;/summary&gt;
   public Rectangle SourceRect;

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, transformation, source rectangle and color modulation.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="M11"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M12"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M21"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M22"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M41"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M42"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;param name="color"&gt;Provides this frame's &lt;see cref="Color"/&gt;.&lt;/param&gt;
   public Frame(Display.TextureRef texture, short cell, float M11, float M12, float M21, float M22, float M41, float M42, Rectangle srcRect, int color)
   {
      GraphicSheetTexture = texture;
      CellIndex = cell;
      Transform = Matrix.Identity;
      Transform.M11 = M11;
      Transform.M12 = M12;
      Transform.M21 = M21;
      Transform.M22 = M22;
      Transform.M41 = M41;
      Transform.M42 = M42;
      Transform.M44 = 1;
      SourceRect = srcRect;
      this.Color = color;
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, transformation and source rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="M11"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M12"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M21"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M22"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M41"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="M42"&gt;Provides a component of this frames &lt;see cref="Transform"/&gt; matrix.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   public Frame(Display.TextureRef texture, short cell, float M11, float M12, float M21, float M22, float M41, float M42, Rectangle srcRect) :
      this(texture, cell, M11, M12, M21, M22, M41, M42, srcRect, -1)
   {
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index, source rectangle and color modulation.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;param name="color"&gt;Provides this frame's &lt;see cref="Color"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;This constructor provides a shortcut for creating frames without transformations.&lt;/remarks&gt;
   public Frame(Display.TextureRef texture, short cell, Rectangle srcRect, int color)
   {
      GraphicSheetTexture = texture;
      CellIndex = cell;
      Transform = Matrix.Identity;
      SourceRect = srcRect;
      this.Color = color;
   }

   /// &lt;summary&gt;
   /// Creates a new frame definition based on a graphic sheet, cell index and source rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="texture"&gt;Refers to an object that provides a hardware copy of the graphic
   /// sheet on which this frame is based.&lt;/param&gt;
   /// &lt;param name="cell"&gt;Provides a value for this frame's &lt;see cref="CellIndex"/&gt; property.&lt;/param&gt;
   /// &lt;param name="srcRect"&gt;Provides this frame's &lt;see cref="SourceRect"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;This constructor provides a shortcut for creating frames without transformations or color modulations.&lt;/remarks&gt;
   public Frame(Display.TextureRef texture, short cell, Rectangle srcRect) :
      this(texture, cell, srcRect, -1)
   {
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="SpriteState.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// This specialization of TileFrame is used specifically for sprite frames
/// with collision masks (when mask alpha level is non-zero).
/// &lt;/summary&gt;
/// &lt;remarks&gt;Some sprites simple enough that they can be treated very similar to tiles, and
/// will simply use &lt;see cref="TileFrame"/&gt; directly. Others will use this class.&lt;/remarks&gt;
public class SpriteFrame : TileFrame
{
   private CollisionMask m_Mask;

   public SpriteFrame(System.Drawing.Rectangle localBounds, Frameset frameset, int nAccumulatedDuration, int[] subFrames, byte[] alphas) : base(nAccumulatedDuration, subFrames)
   {
      m_Mask = new CollisionMask(localBounds, frameset, subFrames, alphas);
   }

   public SpriteFrame(System.Drawing.Rectangle localBounds, Frameset frameset, int nAccumulatedDuration, int frame, byte alpha) : base(nAccumulatedDuration, frame)
   {
      m_Mask = new CollisionMask(localBounds, frameset, new int[] {frame}, new byte[] {alpha});
   }

   public CollisionMask Mask
   {
      get
      {
         return m_Mask;
      }
   }
}

/// &lt;summary&gt;
/// Represents one state within a sprite definition, primarily defining how a it can animate.
/// &lt;/summary&gt;
public class SpriteState
{
   private readonly TileFrame[] m_frames;
   private short[] m_frameIndexMap;
   private Frameset m_Frameset;
   private int m_nSolidWidth;
   private int m_nSolidHeight;
   private System.Drawing.Rectangle m_LocalBounds;

   /// &lt;summary&gt;
   /// Constructs a new state given all the information for the state.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Solid width of this state. Each state within a sprite can have its own solid width.&lt;/param&gt;
   /// &lt;param name="height"&gt;Solid height of this state. Each state within a sprite can have its own solid height.&lt;/param&gt;
   /// &lt;param name="frameset"&gt;&lt;see cref="Frameset"/&gt; containing all the graphics for this state.&lt;/param&gt;
   /// &lt;param name="localBounds"&gt;Rectangle that visually enclompases the graphics of all the frames of this state.
   /// This is used to determine when the sprite is fully or partially visible on the layer and needs to be drawn.&lt;/param&gt;
   /// &lt;param name="frames"&gt;A sequential list of all frames from &lt;paramref name="frameset"/&gt; that are included in this state.&lt;/param&gt;
   public SpriteState(int width, int height, Frameset frameset, System.Drawing.Rectangle localBounds, params TileFrame[] frames)
   {
      m_nSolidWidth = width;
      m_nSolidHeight = height;
      m_Frameset = frameset;
      m_LocalBounds = localBounds;
      m_frames = frames;
      m_frameIndexMap = new short[m_frames[m_frames.Length - 1].m_nAccumulatedDuration];
      short frameIndex = 0;
      for (int frameValue=0; frameValue&lt;m_frameIndexMap.Length; frameValue++)
      {
         if (m_frames[frameIndex].m_nAccumulatedDuration &lt;= frameValue)
            frameIndex++;
         m_frameIndexMap[frameValue] = frameIndex;
      }
   }

   /// &lt;summary&gt;
   /// Returns the frameset on which all graphics in this state are based.
   /// &lt;/summary&gt;
   public Frameset Frameset
   {
      get
      {
         return m_Frameset;
      }
   }

   /// &lt;summary&gt;
   /// Return a list of all frame indexes that represent a particular animation frame of a sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="frameIndex"&gt;Frame counter value.&lt;/param&gt;
   /// &lt;returns&gt;Array if integers that represent indexes into &lt;see cref="Frameset"/&gt; for the
   /// frames that should be drawn for the specified frame.&lt;/returns&gt;
   /// &lt;remarks&gt;Often times this will return an array of one integer because a sprite will only
   /// display one frame at a time. Compound frames defined by using a repeat count of "0" on some
   /// frames, however, will cause multiple frameset frames to be comined into a single sprite
   /// frame. So a single &lt;paramref name="frameIndex"/&gt; value can yield multiple frameset frame
   /// indexes to be drawn at once. But also note that multiple &lt;paramref name="frameIndex"/&gt;
   /// values can yield the same frames because a frame with a repeat count greater than 1 will
   /// cause the sprite to remain on the same frame for multiple iterations.&lt;/remarks&gt;
   public int[] GetFrame(int frameIndex)
   {
      return m_frames[m_frameIndexMap[frameIndex % m_frameIndexMap.Length]].subFrames;
   }

   /// &lt;summary&gt;
   /// Get the collision mask for a specified sprite frame.
   /// &lt;/summary&gt;
   /// &lt;param name="frameIndex"&gt;Frame counter value.&lt;/param&gt;
   /// &lt;returns&gt;Collision mask for the specified frame of the sprite (simply or compound)
   /// if applicable, otherwise a null reference.
   /// See &lt;see cref="GetFrame"/&gt; for more information about &lt;paramref name="frameIndex"/&gt; and
   /// frame counters.&lt;/returns&gt;
   public CollisionMask GetMask(int frameIndex)
   {
      SpriteFrame frame = m_frames[m_frameIndexMap[frameIndex % m_frameIndexMap.Length]] as SpriteFrame;
      if (frame == null)
         return null;
      return frame.Mask;
   }

   /// &lt;summary&gt;
   /// Retrieve the solid width of this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each sprite state can have its own solid width. For example a leaping sprite might
   /// be wider than a standing sprite, and might react to solidity on the map as such.&lt;/remarks&gt;
   public int SolidWidth
   {
      get
      {
         return m_nSolidWidth;
      }
   }

   /// &lt;summary&gt;
   /// Retrieve the solid height of this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each sprite state can have its own solid height. For example a crouching sprite might
   /// be shorter than a standing sprite, and might react to solidity on the map as such.&lt;/remarks&gt;
   public int SolidHeight
   {
      get
      {
         return m_nSolidHeight;
      }
   }

   /// &lt;summary&gt;
   /// Returns a rectangle (relative to the origin of the sprite) that bounds
   /// all the graphics in this state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is used to determine when part or all of the sprite is visible on the current
   /// view of the sprite's layer, and consequently, whether it should be drawn.&lt;/remarks&gt;
   public System.Drawing.Rectangle LocalBounds
   {
      get
      {
         return m_LocalBounds;
      }
   }
}</Text>
  </SourceCode>
  <SourceCode Name="MapBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;

/// &lt;summary&gt;
/// Base class for all maps.
/// &lt;/summary&gt;
[Serializable()]
public abstract class MapBase
{
   protected Display m_Display;
   /// &lt;summary&gt;
   /// Stores the type of the map that was previously the current map.
   /// &lt;/summary&gt;
   /// &lt;value&gt;A &lt;see cref="System.Type"/&gt; referring to the type of the previously
   /// active map if any existed, or a null reference if there was none.&lt;/value&gt;
   /// &lt;remarks&gt;This is set by &lt;see cref="GeneralRules.SwitchToMap"/&gt; and used by
   /// &lt;see cref="GeneralRules.ReturnToPreviousMap"/&gt;.&lt;/remarks&gt;
   public Type m_CameFromMapType = null;
   private ViewLayout viewLayout = ViewLayout.Single;
   private static byte currentViewIndex = 0;
   /// &lt;summary&gt;
   /// Stores a set of arbitrary boolean/flag values that can be used for any purpose
   /// on each map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Technically this value can be used to store any data that will
   /// fit in a 32-bit integer, but it's designed to be used with functions in
   /// &lt;see cref="GeneralRules"/&gt; to store individually accessible bits. These
   /// can be set with &lt;see cref="GeneralRules.SetMapFlag"/&gt; and checked with
   /// &lt;see cref="GeneralRules.IsMapFlagOn"/&gt;.&lt;/remarks&gt;
   public int MapFlags = 0;

   /// &lt;summary&gt;
   /// Constructs a new map and links it to the display.
   /// &lt;/summary&gt;
   /// &lt;param name="Disp"&gt;Display object on which the map will be drawn&lt;/param&gt;
   public MapBase(Display Disp)
   {
      m_Display = Disp;
   }

   /// &lt;summary&gt;
   /// Draws all the layers of this map in the current view.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;To draw all layers for all views, see &lt;see cref="DrawAllViews"/&gt;.
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;&lt;/remarks&gt;
   protected abstract void Draw();

   /// &lt;summary&gt;
   /// Execute the rules of each layer in the map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This executes all the rules for all the plans and active sprites for all layers
   /// in the map.&lt;/remarks&gt;
   public abstract void ExecuteRules();

   /// &lt;summary&gt;
   /// Scroll all layers to the specified coordinates after calculating relative scroll rates
   /// &lt;/summary&gt;
   /// &lt;param name="position"&gt;New coordinate. int.MinValue indicates no scrolling on this axis.&lt;/param&gt;
   public abstract void Scroll(Point position);

   /// &lt;summary&gt;
   /// Return the left scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginLeft
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the top scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginTop
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the right scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginRight
   {
      get;
   }
   /// &lt;summary&gt;
   /// Return the bottom scroll margin for this map
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Scroll margins are used to maintain some distance between a sprite and the
   /// edge of the map. Functions that scroll the map generally call
   /// &lt;see cref="LayerBase.ScrollSpriteIntoView"/&gt;, which, when given the appropriate
   /// parameters, will use the scroll margin settings on the map to ensure that the sprite
   /// is scrolled far enough into the view that the scroll margins are maintained.&lt;/remarks&gt;
   public abstract short ScrollMarginBottom
   {
      get;
   }

   /// &lt;summary&gt;
   /// Gets or sets the current arrangement of views within the display.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By changing this you can affect the number and arrangement of views
   /// that are being managed by the map and its layers. Activating a multi-view layout
   /// will cause the layers to maintain multiple scroll positions, one for each view.
   /// And when a layer is scrolled, it will only be scrolled for the current view (as
   /// indicated by &lt;see cref="CurrentViewIndex"/&gt;.  The number of views must not exceed
   /// the maximum set in the project and stored in &lt;see cref="Project.MaxViews"/&gt;.
   /// The view layout can be set from a rule function by calling
   /// &lt;see cref="GeneralRules.SetViewLayout"/&gt;, and the current view can be changed with
   /// &lt;see cref="GeneralRules.CurrentView"/&gt;.
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;
   /// &lt;seealso cref="GetView"/&gt;
   /// &lt;/remarks&gt;
   public ViewLayout ViewLayout
   {
      get
      {
         return viewLayout;
      }
      set
      {
         if (value == ViewLayout.FourCorners)
            if (Project.MaxViews &lt; 4)
            {
               System.Diagnostics.Debug.Fail("Attempted to use 4-corner view with max views less than 4");
               return;
            }
         if ((value == ViewLayout.TopBottom) || (value == ViewLayout.LeftRight))
            if (Project.MaxViews &lt; 2)
            {
               System.Diagnostics.Debug.Fail("Attempted to use double view with max views less than 2");
               return;
            }
         viewLayout = value;
      }
   }

   /// &lt;summary&gt;
   /// Retrieve the area within the display that the current view occupies.
   /// &lt;/summary&gt;
   /// &lt;param name="viewNumber"&gt;Number from 0 to &lt;see cref="Project.MaxViews"/&gt;-1 specifying
   /// which view to retrieve.&lt;/param&gt;
   /// &lt;returns&gt;Rectangle containing the area on the display object occupied by the view.&lt;/returns&gt;
   /// &lt;remarks&gt;Views are numbered in reading order, left to right and top to bottom.
   /// &lt;seealso cref="ViewLayout"/&gt;
   /// &lt;seealso cref="CurrentView"/&gt;
   /// &lt;seealso cref="CurrentViewIndex"/&gt;
   /// &lt;/remarks&gt;
   public Rectangle GetView(int viewNumber)
   {
      Rectangle result = TotalView;
      switch (viewLayout)
      {
         case ViewLayout.Single:
            return result;
         case ViewLayout.TopBottom:
            result.Height /= 2;
         switch (viewNumber)
         {
            case 0:
               return result;
            default:
               result.Y += TotalView.Height / 2;
               return result;
         }
         case ViewLayout.LeftRight:
            result.Width /= 2;
         switch(viewNumber)
         {
            case 0:
               return result;
            default:
               result.X += TotalView.Width / 2;
               return result;
         }
         default:
            result.Width /= 2;
            result.Height /= 2;
         switch(viewNumber)
         {
            case 0:
               return result;
            case 1:
               result.X += TotalView.Width / 2;
               return result;
            case 2:
               result.Y += TotalView.Height / 2;
               return result;
            default:
               result.X += TotalView.Width / 2;
               result.Y += TotalView.Height / 2;
               return result;
         }
      }
   }

   /// &lt;summary&gt;
   /// Returns the rectangle for the currently active view within the map's total view area
   /// &lt;seealso cref="GetView"/&gt;
   /// &lt;/summary&gt;
   public Rectangle CurrentView
   {
      get
      {
         return GetView(CurrentViewIndex);
      }
   }

   /// &lt;summary&gt;
   /// Which view is currently being processed (0 to &lt;see cref="Project.MaxViews"/&gt; - 1)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;
   /// This can be retrieved and set from rule functions by using
   /// &lt;see cref="GeneralRules.CurrentView"/&gt;.
   /// &lt;seealso cref="ViewLayout"/&gt;
   /// &lt;/remarks&gt;
   public byte CurrentViewIndex
   {
      get
      {
         return currentViewIndex;
      }
      set
      {
         if ((value &gt;= 0) &amp;&amp; (value &lt; Project.MaxViews))
            currentViewIndex = value;
         else
            System.Diagnostics.Debug.Fail("Bad CurrentViewIndex value ignored");
      }
   }

   /// &lt;summary&gt;
   /// Draws all layers in the map on all views according to the map's current ViewLayout
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Each layer is drawn according to its respective scroll position in the view.
   /// currentViewIndex is reset to 0 after this function called.
   /// &lt;seealso cref="MapBase.ViewLayout"/&gt;&lt;/remarks&gt;
   public void DrawAllViews()
   {
      switch(viewLayout)
      {
         case ViewLayout.Single:
            currentViewIndex = 0;
            Draw();
            break;
         case ViewLayout.TopBottom:
         case ViewLayout.LeftRight:
            for (currentViewIndex = 0; currentViewIndex &lt; 2; currentViewIndex++)
               Draw();
            currentViewIndex = 0;
            break;
         case ViewLayout.FourCorners:
            for (currentViewIndex = 0; currentViewIndex &lt; 4; currentViewIndex++)
               Draw();
            currentViewIndex = 0;
            break;
      }
   }

   /// &lt;summary&gt;
   /// Returns the entire view area for this map (including all sub-views if multiple views exist)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The total view area is based on the size of the display, which depends on the
   /// display mode setting of the project. Changing this is not supported.&lt;/remarks&gt;
   public virtual Rectangle TotalView
   {
      get
      {
         return m_Display.DisplayRectangle;
      }
      set
      {
         System.Diagnostics.Debug.Assert(System.Drawing.Rectangle.Intersect(m_Display.DisplayRectangle, value).Equals(value));
      }
   }

   /// &lt;summary&gt;
   /// Returns the display on which this map is drawn.
   /// &lt;/summary&gt;
   public Display Display
   {
      get
      {
         return m_Display;
      }
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="Tile.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Maps a tile index to frameset frames based on counter values etc
/// &lt;/summary&gt;
public abstract class TileBase
{
   protected TileCategoryMembershipBase m_membership;

   protected TileBase(TileCategoryMembershipBase membership)
   {
      m_membership = membership;
   }

   /// &lt;summary&gt;
   /// Returns an array of frameset frames to draw for a tile during a particular frame
   /// &lt;/summary&gt;
   public abstract int[] CurrentFrame
   {
      get;
   }

   /// &lt;summary&gt;
   /// Determines if the tile is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="cat"&gt;Enumerated value that designates a tile category&lt;/param&gt;
   /// &lt;returns&gt;True if the tile is a member of the specified category&lt;/returns&gt;
   public abstract bool IsMember(TileCategoryName cat);
}

/// &lt;summary&gt;
/// Represents the definition for an animated tile in a tileset
/// &lt;/summary&gt;
public class AnimTile : TileBase
{
   private readonly TileFrame[] m_frames;
   private readonly Counter m_counter;
   private short[] m_frameIndexMap;

   /// &lt;summary&gt;
   /// Creates an animated tile definition
   /// &lt;/summary&gt;
   /// &lt;param name="counter"&gt;Which counter affects this tile's animation&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames sorted by chronological sequence&lt;/param&gt;
   public AnimTile(Counter counter, params TileFrame[] frames) : base(null)
   {
      if (frames.Length &lt;= 0)
         throw new System.ApplicationException("Use EmptyTile to create empty tiles");
      this.m_frames = frames;
      this.m_counter = counter;
      GenerateFrameIndexMap();
   }

   /// &lt;summary&gt;
   /// Creates an animated tile definition and defines the tile's membership in tiel categories.
   /// &lt;/summary&gt;
   /// &lt;param name="counter"&gt;Which counter affects this tile's animation&lt;/param&gt;
   /// &lt;param name="membership"&gt;Defines the categories of which this tile is a member&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames sorted by chronological sequence&lt;/param&gt;
   public AnimTile(Counter counter, TileCategoryMembershipBase membership, params TileFrame[] frames) : base(membership)
   {
      if (frames.Length &lt;= 0)
         throw new System.ApplicationException("Use EmptyTile to create empty tiles");
      this.m_frames = frames;
      this.m_counter = counter;
      GenerateFrameIndexMap();
   }

   private void GenerateFrameIndexMap()
   {
      m_frameIndexMap = new short[m_frames[m_frames.Length - 1].m_nAccumulatedDuration];
      short frameIndex = 0;
      for (int frameValue=0; frameValue&lt;m_frameIndexMap.Length; frameValue++)
      {
         if (m_frames[frameIndex].m_nAccumulatedDuration &lt;= frameValue)
            frameIndex++;
         m_frameIndexMap[frameValue] = frameIndex;
      }
   }

   /// &lt;summary&gt;
   /// Return the index of the current distinct animation frame in the tile's animation sequence.
   /// (NOT a counter value)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If a tile's first frame has a repeat count of 2, then counter values of 1
   /// and 2 will yield the same animation frame for that tile, and a counter value of 3
   /// will yield the next animation frame. Notice that these were 3 counter values, but only 2
   /// distinct frames. This property will return 1 for counter values of 1 and 2, and 2 for a
   /// counter value of 3 in this example.&lt;/remarks&gt;
   public int FrameSequenceIndex
   {
      get
      {
         return m_frameIndexMap[m_counter.CurrentValue % m_frameIndexMap.Length];
      }
   }

   /// &lt;summary&gt;
   /// Return the total number of distinct animation frames in the tile.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Although a tile may have (for example) 3 distinct animation frames, they may be
   /// spread out over 24 separate counter values be giving each frame a repeat count of 8.
   /// This value will return 3 in this example, not 24.&lt;/remarks&gt;
   public int FrameSequenceLength
   {
      get
      {
         return m_frames.Length;
      }
   }

   /// &lt;summary&gt;
   /// Return an array of frame indexes representing the frames from this tile's
   /// frameset that should be drawn for the tile in its current state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Often times this will be an array of 1 integer because tiles will
   /// often only have one frameset frame per animation frame. But multiple frameset
   /// frames can be combined into a single tile animation frame by specifying a
   /// repeat count of 0, in which case this will return all the "sub-frames" that are
   /// active in the current frame of this tile.&lt;/remarks&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return m_frames[FrameSequenceIndex].subFrames;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      if (m_membership == null) return false;
      if (m_membership is TileCategoryFrameMembership)
         return ((TileCategoryFrameMembership)m_membership)[FrameSequenceIndex, cat];
      else
         return ((TileCategorySimpleMembership)m_membership)[cat];
   }
}

/// &lt;summary&gt;
/// Represents a non-animated composite or single-cell tile
/// &lt;/summary&gt;
public class SimpleTile : TileBase
{
   private readonly int[] frame;

   /// &lt;summary&gt;
   /// Constructs a tile based on a single frame index from a frameset.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;Zero-based index of the frame within the frameset.&lt;/param&gt;
   public SimpleTile(int frame) : base(null)
   {
      this.frame = new int[] {frame};
   }

   /// &lt;summary&gt;
   /// Constructs a single-frame tile based on multiple frameset frames.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;An array of frame indexes that make of this compisite tile.&lt;/param&gt;
   /// &lt;remarks&gt;The frame indexes represent the multiple frames that this tile will always
   /// draw. The first frame is drawn behind, and the last frame is drawn in front.&lt;/remarks&gt;
   public SimpleTile(int[] frame) : base(null)
   {
      this.frame = frame;
   }

   /// &lt;summary&gt;
   /// Constructs a tile based on a single frame index from a frameset, and specifies
   /// the tile's membership in tile categories.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;Zero-based index of the frame within the frameset.&lt;/param&gt;
   /// &lt;param name="membership"&gt;Provides an object that determines in which categories
   /// this tile is a member.&lt;/param&gt;
   public SimpleTile(int frame, TileCategoryMembershipBase membership) : base(membership)
   {
      this.frame = new int[] {frame};
   }

   /// &lt;summary&gt;
   /// Constructs a single-frame tile based on multiple frameset frames, and specifies
   /// the tile's membership in tile categories.
   /// &lt;/summary&gt;
   /// &lt;param name="frame"&gt;An array of frame indexes that make of this compisite tile.&lt;/param&gt;
   /// &lt;param name="membership"&gt;Provides an object that determines in which categories
   /// this tile is a member.&lt;/param&gt;
   /// &lt;remarks&gt;The frame indexes represent the multiple frames that this tile will always
   /// draw. The first frame is drawn behind, and the last frame is drawn in front.&lt;/remarks&gt;
   public SimpleTile(int[] frame, TileCategoryMembershipBase membership) : base(membership)
   {
      this.frame = frame;
   }

   /// &lt;summary&gt;
   /// Returns an array of frameset frame indexes that represent the current appearance of the tile.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For a simple single-frame tile this will always be an array of 1.  For a
   /// compound tile, this will contain multiple frame indexes in sequence from back-most to
   /// fore-most on the display.&lt;/remarks&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return frame;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      if (m_membership == null) return false;
      return ((TileCategorySimpleMembership)m_membership)[cat];
   }
}

/// &lt;summary&gt;
/// Represents a tile that doesn't draw anything onto the layer
/// &lt;/summary&gt;
public class EmptyTile : TileBase
{
   public static readonly EmptyTile Value = new EmptyTile();
   private readonly int[] frame;

   private EmptyTile() : base(null)
   {
      frame = new int[] {};
   }

   /// &lt;summary&gt;
   /// Returns an empty array
   /// &lt;/summary&gt;
   public override int[] CurrentFrame
   {
      get
      {
         return frame;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileBase.IsMember"/&gt;.
   /// &lt;/summary&gt;
   public override bool IsMember(TileCategoryName cat)
   {
      return false;
   }
}

/// &lt;summary&gt;
/// Represents the appearance of a tile during one iteration of the game loop.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Composite tiles are tiles that draw multiple images at once for a single
/// iteration of the game loop. Such tiles will have sub-frames representing the multiple
/// images that are drawn overlapped.&lt;/remarks&gt;
public class TileFrame : IComparable
{
   /// &lt;summary&gt;
   /// Represents counter value, and is used to optimize frame searching
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is the sum of all the repeat count values on this frame
   /// and before and is used to optimize the translation between a counter
   /// value and an index into the series of distinct tile frames/appearances.&lt;/remarks&gt;
   public readonly int m_nAccumulatedDuration;
   /// &lt;summary&gt;
   /// A list of all the frameset frame indexes contained in this tile frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Composite tiles may have multiple frames drawn on top of each other.&lt;/remarks&gt;
   public readonly int[] subFrames;

   /// &lt;summary&gt;
   /// Constructs a composite TileFrame given its &lt;see cref="m_nAccumulatedDuration"/&gt; and
   /// &lt;see cref="subFrames"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="nAccumulatedDuration"&gt;&lt;see cref="m_nAccumulatedDuration"/&gt; value&lt;/param&gt;
   /// &lt;param name="subFrames"&gt;&lt;see cref="subFrames"/&gt; value&lt;/param&gt;
   public TileFrame(int nAccumulatedDuration, int[] subFrames)
   {
      this.m_nAccumulatedDuration = nAccumulatedDuration;
      this.subFrames = subFrames;
   }

   /// &lt;summary&gt;
   /// Constructs a simple (non-composite) TileFrame given its &lt;see cref="m_nAccumulatedDuration"/&gt;
   /// and the single frameset frame index.
   /// &lt;/summary&gt;
   /// &lt;param name="nAccumulatedDuration"&gt;&lt;see cref="m_nAccumulatedDuration"/&gt; value&lt;/param&gt;
   /// &lt;param name="frame"&gt;Frameset frame index drawn by this tile frame. This gets converted into
   /// a single-element array of integers in &lt;see cref="subFrames"/&gt;.&lt;/param&gt;
   public TileFrame(int nAccumulatedDuration, int frame)
   {
      this.m_nAccumulatedDuration= nAccumulatedDuration;
      this.subFrames = new int[] {frame};
   }

   #region IComparable Members
   /// &lt;summary&gt;
   /// Compares frames based on their &lt;see cref="m_nAccumulatedDuration"/&gt; value
   /// &lt;/summary&gt;
   /// &lt;param name="obj"&gt;Another TileFrame object, or a counter value&lt;/param&gt;
   /// &lt;returns&gt;
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Return Value&lt;/term&gt;&lt;item&gt;Description&lt;/item&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Less than zero&lt;/term&gt;&lt;description&gt;This frame comes before &lt;paramref name="obj"/&gt;
   /// in the counter indexing sequence.&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Zero&lt;/term&gt;&lt;description&gt;This frame should be drawn when the specified counter value is current&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Greater than zero&lt;/term&gt;&lt;description&gt;This frame comes after
   /// &lt;paramref name="obj"/&gt; in the counter indexing sequence.&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;&lt;/returns&gt;
   public int CompareTo(object obj)
   {
      if (obj is TileFrame)
         return m_nAccumulatedDuration.CompareTo(((TileFrame)obj).m_nAccumulatedDuration);
      else
         return m_nAccumulatedDuration.CompareTo(obj);
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="LayerBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.Drawing;
using Microsoft.DirectX.Direct3D;
using Microsoft.DirectX;

/// &lt;summary&gt;
/// Defines the basic operation of a layer of tiles and sprites within a map.
/// &lt;/summary&gt;
[Serializable()]
public abstract class LayerBase : System.Collections.IEnumerable
{
   #region Embedded Classes
   /// &lt;summary&gt;
   /// Maintains information about a &lt;see cref="Frame"/&gt; that has been inserted
   /// into the layer for the current loop.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Frames may be inserted behind the layer (drawn before the tiles),
   /// Appended in front of the layer (drawn after all the tiles) or inserted between
   /// rows of tiles in the layer (drawn after the rows above it, and before the rows
   /// below it). Frames are generally injected into a layer by the existence of a
   /// sprite on the layer.&lt;/remarks&gt;
   private class InjectedFrame : IComparable
   {
      /// &lt;summary&gt;
      /// Horizontal pixel coordinate of the frame within the layer
      /// &lt;/summary&gt;
      public int x;
      /// &lt;summary&gt;
      /// Vertical pixel coordinate of the frame within the layer
      /// &lt;/summary&gt;
      public int y;
      /// &lt;summary&gt;
      /// Determines whether the frame is drawn behind the layer, in front of it,
      /// ir interleaved with the tiles.
      /// &lt;/summary&gt;
      /// &lt;value&gt;&lt;list type="table"&gt;
      /// &lt;listheader&gt;&lt;term&gt;Value&lt;/term&gt;&lt;description&gt;Drawing Order&lt;/description&gt;&lt;/listheader&gt;
      /// &lt;item&gt;&lt;term&gt;-1&lt;/term&gt;&lt;description&gt;Behind tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;0&lt;/term&gt;&lt;description&gt;Interleaved with tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;1&lt;/term&gt;&lt;description&gt;In front of tiles&lt;/description&gt;&lt;/item&gt;
      /// &lt;/list&gt;&lt;/value&gt;
      /// &lt;remarks&gt;Although at design time, priorities are generally specified with
      /// a wide range of numbers on the sprite instances, all we need to know at
      /// runtime is whether a frame is behind, interleaved or in front, so this
      /// priority value only has 3 possible values.&lt;/remarks&gt;
      public int priority;
      /// &lt;summary&gt;
      /// Refers to the frame that is drawn "injected" into this layer
      /// &lt;/summary&gt;
      public Frame frame;
      /// &lt;summary&gt;
      /// Speifies any color modulation that is applied to the frame when it is drawn
      /// &lt;/summary&gt;
      public int color;
      /// &lt;summary&gt;
      /// Constructs a new frame provided with all the values
      /// &lt;/summary&gt;
      /// &lt;param name="x"&gt;Initial value for &lt;see cref="x"/&gt;&lt;/param&gt;
      /// &lt;param name="y"&gt;Initial value for &lt;see cref="y"/&gt;&lt;/param&gt;
      /// &lt;param name="priority"&gt;Initial value for &lt;see cref="priority"/&gt;&lt;/param&gt;
      /// &lt;param name="frame"&gt;Initial value for &lt;see cref="frame"/&gt;&lt;/param&gt;
      /// &lt;param name="color"&gt;Initial value for &lt;see cref="color"/&gt;&lt;/param&gt;
      /// &lt;remarks&gt;A frame may have its own color modulation value internally.
      /// If the color provided to this constructor (presumably from the sprite's
      /// color modulation value) and the frame's color are both specified (not the
      /// default of -1) then they are combined.&lt;/remarks&gt;
      public InjectedFrame(int x, int y, int priority, Frame frame, int color)
      {
         this.x = x;
         this.y = y;
         this.frame = frame;
         this.priority = priority;
         if (color == -1)
            this.color = frame.Color;
         else if (frame.Color == -1)
            this.color = color;
         else
            this.color = Microsoft.DirectX.Direct3D.ColorOperator.Modulate(ColorValue.FromArgb(frame.Color), ColorValue.FromArgb(color)).ToArgb();
      }
      #region IComparable Members

      /// &lt;summary&gt;
      /// Dertermine whether a specified frame should be drawn before or after this frame.
      /// &lt;/summary&gt;
      /// &lt;param name="obj"&gt;Another &lt;see cref="InjectedFrame"/&gt; object.&lt;/param&gt;
      /// &lt;returns&gt;A signed integer that indicates the sequence of the frames
      /// &lt;list type="table"&gt;
      /// &lt;listheader&gt;&lt;term&gt;Return Value&lt;/term&gt;&lt;item&gt;Description&lt;/item&gt;&lt;/listheader&gt;
      /// &lt;item&gt;&lt;term&gt;Less than zero&lt;/term&gt;&lt;description&gt;This injected frame should be drawn
      /// before &lt;paramref name="obj"/&gt;.&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;Zero&lt;/term&gt;&lt;description&gt;Frames overlap exactly, drawing order indeterminant.&lt;/description&gt;&lt;/item&gt;
      /// &lt;item&gt;&lt;term&gt;Greater than zero&lt;/term&gt;&lt;description&gt;This injected frame should be drawn
      /// after &lt;paramref name="obj"/&gt;.&lt;/description&gt;&lt;/item&gt;
      /// &lt;/list&gt;&lt;/returns&gt;
      /// &lt;remarks&gt;&lt;see cref="InjectFrames"/&gt; relies on this interface to make sure that newly
      /// injected frames will be drawn in the right order. Frames higher up in the layer are
      /// drawn before frames that are lower down in the layer regardless of the order in which
      /// they are injected. Frames at the same vertical position will use the horizontal position
      /// to determine drawing order, frames on the left will draw first.&lt;/remarks&gt;
      public int CompareTo(object obj)
      {
         int result = y.CompareTo((obj as InjectedFrame).y);
         if (result != 0)
            return result;
         result = x.CompareTo((obj as InjectedFrame).x);
         if (result != 0)
            return result;
         return -1;
      }

      #endregion
   }
   #endregion

   #region Fields
   protected readonly Tileset m_Tileset;
   private Frameset m_Frameset;
   [NonSerialized()]
   private System.Collections.ArrayList m_InjectedFrames = null;
   
   private readonly int m_nLeftBuffer;
   private readonly int m_nTopBuffer;
   private readonly int m_nRightBuffer;
   private readonly int m_nBottomBuffer;
   protected readonly int m_nColumns;
   protected readonly int m_nRows;
   private readonly int m_nVirtualColumns;
   private readonly int m_nVirtualRows;
   private System.Drawing.Point m_AbsolutePosition;
   /// &lt;summary&gt;
   /// A "Category" or collection of all sprites contained by the layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;"Static" sprites (sprite instances added at design time in the
   /// map editor) occupy the first portion of this collection. Any dynamically
   /// added sprites (added with functions like &lt;see cref="SpriteBase.TileAddSprite"/&gt;)
   /// are appended to the end. When a dynamically added sprite is deactivated, it is
   /// removed from this collection.&lt;/remarks&gt;
   public SpriteCollection m_Sprites;
   private readonly System.Drawing.SizeF m_ScrollRate;
   private System.Drawing.Point[] m_CurrentPosition = new System.Drawing.Point[Project.MaxViews];
   private MapBase m_ParentMap;
   /// &lt;summary&gt;
   /// Provides access to all sprite categories as they relate to this layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The objects provided by this member will return a collection of all sprites
   /// in the requested category that are on this layer.&lt;/remarks&gt;
   public LayerSpriteCategoriesBase m_SpriteCategories;
   protected readonly int m_nInjectStartIndex;
   protected readonly int m_nAppendStartIndex;
   #endregion

   protected LayerBase(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer, int nBottomBuffer,
      int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex)
   {
      this.m_ParentMap = Parent;
      this.m_Tileset = Tileset;
      this.m_Frameset = Tileset.GetFrameset(Parent.Display);
      this.m_nLeftBuffer = nLeftBuffer;
      this.m_nTopBuffer = nTopBuffer;
      this.m_nRightBuffer = nRightBuffer;
      this.m_nBottomBuffer = nBottomBuffer;
      this.m_nColumns = nColumns;
      this.m_nRows = nRows;
      if (nVirtualColumns == 0)
         this.m_nVirtualColumns = nColumns;
      else
         this.m_nVirtualColumns = nVirtualColumns;
      if (nVirtualRows == 0)
         this.m_nVirtualRows = nRows;
      else
         this.m_nVirtualRows = nVirtualRows;
      this.m_AbsolutePosition = Position;
      this.m_ScrollRate = ScrollRate;
      this.Move(new Point(0,0));
      this.m_nInjectStartIndex = nInjectStartIndex;
      this.m_nAppendStartIndex = nAppendStartIndex;
   }

   #region Abstract Members
   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   public abstract int this[int x, int y]
   {
      get;
      set;
   }
   protected abstract int[] GetTileFrame(int x, int y);
   /// &lt;summary&gt;
   /// Retrieves information about the tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal tile coordinate of the tile to retrieve&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical tile coordinate of the tile to retrieve&lt;/param&gt;
   /// &lt;returns&gt;Object describing the tile at the specified position in the layer.&lt;/returns&gt;
   /// &lt;remarks&gt;If the coordinate is beyond the edge of the layer's data, it wraps
   /// to the other side of the layer in order to support layers whose virtual size
   /// is larger than the data size.&lt;/remarks&gt;
   public abstract TileBase GetTile(int x, int y);
   #endregion

   #region IEnumerable Members
   /// &lt;summary&gt;
   /// Enumerates active sprites on the layer.
   /// &lt;/summary&gt;
   public System.Collections.IEnumerator GetEnumerator()
   {
      return new ActiveSpriteEnumerator(m_Sprites);
   }
   #endregion

   #region Properties
   /// &lt;summary&gt;
   /// Get the number of columns of tiles in the layer's tile data
   /// &lt;/summary&gt;
   public int ActualColumns
   {
      get
      {
         return m_nColumns;
      }
   }
   /// &lt;summary&gt;
   /// Get the number of rows of tiles in the layer's tile data
   /// &lt;/summary&gt;
   public int ActualRows
   {
      get
      {
         return m_nRows;
      }
   }

   /// &lt;summary&gt;
   /// Get the number of columns of tiles in the layer's displayed
   /// virtual scroll space (data is wrapped)
   /// &lt;/summary&gt;
   public int VirtualColumns
   {
      get
      {
         return m_nVirtualColumns;
      }
   }
   /// &lt;summary&gt;
   /// Get the number of rows of tiles in the layer's displayed
   /// virtual scroll space (data is wrapped)
   /// &lt;/summary&gt;
   public int VirtualRows
   {
      get
      {
         return m_nVirtualRows;
      }
   }

   /// &lt;summary&gt;
   /// Get or set the position of the layer within the map. 
   /// (Does not affect current position until &lt;see cref="Move"/&gt; is called)
   /// &lt;/summary&gt;
   public System.Drawing.Point AbsolutePosition
   {
      get
      {
         return m_AbsolutePosition;
      }
      set
      {
         m_AbsolutePosition = value;
      }
   }

   /// &lt;summary&gt;
   /// Gets the scroll rate that is applied to &lt;see cref="Move"/&gt; operations.
   /// &lt;/summary&gt;
   public System.Drawing.SizeF ScrollRate
   {
      get
      {
         return m_ScrollRate;
      }
   }

   /// &lt;summary&gt;
   /// Gets/Sets the current pixel position of the layer relative to the screen.
   /// (Setting this directly ignores &lt;see cref="ScrollRate"/&gt; and &lt;see cref="AbsolutePosition"/&gt;.)
   /// &lt;/summary&gt;
   public System.Drawing.Point CurrentPosition
   {
      get
      {
         return m_CurrentPosition[ParentMap.CurrentViewIndex];
      }
      set
      {
         m_CurrentPosition[ParentMap.CurrentViewIndex] = value;
      }
   }

   /// &lt;summary&gt;
   /// Returns the map that owns this layer
   /// &lt;/summary&gt;
   public MapBase ParentMap
   {
      get
      {
         return m_ParentMap;
      }
   }
   
   public Tileset Tileset
   {
      get
      {
         return m_Tileset;
      }
   }
   #endregion

   #region Public methods
   /// &lt;summary&gt;
   /// Move/Scroll the layer to a new position based on the current map position.
   /// The layer's current position is offset by its position on the map and scaled
   /// by the layer's scroll rate.
   /// &lt;/summary&gt;
   /// &lt;param name="MapPosition"&gt;Position of the map. If one component is int.minValue,
   /// that axis is not affected.&lt;/param&gt;
   /// &lt;remarks&gt;Map positions are usually negative because the map position indicates
   /// the position of the top-left corner of the map which is usually scrolled off
   /// the top-left corner of the screen to a negative position.&lt;/remarks&gt;
   public void Move(Point MapPosition)
   {
      if (MapPosition.X != int.MinValue)
         if (MapPosition.Y != int.MinValue)
            CurrentPosition = new Point(m_AbsolutePosition.X + (int)(MapPosition.X * m_ScrollRate.Width), m_AbsolutePosition.Y + (int)(MapPosition.Y * m_ScrollRate.Height));
         else
            CurrentPosition = new Point(m_AbsolutePosition.X + (int)(MapPosition.X * m_ScrollRate.Width), CurrentPosition.Y);
      else if (MapPosition.Y != int.MinValue)
         CurrentPosition = new Point(CurrentPosition.X, m_AbsolutePosition.Y + (int)(MapPosition.Y * m_ScrollRate.Height));
   }

   /// &lt;summary&gt;
   /// Draw the layer according to the currently active view defined by &lt;see cref="MapBase.CurrentView"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Drawing the layer includes drawing of all the tiles and the sprites in the layer.&lt;/remarks&gt;
   public void Draw()
   {
      int nTileWidth = m_Tileset.TileWidth;
      int nTileHeight = m_Tileset.TileHeight;

      int nStartCol = (-m_nLeftBuffer - CurrentPosition.X) / nTileWidth;
      if (nStartCol &lt; 0)
         nStartCol = 0;
      int nStartRow = (-m_nTopBuffer - CurrentPosition.Y) / nTileHeight;
      if (nStartRow &lt; 0)
         nStartRow = 0;

      Rectangle ViewRect = m_ParentMap.CurrentView;
      m_ParentMap.Display.Device.RenderState.ScissorTestEnable = true;
      m_ParentMap.Display.Device.ScissorRectangle = ViewRect;

      int EndCol = (ViewRect.Width - 1 + m_nRightBuffer - CurrentPosition.X) / nTileWidth;
      if (EndCol &gt;= VirtualColumns)
         EndCol = VirtualColumns - 1;
      int EndRow = (ViewRect.Height - 1 + m_nBottomBuffer - CurrentPosition.Y) / nTileHeight;
      if (EndRow &gt;= VirtualRows)
         EndRow = VirtualRows - 1;

      System.Collections.IEnumerator Injected = null;
      InjectedFrame CurFrame;
      if (m_InjectedFrames != null)
      {
         Injected = m_InjectedFrames.GetEnumerator();
         if (!Injected.MoveNext())
            Injected = null;
      }

      Sprite spr = m_ParentMap.Display.Sprite;

      for (int y = nStartRow; y &lt;= EndRow; y++)
      {
         if (Injected != null)
         {
            while ((((CurFrame = (InjectedFrame)Injected.Current).y &lt; y * nTileHeight)) &amp;&amp; (CurFrame.priority &lt;= 0) ||
                   (CurFrame.priority &lt; 0))
            {
               spr.Transform = Matrix.Multiply(CurFrame.frame.Transform, Matrix.Translation(
                  (float)CurFrame.x + CurrentPosition.X + ViewRect.X,
                  (float)CurFrame.y + CurrentPosition.Y + ViewRect.Y, 0));
               spr.Draw(CurFrame.frame.GraphicSheetTexture.Texture, CurFrame.frame.SourceRect,
                  Vector3.Empty, Vector3.Empty, CurFrame.color);
               if (!Injected.MoveNext())
               {
                  Injected = null;
                  break;
               }
            }
         }

         for (int x = nStartCol; x &lt;= EndCol; x++)
         {
            int[] SubFrames = GetTileFrame(x,y);
            for (int nFrame = 0; nFrame &lt; SubFrames.Length; nFrame++)
            {
               Frame f = m_Frameset[SubFrames[nFrame]];
               spr.Transform = Matrix.Multiply(f.Transform, Matrix.Translation(
                  x * nTileWidth + CurrentPosition.X + ViewRect.X,
                  y * nTileHeight + CurrentPosition.Y + ViewRect.Y, 0));
               spr.Draw(f.GraphicSheetTexture.Texture, f.SourceRect, Vector3.Empty, Vector3.Empty, f.Color);
            }
         }
      }

      while (Injected != null)
      {
         CurFrame = (InjectedFrame)Injected.Current;
         spr.Transform = Matrix.Multiply(CurFrame.frame.Transform, Matrix.Translation(
            (float)CurFrame.x + CurrentPosition.X + ViewRect.X,
            (float)CurFrame.y + CurrentPosition.Y + ViewRect.Y, 0));
         spr.Draw(CurFrame.frame.GraphicSheetTexture.Texture, CurFrame.frame.SourceRect,
            Vector3.Empty, Vector3.Empty, CurFrame.color);
         if (!Injected.MoveNext())
         {
            Injected = null;
            break;
         }
      }
   }

   /// &lt;summary&gt;
   /// Returns a rectangle within this layer that represents the currently visible portion.
   /// &lt;/summary&gt;
   public Rectangle VisibleArea
   {
      get
      {
         return new Rectangle(new System.Drawing.Point(-CurrentPosition.X, -CurrentPosition.Y), m_ParentMap.CurrentView.Size);
      }
   }

   /// &lt;summary&gt;
   /// Determines if any part of the specified sprite is visible in the current view.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test.&lt;/param&gt;
   /// &lt;returns&gt;True if any part of the specified sprite is visible in the map's
   /// &lt;see cref="MapBase.CurrentView"/&gt;.&lt;/returns&gt;
   public bool IsSpriteVisible(SpriteBase sprite)
   {
      return sprite.isActive &amp;&amp; sprite.GetBounds().IntersectsWith(VisibleArea);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be interleaved
   /// with the tiles on the layer.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void InjectFrames(int x, int y, Frame[] frames)
   {
      InjectFrames(x, y, frames, -1);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be interleaved
   /// with the tiles on the layer, specifying a color modulation value.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;param name="color"&gt;Specifies how the color channels of the injected frames will be affected.
   /// If the frames include their own color modulation, they will be merged with this.&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void InjectFrames(int x, int y, Frame[] frames, int color)
   {
      if (frames.Length &lt;= 0)
         return;

      InjectedFrame[] additions = new InjectedFrame[frames.Length];
      for (int idx=0; idx&lt;frames.Length; idx++)
         additions[idx] = new InjectedFrame(x, y, 0, frames[idx], color);

      int insIdx;
      if (m_InjectedFrames == null)
      {
         m_InjectedFrames = new System.Collections.ArrayList();
         insIdx = 0;
      }
      else
      {
         insIdx = m_InjectedFrames.BinarySearch(additions[0]);
         if (insIdx &lt; 0)
            insIdx = ~insIdx;
      }
      m_InjectedFrames.InsertRange(insIdx, additions);
   }

   /// &lt;summary&gt;
   /// Injects a series of &lt;see cref="Frame"/&gt; objects into this layer, to be drawn behind the
   /// layer or in front of it, specifying a color modulation value.
   /// &lt;/summary&gt;
   /// &lt;param name="x"&gt;Horizontal pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="y"&gt;Vertical pixel coordinate of the location to inject the frames&lt;/param&gt;
   /// &lt;param name="frames"&gt;Array of frames to be injected at the specified coordinate&lt;/param&gt;
   /// &lt;param name="color"&gt;Specifies how the color channels of the injected frames will be affected.
   /// If the frames include their own color modulation, they will be merged with this.&lt;/param&gt;
   /// &lt;param name="priority"&gt;&lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Value&lt;/term&gt;&lt;description&gt;Drawing Order&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;-1&lt;/term&gt;&lt;description&gt;Behind tiles&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;1&lt;/term&gt;&lt;description&gt;In front of tiles&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;&lt;/param&gt;
   /// &lt;remarks&gt;Often times only a single frame is injected, but sprites with compound frames
   /// may inject multiple frames at once.&lt;/remarks&gt;
   public void AppendFrames(int x, int y, Frame[] frames, int color, int priority)
   {
      InjectedFrame[] additions = new InjectedFrame[frames.Length];
      for (int idx=0; idx&lt;frames.Length; idx++)
         additions[idx] = new InjectedFrame(x, y, priority, frames[idx], color);
      if (m_InjectedFrames == null)
      {
         m_InjectedFrames = new System.Collections.ArrayList(additions);
      }
      else
         m_InjectedFrames.AddRange(additions);
   }

   /// &lt;summary&gt;
   /// Remove all injected frames from the layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is performed after each time the layer is drawn to
   /// prepare for the next iteration.&lt;/remarks&gt;
   public void ClearInjections()
   {
      if (m_InjectedFrames != null)
         m_InjectedFrames.Clear();
   }

   /// &lt;summary&gt;
   /// Inject frames into the layer to represent the current images and positions of
   /// the sprites contained in this layer for this loop iteration.
   /// &lt;/summary&gt;
   public void InjectSprites()
   {
      for (int i = 0; (i &lt; m_nInjectStartIndex) &amp;&amp; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            AppendFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color, -1);
      }
      for (int i = m_nInjectStartIndex; (i &lt; m_nAppendStartIndex) &amp;&amp; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            InjectFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color);
      }
      for (int i = m_nAppendStartIndex; (i &lt; m_Sprites.Count); i++)
      {
         SpriteBase sprite = m_Sprites[i];
         if (IsSpriteVisible(sprite))
            AppendFrames(sprite.PixelX, sprite.PixelY, sprite.GetCurrentFramesetFrames(), sprite.color, 1);
      }
   }

   /// &lt;summary&gt;
   /// Execute the rules of all active sprites on this layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;After the rules are executed, the function checks to see if
   /// any dynamic sprites have been de-activated and removes them.&lt;/remarks&gt;
   public void ProcessSprites()
   {
      foreach(SpriteBase sprite in m_Sprites)
         // Assuming it's more efficient to just set them all to false rather than
         // try and only enumerate the active ones.
         sprite.Processed = false;
      for(int i=0; i &lt; m_Sprites.Count; i++)
         if (m_Sprites[i].isActive)
            m_Sprites[i].ProcessRules();
      m_Sprites.Clean();
   }

   /// &lt;summary&gt;
   /// Retrieve the current mouse position
   /// &lt;/summary&gt;
   /// &lt;returns&gt;Layer-relative coordinate representing the current position of the mouse.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to set a sprite's position at the mouse cursor and make it behave
   /// like a mouse pointer.
   /// &lt;seealso cref="PlanBase.TransportToPoint"/&gt;&lt;/remarks&gt;
   public Point GetMousePosition()
   {
      Point dispPos;
      if (m_ParentMap.Display.Windowed)
         dispPos = m_ParentMap.Display.PointToClient(System.Windows.Forms.Control.MousePosition);
      else
         dispPos = System.Windows.Forms.Control.MousePosition;
      dispPos.Offset(-CurrentPosition.X, -CurrentPosition.Y);
      return dispPos;
   }

   /// &lt;summary&gt;
   /// Scroll the currently active view on the map so the specified sprite is visible.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to scroll into view&lt;/param&gt;
   /// &lt;param name="useScrollMargins"&gt;True to scroll the sprite so that it is also within
   /// the scroll margins, false to only scroll it so it is fully visible in the view.&lt;/param&gt;
   public void ScrollSpriteIntoView(SpriteBase sprite, bool useScrollMargins)
   {
      Rectangle spriteBounds = sprite.GetBounds();
      int newX = int.MinValue;
      int newY = int.MinValue;
      int marginLeft;
      int marginTop;
      int marginRight;
      int marginBottom;
      if (useScrollMargins)
      {
         marginLeft = ParentMap.ScrollMarginLeft;
         marginTop = ParentMap.ScrollMarginTop;
         marginRight = ParentMap.ScrollMarginRight;
         marginBottom = ParentMap.ScrollMarginBottom;
      }
      else
      {
         marginLeft = 0;
         marginTop = 0;
         marginRight = 0;
         marginBottom = 0;
      }
      if (spriteBounds.Left + CurrentPosition.X &lt; marginLeft)
      {
         if (ScrollRate.Width &gt; 0)
            newX = (int)((-spriteBounds.Left + marginLeft - AbsolutePosition.X) / ScrollRate.Width);
         else
            CurrentPosition = new Point(-spriteBounds.Left + marginLeft, CurrentPosition.Y);
      }
      else if (spriteBounds.Right + CurrentPosition.X &gt; VisibleArea.Width - marginRight)
      {
         if (ScrollRate.Width &gt; 0)
            newX = (int)((-spriteBounds.Right + VisibleArea.Width - marginRight - AbsolutePosition.X) / ScrollRate.Width);
         else
            CurrentPosition = new Point(-spriteBounds.Right + VisibleArea.Width - marginRight, CurrentPosition.Y);
      }

      if (spriteBounds.Top + CurrentPosition.Y &lt; marginTop)
      {
         if (ScrollRate.Height &gt; 0)
            newY = (int)((-spriteBounds.Top + marginTop - AbsolutePosition.Y) / ScrollRate.Height);
         else
            CurrentPosition = new Point(CurrentPosition.X, -spriteBounds.Top + marginTop);
      }
      else if (spriteBounds.Bottom + CurrentPosition.Y &gt; VisibleArea.Height - marginBottom)
      {
         if (ScrollRate.Height &gt; 0)
            newY = (int)((-spriteBounds.Bottom + VisibleArea.Height - marginBottom - AbsolutePosition.Y) / ScrollRate.Height);
         else
            CurrentPosition = new Point(CurrentPosition.X, -spriteBounds.Bottom + VisibleArea.Height - marginBottom);
      }
      ParentMap.Scroll(new Point(newX, newY));
   }

   /// &lt;summary&gt;
   /// Push the specified sprite into the currently active view.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be pushed&lt;/param&gt;
   /// &lt;param name="stayInScrollMargins"&gt;True to push the sprite until it's within the scroll
   /// margins, or false to only push it until it's fully visible in the view.&lt;/param&gt;
   /// &lt;remarks&gt;This only affects the sprites intended velocity and does not actually move it.
   /// Solidity ot other factors could still impede the sprite's ability to stay in the view.&lt;/remarks&gt;
   public void PushSpriteIntoView(SpriteBase sprite, bool stayInScrollMargins)
   {
      Rectangle spriteBounds = sprite.GetBounds();
      int marginLeft;
      int marginTop;
      int marginRight;
      int marginBottom;
      if (stayInScrollMargins)
      {
         marginLeft = ParentMap.ScrollMarginLeft;
         marginTop = ParentMap.ScrollMarginTop;
         marginRight = ParentMap.ScrollMarginRight;
         marginBottom = ParentMap.ScrollMarginBottom;
      }
      else
      {
         marginLeft = 0;
         marginTop = 0;
         marginRight = 0;
         marginBottom = 0;
      }

      if (spriteBounds.Left + CurrentPosition.X &lt; marginLeft)
      {
         if (double.IsNaN(sprite.LocalDX))
            sprite.dx = marginLeft - CurrentPosition.X - spriteBounds.Left;
         else
            sprite.LocalDX = marginLeft - CurrentPosition.X - spriteBounds.Left - sprite.RidingOn.dx;
      }
      else if (spriteBounds.Right + CurrentPosition.X &gt; VisibleArea.Width - marginRight)
      {
         if (double.IsNaN(sprite.LocalDX))
            sprite.dx = VisibleArea.Width - marginRight - CurrentPosition.X - spriteBounds.Right;
         else
            sprite.LocalDX = VisibleArea.Width - marginRight - CurrentPosition.X - spriteBounds.Right - sprite.RidingOn.dx;
      }

      if (spriteBounds.Top + CurrentPosition.Y &lt; marginTop)
      {
         if (double.IsNaN(sprite.LocalDY))
            sprite.dy = marginTop - spriteBounds.Top - CurrentPosition.Y;
         else
            sprite.LocalDY = marginTop - spriteBounds.Top - CurrentPosition.Y - sprite.RidingOn.dy;
      }
      else if (spriteBounds.Bottom + CurrentPosition.Y &gt; VisibleArea.Height - marginBottom)
      {
         if (double.IsNaN(sprite.LocalDY))
            sprite.dy = VisibleArea.Height - marginBottom - spriteBounds.Bottom - CurrentPosition.Y;
         else
            sprite.LocalDY = VisibleArea.Height - marginBottom - spriteBounds.Bottom - CurrentPosition.Y - sprite.RidingOn.dy;
      }
   }

   /// &lt;summary&gt;
   /// Determine the vertical offset of the top-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative vertical coordinate (y) of the top-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetTopSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileHeight) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short minTileTop = (short)(testArea.Top % m_Tileset.TileHeight);
      int tileLeft = leftTile * m_Tileset.TileWidth;
      for (int y = topTile; y &lt;= bottomTile; y++)
      {
         if (rightTile == leftTile)
         {
            short topMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               topMost = 0;
            else
               topMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft),
                  (short)(testArea.Left + testArea.Width - 1 - tileLeft));
            if ((topMost != short.MaxValue) &amp;&amp; ((y &gt; topTile) || (topMost &gt;= minTileTop)))
            {
               int result = topMost + y * m_Tileset.TileHeight;
               if (result &lt; testArea.Top + testArea.Height)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short topMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               topMost = 0;
            else
               topMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft), (short)(m_Tileset.TileWidth - 1));
            if ((y == topTile) &amp;&amp; (topMost &lt; minTileTop))
               topMost = short.MaxValue;
            short top;
            for (int x = leftTile + 1; x &lt; rightTile; x++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  top = 0;
               else
                  top = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetTopSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileWidth - 1));
               if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
                  topMost = top;
            }
            if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               top = 0;
            else
               top = solid.GetCurrentTileShape(m_Tileset[this[rightTile,y]]).GetTopSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Left + testArea.Width - 1) % m_Tileset.TileWidth));
            if ((top &lt; topMost) &amp;&amp; ((y &gt; topTile) || (top &gt;= minTileTop)))
               topMost = top;
            if (topMost != short.MaxValue)
            {
               int result = topMost + y * m_Tileset.TileHeight;
               if (result &lt; testArea.Top + testArea.Height)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the vertical offset of the bottom-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative vertical coordinate (y) of the bottom-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetBottomSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileHeight) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short maxTileBottom = (short)((testArea.Top+testArea.Height-1) % m_Tileset.TileHeight);
      int tileLeft = leftTile * m_Tileset.TileWidth;
      for (int y = bottomTile; y &gt;= topTile; y--)
      {
         if (rightTile == leftTile)
         {
            short bottomMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottomMost = (short)(m_Tileset.TileHeight - 1);
            else
               bottomMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft),
                  (short)(testArea.Left + testArea.Width - 1 - tileLeft));
            if ((bottomMost != short.MinValue) &amp;&amp; ((y &lt; bottomTile) || (bottomMost &lt;= maxTileBottom)))
            {
               int result = bottomMost + y * m_Tileset.TileHeight;
               if (result &gt;= testArea.Top)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short bottomMost;
            if (outOfBounds &amp;&amp; ((leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottomMost = (short)(m_Tileset.TileHeight - 1);
            else
               bottomMost = solid.GetCurrentTileShape(m_Tileset[this[leftTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Left - tileLeft), (short)(m_Tileset.TileWidth - 1));
            if ((y == bottomTile) &amp;&amp; (bottomMost &gt; maxTileBottom))
               bottomMost = short.MinValue;
            short bottom;
            for (int x = leftTile + 1; x &lt; rightTile; x++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  bottom = (short)(m_Tileset.TileHeight - 1);
               else
                  bottom = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetBottomSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileWidth - 1));
               if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
                  bottomMost = bottom;
            }
            if (outOfBounds &amp;&amp; ((rightTile &lt; 0) || (rightTile &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
               bottom = (short)(m_Tileset.TileHeight - 1);
            else
               bottom = solid.GetCurrentTileShape(m_Tileset[this[rightTile,y]]).GetBottomSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Left + testArea.Width - 1) % m_Tileset.TileWidth));
            if ((bottom &gt; bottomMost) &amp;&amp; ((y &lt; bottomTile) || (bottom &lt;= maxTileBottom)))
               bottomMost = bottom;
            if (bottomMost != short.MinValue)
            {
               int result = bottomMost + y * m_Tileset.TileHeight;
               if (result &gt;= testArea.Top)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the horizontal offset of the left-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative horizontal coordinate (x) of the left-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetLeftSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileHeight) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short minTileLeft = (short)(testArea.Left % m_Tileset.TileWidth);
      int tileTop = topTile * m_Tileset.TileHeight;
      for (int x = leftTile; x &lt;= rightTile; x++)
      {
         if (bottomTile == topTile)
         {
            short leftMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               leftMost = 0;
            else
               leftMost = solid.GetCurrentTileShape(m_Tileset[this[x,topTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop),
                  (short)(testArea.Top + testArea.Height - 1 - tileTop));
            if ((leftMost != short.MaxValue) &amp;&amp; ((x &gt; leftTile) || (leftMost &gt;= minTileLeft)))
            {
               int result = leftMost + x * m_Tileset.TileWidth;
               if (result &lt; testArea.Left + testArea.Width)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short leftMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               leftMost = 0;
            else
               leftMost = solid.GetCurrentTileShape(m_Tileset[this[x, topTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop), (short)(m_Tileset.TileHeight - 1));
            if ((x == leftTile) &amp;&amp; (leftMost &lt; minTileLeft))
               leftMost = short.MaxValue;
            short left;
            for (int y = topTile + 1; y &lt; bottomTile; y++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  left = 0;
               else
                  left = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetLeftSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileHeight - 1));
               if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
                  leftMost = left;
            }
            if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               left = 0;
            else
               left = solid.GetCurrentTileShape(m_Tileset[this[x, bottomTile]]).GetLeftSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Top + testArea.Height - 1) % m_Tileset.TileHeight));
            if ((left &lt; leftMost) &amp;&amp; ((x &gt; leftTile) || (left &gt;= minTileLeft)))
               leftMost = left;
            if (leftMost != short.MaxValue)
            {
               int result = leftMost + x * m_Tileset.TileWidth;
               if (result &lt; testArea.Left + testArea.Width)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }

   /// &lt;summary&gt;
   /// Determine the horizontal offset of the right-most solid pixel within the specified rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="testArea"&gt;Rectangle to test&lt;/param&gt;
   /// &lt;param name="solid"&gt;Solidity definition defining tile shapes&lt;/param&gt;
   /// &lt;returns&gt;Layer-relative horizontal coordinate (x) of the right-most solid pixel contained
   /// in the rectangle, or &lt;see cref="int.MinValue"/&gt; if none exists.&lt;/returns&gt;
   /// &lt;remarks&gt;This function (and solidity in general) only deals with solid boundaries of tiles.
   /// Therefore if the rectangle is fully embedded in a solid tile and is not crossing any solid
   /// boundaries, the return value will indicate that no solidity was found. This allows such
   /// features as tiles through which the player can jump upward but land down on solidly.&lt;/remarks&gt;
   public int GetRightSolidPixel(Rectangle testArea, Solidity solid)
   {
      int topTile = (testArea.Top + m_Tileset.TileHeight) / m_Tileset.TileHeight - 1;
      int bottomTile = (int)((testArea.Top + testArea.Height - 1) / m_Tileset.TileHeight);
      int leftTile = (testArea.Left + m_Tileset.TileHeight) / m_Tileset.TileWidth - 1;
      int rightTile = (int)((testArea.Left + testArea.Width - 1) / m_Tileset.TileWidth);
      bool outOfBounds = false;
      if ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows)
         || (leftTile &lt; 0) || (leftTile &gt;= VirtualColumns) || (rightTile &lt; 0) || (rightTile &gt;= VirtualColumns))
         outOfBounds = true;
      short maxTileRight = (short)((testArea.Left+testArea.Width-1) % m_Tileset.TileWidth);
      int tileTop = topTile * m_Tileset.TileHeight;
      for (int x = rightTile; x &gt;= leftTile; x--)
      {
         if (bottomTile == topTile)
         {
            short rightMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               rightMost = (short)(m_Tileset.TileWidth - 1);
            else
               rightMost = solid.GetCurrentTileShape(m_Tileset[this[x,topTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop),
                  (short)(testArea.Top + testArea.Height - 1 - tileTop));
            if ((rightMost != short.MinValue) &amp;&amp; ((x &lt; rightTile) || (rightMost &lt;= maxTileRight)))
            {
               int result = rightMost + x * m_Tileset.TileWidth;
               if (result &gt;= testArea.Left)
                  return result;
               else
                  return int.MinValue;
            }
         }
         else
         {
            short rightMost;
            if (outOfBounds &amp;&amp; ((topTile &lt; 0) || (topTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               rightMost = (short)(m_Tileset.TileWidth - 1);
            else
               rightMost = solid.GetCurrentTileShape(m_Tileset[this[x, topTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, (short)(testArea.Top - tileTop), (short)(m_Tileset.TileHeight - 1));
            if ((x == rightTile) &amp;&amp; (rightMost &gt; maxTileRight))
               rightMost = short.MinValue;
            short right;
            for (int y = topTile + 1; y &lt; bottomTile; y++)
            {
               if (outOfBounds &amp;&amp; ((x &lt; 0) || (x &gt;= VirtualColumns) || (y &lt; 0) || (y &gt;= VirtualRows)))
                  right = (short)(m_Tileset.TileWidth - 1);
               else
                  right = solid.GetCurrentTileShape(m_Tileset[this[x,y]]).GetRightSolidPixel(
                     m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)(m_Tileset.TileHeight - 1));
               if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
                  rightMost = right;
            }
            if (outOfBounds &amp;&amp; ((bottomTile &lt; 0) || (bottomTile &gt;= VirtualRows) || (x &lt; 0) || (x &gt;= VirtualColumns)))
               right = (short)(m_Tileset.TileWidth - 1);
            else
               right = solid.GetCurrentTileShape(m_Tileset[this[x, bottomTile]]).GetRightSolidPixel(
                  m_Tileset.TileWidth, m_Tileset.TileHeight, 0, (short)((testArea.Top + testArea.Height - 1) % m_Tileset.TileHeight));
            if ((right &gt; rightMost) &amp;&amp; ((x &lt; rightTile) || (right &lt;= maxTileRight)))
               rightMost = right;
            if (rightMost != short.MinValue)
            {
               int result = rightMost + x * m_Tileset.TileWidth;
               if (result &gt;= testArea.Left)
                  return result;
               else
                  return int.MinValue;
            }
         }
      }
      return int.MinValue;
   }
   #endregion
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a 32-bit integer.
/// &lt;/summary&gt;
[Serializable()]
public abstract class IntLayer : LayerBase
{
   private int[,] m_Tiles;

   public IntLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows,
      System.Drawing.Point Position, System.Drawing.SizeF ScrollRate,
      int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      m_Tiles = (int[,])(resources.GetObject(Name));
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   public override int this[int x, int y]
   {
      get
      {
         return m_Tiles[x % m_nColumns, y % m_nRows];
      }
      set
      {
         m_Tiles[x % m_nColumns, y % m_nRows] = value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns,y % m_nRows]];
   }
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a 16-bit integer.
/// &lt;/summary&gt;
[Serializable()]
public abstract class ShortLayer : LayerBase
{
   private short[,] m_Tiles;

   public ShortLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      m_Tiles = (short[,])(resources.GetObject(Name));
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;value&gt;A number from 0 to 32767&lt;/value&gt;
   /// &lt;remarks&gt;Although this member accepts an integer as the value (because that
   /// is the type required by the base class), a layer of this type can only use
   /// 16-bit values.&lt;/remarks&gt;
   public override int this[int x, int y]
   {
      get
      {
         return (int)(m_Tiles[x,y]);
      }
      set
      {
         m_Tiles[x,y] = (short)value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x,y]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x,y]];
   }
}

/// &lt;summary&gt;
/// Represents a layer where each tile is represented as a single byte.
/// &lt;/summary&gt;
[Serializable()]
public abstract class ByteLayer : LayerBase
{
   private byte[,] m_Tiles;

   public ByteLayer(Tileset Tileset, MapBase Parent, int nLeftBuffer, int nTopBuffer, int nRightBuffer,
      int nBottomBuffer, int nColumns, int nRows, int nVirtualColumns, int nVirtualRows, System.Drawing.Point Position,
      System.Drawing.SizeF ScrollRate, int nInjectStartIndex, int nAppendStartIndex, string Name) : 
      base(Tileset, Parent, nLeftBuffer, nTopBuffer, nRightBuffer,
      nBottomBuffer, nColumns, nRows, nVirtualColumns, nVirtualRows, Position,
      ScrollRate, nInjectStartIndex, nAppendStartIndex)
   {
      System.Resources.ResourceManager resources = new System.Resources.ResourceManager(Parent.GetType());
      m_Tiles = (byte[,])(resources.GetObject(Name));
   }

   /// &lt;summary&gt;
   /// Retrieves or sets the value of a tile at the specified tile coordinate
   /// &lt;/summary&gt;
   /// &lt;value&gt;A number from 0 to 255&lt;/value&gt;
   /// &lt;remarks&gt;Although this member accepts an integer as the value (because that
   /// is the type required by the base class), a layer of this type can only use
   /// 8-bit values.&lt;/remarks&gt;
   public override int this[int x, int y]
   {
      get
      {
         return (int)(m_Tiles[x % m_nColumns, y % m_nRows]);
      }
      set
      {
         m_Tiles[x % m_nColumns, y % m_nRows] = (byte)value;
      }
   }

   protected override int[] GetTileFrame(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]].CurrentFrame;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="LayerBase.GetTile"/&gt;.
   /// &lt;/summary&gt;
   public override TileBase GetTile(int x, int y)
   {
      return m_Tileset[m_Tiles[x % m_nColumns, y % m_nRows]];
   }
}</Text>
  </SourceCode>
  <SourceCode Name="TileCategoryMembership.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Stores information about which categories a tile is in.
/// &lt;/summary&gt;
public abstract class TileCategoryMembershipBase
{
}

/// &lt;summary&gt;
/// Represents membership information in which the membership of a tile does not
/// change based on its state.
/// &lt;/summary&gt;
public class TileCategorySimpleMembership : TileCategoryMembershipBase
{
   private System.Collections.BitArray m_membership;

   /// &lt;summary&gt;
   /// Constructs membership information given a list of category designators.
   /// &lt;/summary&gt;
   /// &lt;param name="membership"&gt;Designates the categories in which a tile is a member.&lt;/param&gt;
   public TileCategorySimpleMembership(params TileCategoryName[] membership)
   {
      m_membership = new System.Collections.BitArray((int)TileCategoryName.Count);
      foreach(TileCategoryName cat in membership)
         m_membership[(int)cat] = true;
   }

   /// &lt;summary&gt;
   /// Returns true if the tile is a member of the specified category
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This algorithm is simple and executes in O(1) time (it is not
   /// proportional to the number of tiles, number of categories, or number
   /// of memberships).&lt;/remarks&gt;
   public bool this[TileCategoryName category]
   {
      get
      {
         return m_membership[(int)category];
      }
   }
}

/// &lt;summary&gt;
/// Represents membership information for a tile whose membership changes based on
/// which frame is active.
/// &lt;/summary&gt;
public class TileCategoryFrameMembership : TileCategoryMembershipBase
{
   private System.Collections.BitArray[] m_frames;

   /// &lt;summary&gt;
   /// Constructs membership information for tile given all the information for the membership
   /// &lt;/summary&gt;
   /// &lt;param name="nFrameSequenceCount"&gt;The number of distinct frames the tile has&lt;/param&gt;
   /// &lt;param name="membership"&gt;A list of memberships for some or all of the tile's frames.
   /// For each category that contains one or more of the tile's frames, there should be
   /// one element in this list.&lt;/param&gt;
   /// &lt;remarks&gt;The &lt;paramref name="membership"/&gt; parameter is only a temporary object used
   /// in the process of constructing this object and is discarded when construction is
   /// complete. This is done to abbreviate the code that constructs these memberships since
   /// the number of distinct categories in which the tile's various frames are members is
   /// usually low, but there may be many distinct frames that are included in each category.
   /// This information is converted to a more optimal format during construction, which allows
   /// the code to determine if a frame is in a category without doing any searching. So the
   /// original membership data is no longer required.&lt;/remarks&gt;
   public TileCategoryFrameMembership(int nFrameSequenceCount, params TileFrameMembership[] membership)
   {
      m_frames = new System.Collections.BitArray[nFrameSequenceCount];
      for (int i=0; i&lt;(int)nFrameSequenceCount; i++)
         m_frames[i] = new System.Collections.BitArray((int)TileCategoryName.Count);

      foreach(TileFrameMembership mbr in membership)
         for (int frameIdx = 0; frameIdx &lt; mbr.frames.Length; frameIdx++)
            m_frames[mbr.frames[frameIdx]][(int)mbr.category] = true;
   }

   /// &lt;summary&gt;
   /// Returns true if the specified zero-based frame (not counter value) of the tile
   /// is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;nFrameSequenceIndex refers to the index within the list of distinct
   /// frames in the tile's animation sequence, not the counter value that corresponds
   /// to that frame. This operation is simple and will return in O(1) time (it does not
   /// depend on the number of frames, categories or memberships involved).
   /// &lt;see cref="AnimTile.FrameSequenceIndex"/&gt;&lt;/remarks&gt;
   public bool this[int nFrameSequenceIndex, TileCategoryName category]
   {
      get
      {
         return m_frames[nFrameSequenceIndex][(int)category];
      }
   }
}

/// &lt;summary&gt;
/// Defines an object that can be used to provide information to the construction of a
/// &lt;see cref="TileCategoryFrameMembership"/&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Instances of this class are not retained, but rather converted into a more optimal
/// form during the construction of the &lt;see cref="TileCategoryFrameMembership"/&gt;.&lt;/remarks&gt;
public struct TileFrameMembership
{
   /// &lt;summary&gt;
   /// Represents a category designated to contain one or more specific frames from an animated tile.
   /// &lt;/summary&gt;
   public TileCategoryName category;
   /// &lt;summary&gt;
   /// Represents a list of frame indexes from a tile that are to be included in a category.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Note that this refers to frame sequence index as described
   /// in &lt;see cref="AnimTile. FrameSequenceIndex"/&gt;, and not a counter value.&lt;/remarks&gt;
   public int[] frames;

   /// &lt;summary&gt;
   /// Constructs membership information given all the parameters
   /// &lt;/summary&gt;
   /// &lt;param name="category"&gt;Specifies a category that will contain one or more
   /// frames from an animated tile.&lt;/param&gt;
   /// &lt;param name="frames"&gt;Specifies the indexes of the tile's frames that will be
   /// included in this category. Note that this refers to frame sequence index as described
   /// in &lt;see cref="AnimTile. FrameSequenceIndex"/&gt;, and not a counter value.&lt;/param&gt;
   public TileFrameMembership(TileCategoryName category, int[] frames)
   {
      this.frames = frames;
      this.category = category;
   }
}
</Text>
  </SourceCode>
  <SourceCode Name="SpriteCollection.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Categorizes / collects sprite instances
/// &lt;/summary&gt;
/// &lt;remarks&gt;Instances of this class are used both to represent the entire collection
/// of sprites contained within a layer &lt;see cref="LayerBase.m_Sprites"/&gt; as well
/// as sub-collections of these sprites divided into individual categories, exposed by
/// &lt;see cref="LayerBase.m_SpriteCategories"/&gt;. Sprite collections can contain static
/// and dynamic sprites. For more information about this distinction, see remarks in
/// &lt;see cref="staticSize"/&gt;.&lt;/remarks&gt;
[Serializable()]
public class SpriteCollection : System.Collections.CollectionBase
{
   /// &lt;summary&gt;
   /// Indicates the initial size of this collection, and the size below which
   /// sprites are never removed.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;para&gt;Sprites defined in the map editor are considered "static" and will always
   /// exist, although they may be inactive (invisible and excluded from processing rules).
   /// But sprites can also be added at runtime. These are referred to as "dynamic"
   /// sprites. When a dynamic sprite is added, it is appended to the end of the main
   /// sprite collection for the layer (&lt;see cref="LayerBase.m_Sprites"/&gt;) as well as
   /// all categories designated to include the specified sprite type (which are also
   /// &lt;see cref="SpriteCollection"/&gt; objects). So each sprite collection has a segment
   /// (at the beginning) of static sprites and a segment at the end (beginning at index
   /// determined by staticSize) containing zero or more dynamic sprites.&lt;/para&gt;
   /// &lt;para&gt;This value, then, represents the number of static sprites in the collection
   /// (whether it be a layer's main collection or a category within the layer).
   /// It is used to ensure that no static sprite can ever be completely removed from
   /// the collection because these should always be available for activation. And sprites
   /// in the collection beyond this range are the only sprites that need to be considered
   /// for removal after a layer's rules are done executing. Only the range of dynamic
   /// sprites will be checked for inactive sprites. Inactive dynamic sprites are removed
   /// from all the categories in which they were a member.&lt;/para&gt;
   /// &lt;seealso cref="SpriteBase.TileAddSprite"/&gt;
   /// &lt;seealso cref="SpriteBase.AddSpriteHere"/&gt;
   /// &lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="Clean"/&gt;&lt;/remarks&gt;
   public readonly int staticSize;

   /// &lt;summary&gt;
   /// Defines a maximum sprite collection size to help ensure dynamic sprites are not
   /// "leaking" into the system without getting cleaned up.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.&lt;/remarks&gt;
   public const int maxCollectionSize = 100;

   /// &lt;summary&gt;
   /// Constructs a sprite collection given a list of all the sprites it should contain.
   /// &lt;/summary&gt;
   /// &lt;param name="sprites"&gt;Array of sprite instances contained in the collection.&lt;/param&gt;
   public SpriteCollection(params SpriteBase[] sprites)
   {
      InnerList.AddRange(sprites);
      staticSize = sprites.Length;
   }

   /// &lt;summary&gt;
   /// Return a sprite instance from the collection given its 0-based index.
   /// &lt;/summary&gt;
   public SpriteBase this[int index]
   {
      get
      {
         return (SpriteBase)InnerList[index];
      }
   }

   /// &lt;summary&gt;
   /// Add a dynamic sprite to the end of this sprite collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be added&lt;/param&gt;
   /// &lt;returns&gt;Index of the new sprite in the collection&lt;/returns&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// This function will fail if the number of sprites in the collection is already equal to
   /// or greater than &lt;see cref="maxCollectionSize"/&gt;.&lt;/remarks&gt;
   public int Add(SpriteBase sprite)
   {
      if (List.Count &gt;= maxCollectionSize)
         throw new ApplicationException("A sprite collection has reached the maximum size of " + maxCollectionSize.ToString() + ". This may be a result of failing to properly clean up dynamic sprites, or it may be the result of a maximum that is too small. To increase it, change the value associated with maxCollectionSize in SpriteCollection.cs");
      return List.Add(sprite);
   }

   protected override void OnRemove( int index, Object value )  
   {
      if (index &lt; staticSize)
         throw new ApplicationException("Attempted to remove from a collection a sprite that was not dynamically added");
   }

   /// &lt;summary&gt;
   /// Determine the index of the specified sprite in the collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to search for&lt;/param&gt;
   /// &lt;returns&gt;Zero-based index of the sprite if found, otherwise -1.&lt;/returns&gt;
   public int IndexOf(SpriteBase sprite)
   {
      return List.IndexOf(sprite);
   }

   /// &lt;summary&gt;
   /// Remove the specified sprite from this collection.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to be removed. This must be a dynamic sprite&lt;/param&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// An error will occur if an attempt is made to remove a static sprite.&lt;/remarks&gt;
   public void Remove(SpriteBase sprite)
   {
      List.Remove(sprite);
   }

   /// &lt;summary&gt;
   /// Remove inactive dynamic sprites from the collection
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;For more information about dynamic sprites, see &lt;see cref="staticSize"/&gt;.
   /// This function is called after all rules for a layer are processed
   /// (at the end of &lt;see cref="LayerBase.ProcessSprites"/&gt;).&lt;/remarks&gt;
   public void Clean()
   {
      for (int index=staticSize; index &lt; List.Count; index++)
      {
         SpriteBase sprite = this[index];
         if (!sprite.isActive)
         {
            RemoveAt(index);
            sprite.RemoveFromCategories();
         }
      }
   }
}

/// &lt;summary&gt;
/// Enumerates only the currently active sprites on a layer
/// &lt;/summary&gt;
public class ActiveSpriteEnumerator : System.Collections.IEnumerator
{
   private System.Collections.IEnumerator SpriteEnumerator;

   public ActiveSpriteEnumerator(SpriteCollection sprites)
   {
      SpriteEnumerator = sprites.GetEnumerator();
   }

   #region IEnumerator Members

   public void Reset()
   {
      SpriteEnumerator.Reset();
   }

   public object Current
   {
      get
      {
         return SpriteEnumerator.Current;
      }
   }

   public bool MoveNext()
   {
      bool result;
      while ((result = SpriteEnumerator.MoveNext()) &amp;&amp; (!((SpriteBase)Current).isActive))
         ;
      return result;
   }

   #endregion
}
</Text>
  </SourceCode>
  <SourceCode Name="GeneralRules.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Diagnostics;

/// &lt;summary&gt;
/// Implements rules common to sprites and plans
/// &lt;/summary&gt;
[Serializable()]
public abstract class GeneralRules
{
   private static SaveUnit saveUnit = null;
   private static System.Collections.Hashtable memorySaveSlots = new System.Collections.Hashtable();
   private static System.Random randomGen = new System.Random();

   /// &lt;summary&gt;
   /// Contains the last sprite created with &lt;see cref="PlanBase.AddSpriteAtPlan"/&gt;,
   /// &lt;see cref="SpriteBase.TileAddSprite"/&gt; or &lt;see cref="SpriteBase.AddSpriteHere"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This reference can be used to initialize various properties of a sprite
   /// that was just created. It can't be used to set parameters on the sprite that are
   /// specific to that sprite type unless it is cast to the correct type (which is not
   /// supported in the interface for defining rules). That should be done from within
   /// the sprite's rules by checking for a specific parameter value (like "IsInisialized")
   /// being 0 or 1, for example.&lt;/remarks&gt;
   public static SpriteBase lastCreatedSprite;

   /// &lt;summary&gt;
   /// Retrieves the layer that contains this object.
   /// &lt;/summary&gt;
   public abstract LayerBase ParentLayer
   {
      get;
   }

   /// &lt;summary&gt;
   /// Write a string to the debug output without moving to the next line.
   /// &lt;/summary&gt;
   /// &lt;param name="Label"&gt;String value to write to the debug output&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;By default, the debug output is reset each frame, so in order to
   /// force a piece of debug output to be visible long enough to see it, it must be
   /// logged during each frame.&lt;/para&gt;
   /// &lt;para&gt;Debug output is drawn to the display in &lt;see cref="GameForm.OutputDebugInfo"/&gt;,
   /// which is called from the main game loop in &lt;see cref="GameForm.Run"/&gt;. The behavior
   /// of debug output can be customized there.&lt;/para&gt;
   /// &lt;para&gt;This function is often used in conjunction with &lt;see cref="LogDebugValue"/&gt;
   /// because LogDebugLabel leaves the position of the output on the same line allowing for a
   /// value to be appended to the end of the line.&lt;/para&gt;
   /// &lt;seealso cref="LogDebugValue"/&gt;
   /// &lt;seealso cref="GameForm.debugText"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;This will add the string "Counter 1 value: " followed by the value
   /// contained in a counter named "Counter 1" to the debug output for the current frame.
   /// &lt;code&gt;LogDebugLabel("Counter 1 value: ");
   /// LogDebugValue(Counter.Counter_1.CurrentValue);&lt;/code&gt;&lt;/example&gt;
   [Description("Write a string to the debug output without moving to the next line"),
   System.Diagnostics.Conditional("DEBUG")]
   public void LogDebugLabel(string Label)
   {
      Project.GameWindow.debugText.Write(Label);
   }

   /// &lt;summary&gt;
   /// Write a number to the debug output and move to the next line.
   /// &lt;/summary&gt;
   /// &lt;param name="DebugValue"&gt;Specifies a numeric value to be logged to the output&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;By default, the debug output is reset each frame, so in order to
   /// force a piece of debug output to be visible long enough to see it, it must be
   /// logged during each frame.&lt;/para&gt;
   /// &lt;para&gt;Debug output is drawn to the display in &lt;see cref="GameForm.OutputDebugInfo"/&gt;,
   /// which is called from the main game loop in &lt;see cref="GameForm.Run"/&gt;. The behavior
   /// of debug output can be customized there.&lt;/para&gt;
   /// &lt;para&gt;This function is often used in conjunction with &lt;see cref="LogDebugLabel"/&gt;
   /// because &lt;see cref="LogDebugLabel"/&gt; leaves the position of the output on the same
   /// line allowing for a label to be provided on the same line as the value.&lt;/para&gt;
   /// &lt;seealso cref="LogDebugLabel"/&gt;
   /// &lt;seealso cref="GameForm.debugText"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;See &lt;see cref="LogDebugLabel"/&gt; for an example&lt;/example&gt;
   [Description("Write a number to the debug output and move to the next line"),
   System.Diagnostics.Conditional("DEBUG")]
   public void LogDebugValue(int DebugValue)
   {
      Project.GameWindow.debugText.WriteLine(DebugValue.ToString());
   }

   /// &lt;summary&gt;
   /// Sets a different map as the one to be drawn on the game display.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies the map to switch to.&lt;/param&gt;
   /// &lt;param name="UnloadCurrent"&gt;If true, the current map will be unloaded first&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;&lt;paramref name="MapType"/&gt; specifies a type of map rather than a specific
   /// instance of a map.
   /// This accomplishes two things. First, it allows the function to switch to a map that hasn't
   /// been initialized/created yet, thus allowing the map instance to only be created when
   /// necessary, and not before switching to it. This can improve performance because an instance
   /// of each map doesn't have to be created during game initialization. Secondly, it allows maps
   /// to be unloaded so that maps instances that don't need to remember their state can be released,
   /// freeing up whatever memory they were occupying. Each map defined in the IDE is compiled/generated as its
   /// own class when the project is compiled, and each map instance becomes an instance of the
   /// class. This conceivably allows multiple instances of the same map to exist, but this is not
   /// fully supported by default in the code provided with this environment.&lt;/para&gt;
   /// &lt;para&gt;When &lt;paramref name="UnloadCurrent"/&gt; is true, the old map will be unloaded while
   /// switching to the new map, freeing up the memory used by the old map's sprites and tiles
   /// (if no other references to the map exist). Eliminating the map from memory also reduces the
   /// amount of data that would be written to a saved game file. Finally it causes the map to be
   /// recreated/reset when returning to it in the future. When &lt;paramref name="UnloadCurrent"/&gt;
   /// is false, the map is retained and re-used next time the game switches to the map, which
   /// means the state of all the tiles and sprites will be remembered as they were when switching
   /// away from the map.&lt;/para&gt;
   /// &lt;seealso cref="UnloadMap"/&gt;&lt;/remarks&gt;
   [Description("Sets a different map as the one to be drawn on the game display.  If UnloadCurrent is true, the current map will be unloaded first (which causes it to be recreated/reset when returning to it).")]
   public void SwitchToMap([Editor("MapType", "UITypeEditor")] Type MapType, bool UnloadCurrent)
   {
      System.Type source = Project.GameWindow.CurrentMap.GetType();
      if (UnloadCurrent)
         Project.GameWindow.UnloadMap(source);
      (Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(MapType)).m_CameFromMapType = source;
   }

   /// &lt;summary&gt;
   /// Return to the map that was active before the last &lt;see cref="SwitchToMap"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="UnloadCurrent"&gt;If true, the current map will be unloaded first&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;Each map remembers where the game was before it became the current map.
   /// Calling this will return to that map, recreating it if it was unloaded. Since each
   /// map can only remember one previous map, you can't keep multiple instances of the same
   /// map in the history. For example, if you switch from a map called "Level1" to "Level2"
   /// then to "Level3" and then back to "Level2", you won't be able to return back to
   /// Level1 using ReturnToPreviousMap. Level2 would switch back to Level3 each time
   /// ReturnToPreviousMap is called.&lt;/para&gt;
   /// &lt;para&gt;If there is no previous map to return to, this function will have no effect.&lt;/para&gt;
   /// &lt;para&gt;See &lt;see cref="SwitchToMap"/&gt; for more information about unloading maps.&lt;/para&gt;&lt;/remarks&gt;
   [Description("Return to the map that was active before the last SwitchToMap.  If UnloadCurrent is true, the current map will be unloaded first (which causes it to be recreated/reset when returning to it).")]
   public void ReturnToPreviousMap(bool UnloadCurrent)
   {
      System.Type source = Project.GameWindow.CurrentMap.m_CameFromMapType;
      if (source == null)
         return;
      if (UnloadCurrent)
         Project.GameWindow.UnloadMap(Project.GameWindow.CurrentMap.GetType());
      Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(source);
   }

   /// &lt;summary&gt;
   /// Determines if there is a previous map to return to.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if calling &lt;see cref="ReturnToPreviousMap"/&gt; will have any effect,
   /// false otherwise.&lt;/returns&gt;
   [Description("Determines if there is a previous map to return to.")]
   public bool CanReturnToPreviousMap()
   {
      return Project.GameWindow.CurrentMap.m_CameFromMapType != null;
   }

   /// &lt;summary&gt;
   /// Unloads the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies the class of map whose instance will be unloaded if
   /// it is loaded.&lt;/param&gt;
   /// &lt;remarks&gt;Unloading a map will free up any memory used by its tiles and sprites if no other
   /// code is referencing it. It also excludes it from the saved game data if the game is saved,
   /// which can significantly reduce the size of a saved game file. Finally it causes the tiles
   /// and sprites to be recreated/reset next time the map is loaded (switched to).
   /// &lt;seealso cref="SwitchToMap"/&gt;
   /// &lt;seealso cref="ReturnToPreviousMap"/&gt;&lt;/remarks&gt;
   [Description("Unloads the specified map, which will force it to be recreated/reset next time it is used.")]
   public void UnloadMap([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      Project.GameWindow.UnloadMap(MapType);
   }

   /// &lt;summary&gt;
   /// Includes a specified set of objects in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Include"&gt;Specifies a category of objects that should be included&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;There are many functions that can be used to specify what elements should be
   /// included in a saved game file.  This function is designed for setting up a very rough
   /// outline of what kind of data will be included in the save file.
   /// After this is called, the selection can be fine tuned with further calls to
   /// related functions in the See Also list.  If nothing is included in the &lt;see cref="SaveUnit"/&gt;
   /// before &lt;see cref="SaveGame"/&gt; is called, everything will be included by default.
   /// See &lt;see cref="SaveUnitInclusion"/&gt; for details about the meaning of different categories.&lt;/para&gt;
   /// &lt;para&gt;By including maps in a &lt;see cref="SaveUnit"/&gt;, all the tiles and sprites are remembered exactly as they
   /// were when the game was saved, but only for those maps that are included.  Maps that aren't
   /// included will be reset to their initial state next time they become active after loading
   /// that game.&lt;/para&gt;
   /// &lt;para&gt;By including only counters (and not maps) in a &lt;see cref="SaveUnit"/&gt;, you can store some
   /// general information in a &lt;see cref="SaveUnit"/&gt; in a significantly smaller file, and use that information
   /// to re-initialize some general properties of the game. For example, the number of lives
   /// and inventory owned by the player (assuming inventory is stored in counters) might be
   /// adequate for some games (if you don't have to worry about items being available again
   /// on maps that have been reset to their initial state, or if you have few enough items that
   /// you can initialize them based on counter values).&lt;/para&gt;
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Includes a specified set of objects in the SaveUnit that will be saved with the next call to SaveGame")]
   public void IncludeInSaveUnit(SaveUnitInclusion Include)
   {
      if (saveUnit == null)
         saveUnit = new SaveUnit();

      switch(Include)
      {
         case SaveUnitInclusion.AllMaps:
            saveUnit.Maps = Project.GameWindow.LoadedMaps;
            saveUnit.AllMaps = true;
            break;
         case SaveUnitInclusion.AllCounters:
         {
            saveUnit.Counters = new System.Collections.ArrayList();
            System.Reflection.PropertyInfo[] counterProps = typeof(Counter).GetProperties(
               System.Reflection.BindingFlags.Public |
               System.Reflection.BindingFlags.GetProperty |
               System.Reflection.BindingFlags.Static);
            foreach(System.Reflection.PropertyInfo counterProp in counterProps)
               saveUnit.Counters.Add(new CounterRef((Counter)counterProp.GetValue(null, null)));
         }
            break;
         case SaveUnitInclusion.WhichMapIsCurrent:
            saveUnit.CurrentMapType = Project.GameWindow.CurrentMap.GetType();
            break;
         case SaveUnitInclusion.PlayerOptions:
            saveUnit.PlayerOptions = Project.GameWindow.Players;
            break;
      }
   }

   /// &lt;summary&gt;
   /// Include the specified counter in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter whose value will be saved when &lt;see cref="SaveGame"/&gt;
   /// is called.&lt;/param&gt;
   /// &lt;remarks&gt;If you want to include only a few select counters in a &lt;see cref="SaveUnit"/&gt;,
   /// you can use this function to select them before calling &lt;see cref="SaveGame"/&gt;.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Include the specified counter in the SaveUnit that will be saved with the next call to SaveGame")]
   public void IncludeCounterInSaveUnit(Counter Counter)
   {
      if (saveUnit == null)
      {
         saveUnit = new SaveUnit();
      }
      if (saveUnit.Counters == null)
      {
         saveUnit.Counters = new System.Collections.ArrayList();
         saveUnit.Counters.Add(new CounterRef(Counter));
         return;
      }
      foreach(CounterRef cr in saveUnit.Counters)
      {
         if (cr.instance == Counter)
            return;
      }
      saveUnit.Counters.Add(Counter);
   }

   /// &lt;summary&gt;
   /// Exclude the specified counter from the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter to remove from the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;If you want to save most counters, but exclude a few, you can call
   /// &lt;see cref="IncludeInSaveUnit"/&gt; to include all counters and then exclude a few
   /// with this function.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Exclude the specified counter from the SaveUnit that will be saved with the next call to SaveGame")]
   public void ExcludeCounterFromSaveUnit(Counter Counter)
   {
      if ((saveUnit == null) || (saveUnit.Counters == null))
         return;
      for(int i = 0; i &lt; saveUnit.Counters.Count; i++)
      {
         if (((CounterRef)(saveUnit.Counters[i])).instance == Counter)
         {
            saveUnit.Counters.RemoveAt(i);
            return;
         }
      }      
   }

   /// &lt;summary&gt;
   /// Include the specified map in the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map to include in the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;If you only want to include a few maps in a &lt;see cref="SaveUnit"/&gt;, specify
   /// which maps to save with this function. Only loaded maps will be saved. If this function
   /// is called on a map type that refers to a map that is not loaded, it will be ignored, and
   /// the specified map type will still be reset next time it becomes active after loading
   /// the game.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Include the specified map in the SaveUnit that will be saved with the next call to SaveGame.")]
   public void IncludeMapInSaveUnit([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      if (Project.GameWindow.LoadedMaps.ContainsKey(MapType))
      {
         if (saveUnit == null)
            saveUnit = new SaveUnit();
         if (saveUnit.Maps == null)
            saveUnit.Maps = new System.Collections.Hashtable();
         saveUnit.Maps[MapType] = Project.GameWindow.LoadedMaps[MapType];
      }
   }

   /// &lt;summary&gt;
   /// Remove the specified map in from the &lt;see cref="SaveUnit"/&gt; that will be saved with the next call to &lt;see cref="SaveGame"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map to exclude from the &lt;see cref="SaveUnit"/&gt;&lt;/param&gt;
   /// &lt;remarks&gt;
   /// If you want to save most maps, but not all, you can call &lt;see cref="IncludeInSaveUnit"/&gt;
   /// to include all maps, and then call this to exclude a few. Maps not included in the save
   /// unit (and maps that were not loaded when the game was saved, even if they are "included")
   /// will be reset next time they become active after loading that &lt;see cref="SaveUnit"/&gt;. Often times an
   /// overly map does not contain any important state information, so excluding an overlay map
   /// from a &lt;see cref="SaveUnit"/&gt; might be a good use of this function.
   /// See &lt;see cref="IncludeInSaveUnit"/&gt; for more information about save units.
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;&lt;/remarks&gt;
   [Description("Remove the specified map in from the SaveUnit that will be saved with the next call to SaveGame.")]
   public void ExcludeMapFromSaveUnit([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      if ((saveUnit == null) || (saveUnit.Maps == null))
         return;
      if (saveUnit.Maps.ContainsKey(MapType))
         saveUnit.Maps.Remove(MapType);
   }

   /// &lt;summary&gt;
   /// Save the current &lt;see cref="SaveUnit"/&gt; into the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number to uniquely identify this &lt;see cref="SaveUnit"/&gt;. If saved to a file, this number plue the ".sav" extension becomes the filename.&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, no file will be created; the current state of the game is stored in a "slot" in memory (and lost when the game exits). Otherwise the game data is saved to a file.&lt;/param&gt;
   /// &lt;remarks&gt;After saving the game, the &lt;see cref="SaveUnit"/&gt; is cleared so that any further inclusions
   /// will start from an empty set.  When the game is saved, the state of the maps and counters
   /// are saved in their current state rather than the state they were in when
   /// &lt;see cref="IncludeInSaveUnit"/&gt; and related functions were called. One exception to this
   /// rule is &lt;see cref="SaveUnitInclusion.WhichMapIsCurrent"/&gt;, which will store the map that
   /// was current when &lt;see cref="IncludeInSaveUnit"/&gt; was called rather than than when the
   /// game is actually saved (if these happen to be different). It's possible to save a game
   /// in a memory slot as well as a file slot. These are considered different slots and can
   /// store different save images even if they use the same number. Otherwise, if a game
   /// already exists in a particular slot, it is overwritten.
   /// &lt;seealso cref="IncludeInSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeCounterInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeCounterFromSaveUnit"/&gt;
   /// &lt;seealso cref="IncludeMapInSaveUnit"/&gt;
   /// &lt;seealso cref="ExcludeMapFromSaveUnit"/&gt;
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;
   /// &lt;/remarks&gt;
   [Description("Save the current save unit into the specified save slot, and reset the save unit. If InMemory is true, no file will be created, otherwise the game is saved to a file.")]
   public void SaveGame(int Slot, bool InMemory)
   {
      System.IO.Stream stm;
      if (InMemory)
         stm = new System.IO.MemoryStream();
      else
         stm = new System.IO.FileStream(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"),
            System.IO.FileMode.Create, System.IO.FileAccess.Write);
      using(stm)
      {
         if (saveUnit == null)
         {
            IncludeInSaveUnit(SaveUnitInclusion.AllMaps);
            IncludeInSaveUnit(SaveUnitInclusion.AllCounters);
            IncludeInSaveUnit(SaveUnitInclusion.WhichMapIsCurrent);
            IncludeInSaveUnit(SaveUnitInclusion.PlayerOptions);
         }
         System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
         bf.Serialize(stm, saveUnit);
         if (InMemory)
            memorySaveSlots[Slot] = ((System.IO.MemoryStream)stm).ToArray();
         saveUnit = null;
      }
   }

   /// &lt;summary&gt;
   /// Restore the state of the objects contained in the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies which game to load&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, the memory slot is used, otherwise the file associated with the slot is loaded&lt;/param&gt;
   /// &lt;remarks&gt;
   /// If there is no data in the specified slot, an error occurs. Use &lt;see cref="SaveExists"/&gt;
   /// to determine if data is available to load from a particular slot.
   /// Counters that were not included in the &lt;see cref="SaveUnit"/&gt; will retain the same value they
   /// had before the game was loaded. Similarly, maps that are not included in the save
   /// unit will retain the same state they had before the game was loaded instead of
   /// being reset or loaded from the file. One exception is if
   /// &lt;see cref="SaveUnitInclusion.AllMaps"/&gt; was ever included in the &lt;see cref="SaveUnit"/&gt; (even
   /// if some maps were later excluded). In this case, all maps that were not included
   /// in the &lt;see cref="SaveUnit"/&gt; will be reset next time they are visited.
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="SaveExists"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;
   /// &lt;/remarks&gt;
   [Description("Restore the state of the objects contained in the specified save slot. If InMemory is true, the memory slot is used, otherwise the file associated with the slot is loaded.")]
   public void LoadGame(int Slot, bool InMemory)
   {
      System.IO.Stream stm;

      if (InMemory)
         stm = new System.IO.MemoryStream((byte[])memorySaveSlots[Slot], false);
      else
         stm = new System.IO.FileStream(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"),
            System.IO.FileMode.Open, System.IO.FileAccess.Read);

      using(stm)
      {
         System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
         SaveUnit unit = (SaveUnit)bf.Deserialize(stm);
         if (unit.Maps != null)
         {
            if (unit.AllMaps)
               Project.GameWindow.LoadedMaps = unit.Maps;
            else
               foreach(System.Collections.DictionaryEntry de in unit.Maps)
                  Project.GameWindow.LoadedMaps[de.Key] = de.Value;
         }
         if (unit.CurrentMapType != null)
            Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(unit.CurrentMapType);
         else
            Project.GameWindow.CurrentMap = Project.GameWindow.GetMap(Project.GameWindow.CurrentMap.GetType());
         if (unit.PlayerOptions != null)
            Project.GameWindow.Players = unit.PlayerOptions;
         // Counters auto-magically take care of themselves via CounterRef
      }
   }

   /// &lt;summary&gt;
   /// Determines if saved game data exists in the specified slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies the slot to check&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If true, checks to see if the specified memory slot has saved
   /// game data available, otherwise checks to see if a file with the specified number
   /// exists for loading game data.&lt;/param&gt;
   /// &lt;returns&gt;True if data can be loaded from the specified slot, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;
   /// Memory slots and file slots are distinct. If a memory slot has game data in it,
   /// a file slot with the same number may not, and vice versa.  Furthermore a memory slot may
   /// have different game data stored in it than a file slot with the same number.
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="DeleteSave"/&gt;&lt;/remarks&gt;
   [Description("Determines if saved game data exists in the specified slot.  Checks for the existence of a file if InMemory is false.")]
   public bool SaveExists(int Slot, bool InMemory)
   {
      if (InMemory)
         return memorySaveSlots.ContainsKey(Slot);
      return System.IO.File.Exists(System.IO.Path.Combine(
         System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"));
   }

   /// &lt;summary&gt;
   /// Empties the specified save slot.
   /// &lt;/summary&gt;
   /// &lt;param name="Slot"&gt;Specifies a number that uniquely identifies a saved game&lt;/param&gt;
   /// &lt;param name="InMemory"&gt;If false, a file is deleted, otherwise a memory slot is cleared.&lt;/param&gt;
   /// &lt;remarks&gt;An error occurs if the specified slot is a file slot and there is no data to delete.
   /// Memory slots and file slots are distinct. If a memory slot has game data in it,
   /// a file slot with the same number may not, and vice versa.  Furthermore a memory slot may
   /// have different game data stored in it than a file slot with the same number.
   /// &lt;seealso cref="LoadGame"/&gt;
   /// &lt;seealso cref="SaveGame"/&gt;
   /// &lt;seealso cref="SaveExists"/&gt;&lt;/remarks&gt;
   [Description("Empties the specified save slot.  If InMemory is false, a file is deleted, otherwise a memory slot is cleared.")]
   public void DeleteSave(int Slot, bool InMemory)
   {
      if (InMemory)
         memorySaveSlots.Remove(Slot);
      else
         System.IO.File.Delete(System.IO.Path.Combine(
            System.Windows.Forms.Application.UserAppDataPath, Slot.ToString() + ".sav"));
   }

   /// &lt;summary&gt;
   /// If multiple views are visible, this determines which view is currently active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Only the currently active view is affected by functions like
   /// &lt;see cref="PlanBase.ScrollSpriteIntoView"/&gt;, and only the current view is
   /// drawn by &lt;see cref="MapBase.Draw"/&gt;. &lt;see cref="MapBase.DrawAllViews"/&gt; is called
   /// during the main loop to cycle through each visible view (changing this value)
   /// and draw it. The scope of this value is limited to the map, so setting it
   /// affects only the map containing this object.&lt;/remarks&gt;
   [Browsable(false)]
   public int CurrentView
   {
      get
      {
         return ParentLayer.ParentMap.CurrentViewIndex;
      }
      set
      {
         ParentLayer.ParentMap.CurrentViewIndex = (byte)value;
      }
   }

   /// &lt;summary&gt;
   /// Sets the layout of multiple views for the current map.
   /// &lt;/summary&gt;
   /// &lt;param name="Layout"&gt;Specifies the number and arrangement of views to be activated.&lt;/param&gt;
   /// &lt;remarks&gt;The number of views designated by &lt;paramref name="Layout"/&gt; must not exceed
   /// &lt;see cref="Project.MaxViews"/&gt; defined by the project.&lt;/remarks&gt;
   [Description("Sets the layout of multiple views for the current map.")]
   public void SetViewLayout(ViewLayout Layout)
   {
      ParentLayer.ParentMap.ViewLayout = Layout;
   }

   /// &lt;summary&gt;
   /// Sets the current state of a sprite based on a category and index into the category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Category containing the sprite to be affected&lt;/param&gt;
   /// &lt;param name="SpriteIndex"&gt;Zero-based index into the category, specifying a sprite&lt;/param&gt;
   /// &lt;param name="State"&gt;Numeric value referring to a state of the specified sprite.&lt;/param&gt;
   [Description("Sets the current state of a sprite based on a category and index into the category.")]
   public void SetCategorySpriteState(SpriteCollection Category, int SpriteIndex, int State)
   {
      Debug.Assert(Category[SpriteIndex].isActive, "SetCategorySpriteState attempted to set the state of an inactive sprite.");
      Category[SpriteIndex].state = State;
   }

   /// &lt;summary&gt;
   /// Turn off the overlay map.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This disables all drawing and rules in the overlay map.&lt;/remarks&gt;
   [Description("Turn off the overlay map. This disables all drawing and rules in the overlay map.")]
   public void ClearOverlay()
   {
      Project.GameWindow.OverlayMap = null;
   }

   /// &lt;summary&gt;
   /// Set the overlay map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map that should be loaded into the overlay&lt;/param&gt;
   /// &lt;remarks&gt;This is very similar to &lt;see cref="SwitchToMap"/&gt;, but it affects the overlay
   /// map instead of the main map.&lt;/remarks&gt;
   [Description("Set the overlay map.")]
   public void SetOverlay([Editor("MapType", "UITypeEditor")] Type MapType)
   {
      Project.GameWindow.OverlayMap = Project.GameWindow.GetMap(MapType);
   }

   /// &lt;summary&gt;
   /// Turn on or off a flag associated with the current map.
   /// &lt;/summary&gt;
   /// &lt;param name="FlagIndex"&gt;A value from 0 to 30 indicating which flag to set or clear&lt;/param&gt;
   /// &lt;param name="Value"&gt;True to set the flag or false to clear it&lt;/param&gt;
   /// &lt;remarks&gt;Each map has a built-in variable &lt;see cref="MapBase.MapFlags"/&gt; that can be used
   /// to store 30 boolean values associated with the map.  This could be used instead of counters
   /// to turn on or off major features of the map, for example, whether the map has been
   /// completed and will allow the player to exit the map without completing it. Such a task is
   /// more suited to a map flag than a counter because there must be exactly one flag per map,
   /// and the flag will automatically be available for each map that is created.
   /// &lt;seealso cref="SetTargetMapFlag"/&gt;
   /// &lt;seealso cref="IsMapFlagOn"/&gt;&lt;/remarks&gt;
   [Description("Turn on or off a flag associated with the current map.  FlagIndex must be a value from 0 through 30.")]
   public void SetMapFlag(int FlagIndex, bool Value)
   {
      if (Value)
         ParentLayer.ParentMap.MapFlags |= 1 &lt;&lt; FlagIndex;
      else
         ParentLayer.ParentMap.MapFlags &amp;= ~(1 &lt;&lt; FlagIndex);
   }

   /// &lt;summary&gt;
   /// Turn on or off a flag associated with the specified map.
   /// &lt;/summary&gt;
   /// &lt;param name="MapType"&gt;Specifies a map whose flag will be set&lt;/param&gt;
   /// &lt;param name="FlagIndex"&gt;A value from 0 to 30 specifying which flag to set or clear&lt;/param&gt;
   /// &lt;param name="Value"&gt;True to set the flag or false to clear it&lt;/param&gt;
   /// &lt;remarks&gt;This operates like &lt;see cref="SetMapFlag"/&gt;, but can operate on any map
   /// rather than just the current map.  This could be used, for example, to set a flag that
   /// would cause all the sprites on any particular map (even if it is not the current map)
   /// to be frozen next time the player visits it, assuming all sprite definitions check
   /// the flag before allowing the sprite to move.
   /// &lt;seealso cref="SetMapFlag"/&gt;
   /// &lt;seealso cref="IsMapFlagOn"/&gt;&lt;/remarks&gt;
   [Description("Turn on or off a flag associated with the specified map. FlagIndex must be a value from 0 through 30.")]
   public void SetTargetMapFlag([Editor("MapType", "UITypeEditor")] Type MapType, int FlagIndex, bool Value)
   {
      if (Value)
         Project.GameWindow.GetMap(MapType).MapFlags |= 1 &lt;&lt; FlagIndex;
      else
         Project.GameWindow.GetMap(MapType).MapFlags &amp;= ~(1 &lt;&lt; FlagIndex);
   }

   /// &lt;summary&gt;
   /// Determine if the specified map-specific flag on the current map is on.
   /// &lt;/summary&gt;
   /// &lt;param name="FlagIndex"&gt;A number from 0 to 30 specifying which flag to check&lt;/param&gt;
   /// &lt;returns&gt;True if the specified flag is set, or false if it is not.&lt;/returns&gt;
   [Description("Determine if the specified map-specific flag on the current map is on.")]
   public bool IsMapFlagOn(int FlagIndex)
   {
      return ((ParentLayer.ParentMap.MapFlags &amp; (1&lt;&lt;FlagIndex)) != 0);
   }

   /// &lt;summary&gt;
   /// Unload all maps that aren't currently visible.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This unloads all maps except the current map and the overlay map.
   /// They will be reset next time they become active.&lt;/remarks&gt;
   [Description("Unload all maps that aren't currently visible (as the current map or overlay map).")]
   public void UnloadBackgroundMaps()
   {
      Project.GameWindow.UnloadBackgroundMaps();
   }

   /// &lt;summary&gt;
   /// Quit the game by closing the main window.
   /// &lt;/summary&gt;
   [Description("Quit the game by closing the main window.")]
   public void QuitGame()
   {
      Project.GameWindow.Quit();
   }

   /// &lt;summary&gt;
   /// Determines if a specified key is being pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="key"&gt;Which key to check&lt;/param&gt;
   /// &lt;returns&gt;True if the specified key is currently pressed, false otherwise&lt;/returns&gt;
   [Description("Returns true if the specified key is currently pressed")]
   public bool IsKeyPressed(Microsoft.DirectX.DirectInput.Key key)
   {
      return Project.GameWindow.KeyboardState[key];
   }

   /// &lt;summary&gt;
   /// Return a random number within a specified range.
   /// &lt;/summary&gt;
   /// &lt;param name="Minimum"&gt;Minimum value that can be returned&lt;/param&gt;
   /// &lt;param name="Maximum"&gt;Maximum bound of the range; this value will never be returned&lt;/param&gt;
   /// &lt;returns&gt;A random integer greater than or equal to Minimum and less than Maximum.
   /// This value is based on a random seed that was generated based on the current time when
   /// the program started.&lt;/returns&gt;
   [Description("Return a random number greater than or equal to Minimum and less than Maximum.")]
   public int GetRandomNumber(int Minimum, int Maximum)
   {
      return randomGen.Next(Minimum,Maximum);
   }

   /// &lt;summary&gt;
   /// Change the font used for drawing text on the display.
   /// &lt;/summary&gt;
   /// &lt;param name="FontName"&gt;Name of the font (quoted string).&lt;/param&gt;
   /// &lt;param name="FontSize"&gt;The em-size, in points, of the new font.&lt;/param&gt;
   [Description("Change the font used for drawing text on the display.")]
   public void SetFont(string FontName, int FontSize)
   {
      Project.GameWindow.GameDisplay.SetFont(FontName, FontSize);
   }

   /// &lt;summary&gt;
   /// Change a counter's value with a pre-defined operation.
   /// &lt;/summary&gt;
   /// &lt;param name="Operation"&gt;Specified a pre-defined operation to execute on a counter&lt;/param&gt;
   /// &lt;returns&gt;True if the counter value hit a limit, false otherwise. For an operation that
   /// stops at a limit, true will only be returned if the counter was unable to change. For an
   /// operation that loops, true indicates that the counter looped. For operators that set the
   /// counter to a limit, true is returned if the counter was already at the limit value, false
   /// otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;Counter values can be changed directly with the "=" function, but
   /// using a pre-defined operation, you can easily cause the counter to loop when
   /// it hits a limit, which is useful for counters linked to tile animations.&lt;/remarks&gt;
   [Description("Change a counter's value with a pre-defined operation. Return true if the counter hits a limit or is left unchanged.")]
   public bool ChangeCounter(Counter Counter, CounterOperation Operation)
   {
      switch(Operation)
      {
         case CounterOperation.IncrementAndStop:
            if (Counter.CurrentValue &lt; Counter.MaxValue)
               Counter.CurrentValue += 1;
            else
               return true;
            return false;
         case CounterOperation.DecrementAndStop:
            if (Counter.CurrentValue &gt; 0)
               Counter.CurrentValue -= 1;
            else
               return true;
            return false;
         case CounterOperation.IncrementAndLoop:
            if (Counter.CurrentValue &lt; Counter.MaxValue)
            {
               Counter.CurrentValue += 1;
               return false;
            }
            Counter.CurrentValue = 0;
            return true;
         case CounterOperation.DecrementAndLoop:
            if (Counter.CurrentValue &gt; 0)
            {
               Counter.CurrentValue -= 1;
               return false;
            }
            Counter.CurrentValue = Counter.MaxValue;
            return true;
         case CounterOperation.SetToMinimum:
            if (Counter.CurrentValue == 0)
               return true;
            Counter.CurrentValue = 0;
            return false;
         case CounterOperation.SetToMaximum:
            if (Counter.CurrentValue == Counter.MaxValue)
               return true;
            Counter.CurrentValue = Counter.MaxValue;
            return false;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified mouse button is pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Button"&gt;Specifies which button to check.&lt;/param&gt;
   /// &lt;returns&gt;True if the button is pressed, false if it is not pressed.&lt;/returns&gt;
   [Description("Determines if the specified mouse button is pressed.")]
   public bool IsMouseButtonPressed(System.Windows.Forms.MouseButtons Button)
   {
      return 0 != (System.Windows.Forms.Control.MouseButtons &amp; Button);
   }
}

/// &lt;summary&gt;
/// Specifies an operation to perform on a counter.
/// &lt;/summary&gt;
public enum CounterOperation
{
   /// &lt;summary&gt;
   /// Add 1 to the counter value. If the counter was at it's maximum value, leave it there.
   /// &lt;/summary&gt;
   IncrementAndStop,
   /// &lt;summary&gt;
   /// Subtract 1 from the counter value. If the counter was at it's minimum value, leave it there.
   /// &lt;/summary&gt;
   DecrementAndStop,
   /// &lt;summary&gt;
   /// Add 1 to the counter value. If the counter was at it's maximum value, set it to its minimum value.
   /// &lt;/summary&gt;
   IncrementAndLoop,
   /// &lt;summary&gt;
   /// Subtract 1 from the counter value. If the counter was at it's minimum value, set it to its maximum value.
   /// &lt;/summary&gt;
   DecrementAndLoop,
   /// &lt;summary&gt;
   /// Set the counter to its minimum value.
   /// &lt;/summary&gt;
   SetToMinimum,
   /// &lt;summary&gt;
   /// Set the counter to its maximum value.
   /// &lt;/summary&gt;
   SetToMaximum
}

/// &lt;summary&gt;
/// This is used to specify general categories of objects to be included
/// in a saved game (save unit).
/// &lt;/summary&gt;
/// &lt;remarks&gt;This is used with &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt;.
/// &lt;seealso cref="GeneralRules.IncludeInSaveUnit"/&gt;
/// &lt;seealso cref="GeneralRules.LoadGame"/&gt;&lt;/remarks&gt;
public enum SaveUnitInclusion
{
   /// &lt;summary&gt;
   /// Includes all loaded maps.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Including all maps in a &lt;see cref="SaveUnit"/&gt; causes all maps to be loaded
   /// or reset when the game is loaded. Maps that were in memory when the game was saved
   /// will be loaded from the file, while the rest will be reset. In that sense, it is
   /// including even maps that aren't loaded because it causes all maps to be reset when the
   /// game is loaded, and then only the stored maps are restored from the file.&lt;/remarks&gt;
   AllMaps,
   /// &lt;summary&gt;
   /// Includes the values of all counters defined in the project.
   /// &lt;/summary&gt;
   AllCounters,
   /// &lt;summary&gt;
   /// Includes an indicator of which map was the currently active map when the game was saved.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If this is not included, the current map will be the same map that was active
   /// before the game was loaded, which may be reset if that map was not included in the
   /// &lt;see cref="SaveUnit"/&gt;. The indicator is determined at the time that &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt;
   /// is called, unlike all the other members which are stored at the time &lt;see cref="GeneralRules.SaveGame"/&gt;
   /// is called.&lt;/remarks&gt;
   WhichMapIsCurrent,
   /// &lt;summary&gt;
   /// Includes player preferences that determine which input devices the players are using and
   /// the keyboad layout.
   /// &lt;/summary&gt;
   PlayerOptions
}

/// &lt;summary&gt;
/// Specifies an arrangement for multiple scrolling views on a single display
/// &lt;/summary&gt;
/// &lt;remarks&gt;This is used with &lt;see cref="GeneralRules.SetViewLayout"/&gt;.
/// There is no space between the views in any of these layouts, but an overlay layer could
/// be used to draw separators on top of the views.
/// &lt;seealso cref="GeneralRules.SetViewLayout"/&gt;&lt;/remarks&gt;
public enum ViewLayout
{
   /// &lt;summary&gt;
   /// A single view that fills the display
   /// &lt;/summary&gt;
   Single,
   /// &lt;summary&gt;
   /// Two views side by side, equally split
   /// &lt;/summary&gt;
   LeftRight,
   /// &lt;summary&gt;
   /// Two views, one above the other, equally split
   /// &lt;/summary&gt;
   TopBottom,
   /// &lt;summary&gt;
   /// Four views occupying the four corners of the display, equally split
   /// &lt;/summary&gt;
   FourCorners
}

/// &lt;summary&gt;
/// Retains information about what has been included for a saved game.
/// &lt;/summary&gt;
/// &lt;remarks&gt;The information included in a SaveUnit only selects which information
/// will be saved, but does not actually store a copy of it. The data for these objects
/// is copied from the objects referenced in the SaveUnit at the time that
/// &lt;see cref="GeneralRules.SaveGame"/&gt; is called. One exception is &lt;see cref="SaveUnitInclusion.WhichMapIsCurrent"/&gt;,
/// which stores an indicator of the current map at the time &lt;see cref="GeneralRules.IncludeInSaveUnit"/&gt; is
/// called.&lt;/remarks&gt;
[Serializable()]
public class SaveUnit
{
   public SaveUnit()
   {
   }
   /// &lt;summary&gt;
   /// Indicates whether &lt;see cref="SaveUnitInclusion.AllMaps"/&gt; was included.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is significant because &lt;see cref="GeneralRules.LoadGame"/&gt; behaves differently
   /// with respect to maps that were not stored in the &lt;see cref="SaveUnit"/&gt; when this
   /// is true or false. If all maps were included, then maps that were not stored are
   /// reset while the game ie being loaded, otherwise they are left as they were before
   /// the game was loaded.&lt;/remarks&gt;
   public bool AllMaps = false;
   /// &lt;summary&gt;
   /// Refers to all maps that will be saved
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The key of this collection is the type of the map and the value refers to the
   /// instance of the map data.&lt;/remarks&gt;
   public System.Collections.Hashtable Maps = null;
   /// &lt;summary&gt;
   /// This indicator remembers which map was current, or is null if the indicator is not saved
   /// &lt;/summary&gt;
   public System.Type CurrentMapType = null;
   /// &lt;summary&gt;
   /// An array of &lt;see cref="CounterRef"/&gt; objects used to include counters in a &lt;see cref="SaveUnit"/&gt;
   /// &lt;/summary&gt;
   public System.Collections.ArrayList Counters = null;
   /// &lt;summary&gt;
   /// Stores player preferenes.
   /// &lt;/summary&gt;
   public IPlayer[] PlayerOptions = null;
}

/// &lt;summary&gt;
/// This class provides a kind of indirect reference to a counter for the purposes
/// of saving and loading counter values in a &lt;see cref="SaveUnit"/&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;Since counters are global objects, it doesn't work well to add a counter
/// directly to the save unit because then loading the save unit will leave the
/// loaded counter values contained in the &lt;see cref="SaveUnit"/&gt; object. But by
/// providing this wrapper that has code specifically for loading ans storing counters,
/// the value of the global counters can automatically be linked to those in a
/// &lt;see cref="SaveUnit"/&gt;.&lt;/remarks&gt;
[Serializable()]
public class CounterRef : System.Runtime.Serialization.ISerializable
{
   public string counterName;
   public Counter instance;

   public CounterRef(Counter counter)
   {
      instance = counter;
      System.Reflection.PropertyInfo[] counterProps = typeof(Counter).GetProperties(
         System.Reflection.BindingFlags.Public |
         System.Reflection.BindingFlags.GetProperty |
         System.Reflection.BindingFlags.Static);
      foreach(System.Reflection.PropertyInfo counterProp in counterProps)
      {
         Counter inst = (Counter)counterProp.GetValue(null, null);
         if (inst == counter)
         {
            counterName = counterProp.Name;
            break;
         }
      }
   }

   private CounterRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      counterName = info.GetString("CounterName");
      instance = (Counter)(typeof(Counter).GetProperty(counterName,
         System.Reflection.BindingFlags.Public |
         System.Reflection.BindingFlags.GetProperty |
         System.Reflection.BindingFlags.Static).GetValue(null, null));
      instance.CurrentValue = info.GetInt32("CounterValue");
   }

   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.AddValue("CounterName", counterName);
      info.AddValue("CounterValue", instance.CurrentValue);
   }
}

/// &lt;summary&gt;
/// Refers to the position of a predefined point relative to a rectangle
/// &lt;/summary&gt;
/// &lt;remarks&gt;Many operations involving the position of one object relative to another
/// object rely on RelativePosition to determine how the two objects' rectangles are
/// aligned. The positions defined in this enumeration generally refer to
/// a point inside the rectangle at the specified position. For example, RightMiddle
/// would refer to the point immediately within the middle of the right side of the
/// rectangle. In the case of aligning two rectangles, this means that the right
/// sides will match up exactly and the vertical center of one rectangle would be
/// aligned with the vertical center of the other.&lt;/remarks&gt;
public enum RelativePosition
{
   TopLeft,
   TopCenter,
   TopRight,
   LeftMiddle,
   CenterMiddle,
   RightMiddle,
   BottomLeft,
   BottomCenter,
   BottomRight
}</Text>
  </SourceCode>
  <SourceCode Name="SpriteBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Diagnostics;

/// &lt;summary&gt;
/// Base class for all sprite definitions.
/// &lt;/summary&gt;
[Serializable()]
public abstract class SpriteBase : GeneralRules
{
   /// &lt;summary&gt;
   /// Horizontal coordinate of the sprite within its layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Because a sprite can move at non-integer rates, the position is tracked
   /// as a floating point number. &lt;seealso cref="PixelX"/&gt;&lt;/remarks&gt;
   public double x;
   /// &lt;summary&gt;
   /// Vertical coordinage of the sprite within its layer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Because a sprite can move at non-integer rates, the position is tracked
   /// as a floating point number. &lt;seealso cref="PixelY"/&gt;&lt;/remarks&gt;
   public double y;
   /// &lt;summary&gt;
   /// Horizontal velocity of the sprite in pixels per frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Negative numbers represent leftward movement while positive numbers
   /// represent rightward movement. This value only represents the final velocity
   /// of the sprite relative to the layer. If the sprite is riding a platform,
   /// see &lt;see cref="LocalDX"/&gt;.&lt;seealso cref="dy"/&gt;&lt;/remarks&gt;
   public double dx;
   /// &lt;summary&gt;
   /// Vertical velocity of the sprite in pixels per frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Negative numbers represent upward movement while positive numbers
   /// represent downward movement. This value only represents the final velocity
   /// of the sprite relative to the layer. If the sprite is riding a platform,
   /// see &lt;see cref="LocalDY"/&gt;.&lt;seealso cref="dx"/&gt;&lt;/remarks&gt;
   public double dy;
   /// &lt;summary&gt;
   /// The value of this sprite's &lt;see cref="x"/&gt; coordinate on the previous frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is set during &lt;see cref="MoveByVelocity"/&gt;.
   /// &lt;seealso cref="OldPixelX"/&gt;&lt;seealso cref="oldY"/&gt;&lt;/remarks&gt;
   public double oldX;
   /// &lt;summary&gt;
   /// The value of this sprite's &lt;see cref="y"/&gt; coordinate on the previous frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is set during &lt;see cref="MoveByVelocity"/&gt;.
   /// &lt;seealso cref="OldPixelY"/&gt;&lt;seealso cref="oldX"/&gt;&lt;/remarks&gt;
   public double oldY;
   /// &lt;summary&gt;
   /// Numeric value corresponding to the sprite's current state.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A value of 0 represents the first state listed in this sprite's
   /// list of states. Each subsequent state is the value of the previous plus 1.
   /// You can refer to the sprites State enumeration to refer to states by name, but
   /// the result must be explicitly converted to an integer.
   /// &lt;seealso cref="SwitchToState"/&gt;
   /// &lt;/remarks&gt;
   /// &lt;example&gt;&lt;c&gt;state = (int)State.Left&lt;/c&gt;&lt;/example&gt;
   public int state;
   /// &lt;summary&gt;
   /// Numeric value corresponding to the sprite's current frame.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The number of valid frames depend on the current state. Each state
   /// has its own sequence of frames. The frame that is displayed depends both on
   /// the number of frames and the repeat count of each frame. &lt;seealso cref="Animate"/&gt;&lt;/remarks&gt;
   public int frame;
   /// &lt;summary&gt;
   /// Stores the inputs that are currently being "pressed" on this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Normally the inputs of a sprite are set by a player, but could
   /// also by explicitly set by rules and other input sources such as saved
   /// input (replaying a previous input sequence). You can cause the sprite
   /// to accelerate in the directions dictated by the input bits with
   /// &lt;see cref="AccelerateByInputs"/&gt;.&lt;seealso cref="AccelerateByInputs"/&gt;
   /// &lt;seealso cref="IsInputPressed"/&gt;&lt;seealso cref="SetInputState"/&gt;
   /// &lt;seealso cref="ClearInputs"/&gt;&lt;seealso cref="MapKeyToInput"/&gt;
   /// &lt;seealso cref="MapPlayerToInputs"/&gt;&lt;seealso cref="oldinputs"/&gt;&lt;/remarks&gt;
   public InputBits inputs;
   /// &lt;summary&gt;
   /// Remembers the inputs that were active on this sprite in the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This value is used to determine when a player (or other input source)
   /// has just started pressing an input versus continued pressing an input that was
   /// already pressed. It is copied from &lt;see cref="inputs"/&gt; when
   /// &lt;see cref="MapPlayerToInputs"/&gt; is called.&lt;seealso cref="inputs"/&gt;
   /// &lt;seealso cref="MapPlayerToInputs"/&gt;&lt;seealso cref="IsInputPressed"/&gt;&lt;/remarks&gt;
   public InputBits oldinputs;
   /// &lt;summary&gt;
   /// Determines if this sprite is currently active.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Only active sprites will be drawn and process rules. Attempting to
   /// refer to an inactive sprite from an active rule (on an active sprite or plan)
   /// will result in an error message in debug mode. &lt;seealso cref="Deactivate"/&gt;
   /// &lt;seealso cref="TileActivateSprite"/&gt;&lt;/remarks&gt;
   public bool isActive;
   private LayerBase layer;
   private Solidity m_solidity;
   /// &lt;summary&gt;
   /// A combination of &lt;see cref="ModulateRed"/&gt;, &lt;see cref="ModulateGreen"/&gt;,
   /// &lt;see cref="ModulateBlue"/&gt; and &lt;see cref="ModulateAlpha"/&gt;.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;para&gt;This member stores the actual data for all 4 of the Modulate properties
   /// that affect the sprite's color. Using the Modulate properties is easier to
   /// read and understand, but setting this property directly is simple and faster
   /// in terms of the amount of code.&lt;/para&gt;
   /// &lt;para&gt;This number consists of 4 bytes, which are, in order from least significant
   /// to most significant: Blue, Greed, Red, Alpha.  To to retrieve the alpha component of
   /// this value, you would divide it by 16777216 or shift the bits rightward 24 places.
   /// &lt;/para&gt;&lt;/remarks&gt;
   public int color;

   /// &lt;summary&gt;
   /// Horizontal velocity relative to the sprite's environment (like a platform)
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the sprite is riding a platform, changes to the sprite's velocity
   /// should affect this instead of &lt;see cref="dx"/&gt;. When the sprite is not riding
   /// a platform, this value will be set to double.NaN.&lt;/remarks&gt;
   public double LocalDX;
   /// &lt;summary&gt;
   /// Vertical velocity relative to the sprite's environment
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;If the sprite is riding an object within which it can move vertically
   /// (platforms only allow the sprite to move within the platform horizontally), changes
   /// to the sprite's velocity should affect this instead of &lt;see cref="dy"/&gt;.
   /// When the sprite is not riding such an object, this value will be set to double.NaN.&lt;/remarks&gt;
   public double LocalDY;

   /// &lt;summary&gt;
   /// Contains all the possible bits that can be set in a sprite's &lt;see cref="inputs"/&gt; and
   /// &lt;see cref="oldinputs"/&gt; properties.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Multiple bits may be set at once if multiple inputs are being pressed on this
   /// sprite at the same time.&lt;/remarks&gt;
   [FlagsAttribute()]
   public enum InputBits
   {
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move up or accelerate
      /// &lt;/summary&gt;
      Up=1,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move or turn right
      /// &lt;/summary&gt;
      Right=2,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move down or decelerate
      /// &lt;/summary&gt;
      Down=4,
      /// &lt;summary&gt;
      /// Refers to an input that causes the sprite to move or turn left
      /// &lt;/summary&gt;
      Left=8,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button1=16,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button2=32,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button3=64,
      /// &lt;summary&gt;
      /// Refers to 1 of 4 customizable inputs on the sprite.
      /// &lt;/summary&gt;
      Button4=128
   }

   /// &lt;summary&gt;
   /// Used to refer to 4 primary directions.
   /// &lt;/summary&gt;
   public enum Direction
   {
      Up,
      Right,
      Down,
      Left
   }

   /// &lt;summary&gt;
   /// Defines the basis for a sprite's animation
   /// &lt;/summary&gt;
   public enum SpriteAnimationType
   {
      /// &lt;summary&gt;
      /// Each frame that passes in the game will cause the sprite to advance its animation by one frame.
      /// &lt;/summary&gt;
      ByFrame,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it will move horizontally each frame.
      /// &lt;/summary&gt;
      ByHorizontalVelocity,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it will move vertically each frame.
      /// &lt;/summary&gt;
      ByVerticalVelocity,
      /// &lt;summary&gt;
      /// The sprite's animation will advance according to how many pixels it moves each frame in any direction (using the distance formula).
      /// &lt;/summary&gt;
      ByVectorVelocity
   }

   /// &lt;summary&gt;
   /// Constructs a new sprite instance given all its base properties.
   /// &lt;/summary&gt;
   /// &lt;param name="layer"&gt;Layer that contains the sprite.&lt;/param&gt;
   /// &lt;param name="x"&gt;Initial horizontal coordinate within the layer&lt;/param&gt;
   /// &lt;param name="y"&gt;Initial vertical coordinate within the layer&lt;/param&gt;
   /// &lt;param name="dx"&gt;Initial horizontal velocity&lt;/param&gt;
   /// &lt;param name="dy"&gt;Initial vertical velocity&lt;/param&gt;
   /// &lt;param name="state"&gt;Initial state&lt;/param&gt;
   /// &lt;param name="frame"&gt;Initial frame within the initial state&lt;/param&gt;
   /// &lt;param name="active"&gt;Determines if the sprite is initially active&lt;/param&gt;
   /// &lt;param name="solidity"&gt;Which solidity definition does the sprite initially react to&lt;/param&gt;
   /// &lt;param name="color"&gt;Initial color modulation settings&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;This cannot be called directly because SpriteBase is an abstract class,
   /// but it is called by the derived constructors on each individual sprite definition.&lt;/para&gt;
   /// &lt;para&gt;The sprite assumes that this is the layer to which it is added and will use it when
   /// looking for other objects or properties in the layer.&lt;/para&gt;&lt;/remarks&gt;
   public SpriteBase(LayerBase layer, double x, double y, double dx, double dy, int state, int frame, bool active, Solidity solidity, int color)
   {
      this.layer = layer;
      this.x = this.oldX = x;
      this.y = this.oldY = y;
      this.dx = dx;
      this.dy = dy;
      this.state = state;
      this.frame = frame;
      this.isActive = active;
      this.m_solidity = solidity;
      this.color = color;
      this.LocalDX = double.NaN;
      this.LocalDY = double.NaN;
   }

   #region Properties
   /// &lt;summary&gt;
   /// Horizontal position of the sprite within the layer rounded toward zero to yield an integer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This can only be changed by changing the sprite's &lt;see cref="dx"/&gt; property.&lt;/remarks&gt;
   public int PixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access PixelX on an inactive sprite");
         // If you don't have the left edge of your map protected by a solid boundary,
         // and the different behavior of the left edge is bugging you, you can use this
         // return statement to work around the rounding difference of negative numbers,
         // but it involves just a bit of unnecessary overhead, and looks rather clumsy:
         // return (int)(x+16)-16;
         return (int)x;
      }
   }

   /// &lt;summary&gt;
   /// Vertical position of the sprite within the layer rounded toward zero to yield an integer.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This can only be changed by changing the sprite's &lt;see cref="dy"/&gt; property.&lt;/remarks&gt;
   public int PixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access PixelY on an inactive sprite");
         return (int)y;
      }
   }

   /// &lt;summary&gt;
   /// The horizontal coordinate that the sprite is expected to be at on the next frame based on its
   /// current position and velocity, rounded toward zero to yield an integer pixel coordinate.
   /// &lt;seealso cref="x"/&gt;&lt;seealso cref="dx"/&gt;
   /// &lt;/summary&gt;
   public int ProposedPixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access ProposedPixelX on an inactive sprite");
         // If you don't have the left edge of your map protected by a solid boundary,
         // and the different behavior of the left edge is bugging you, you can use this
         // return statement to work around the rounding difference of negative numbers,
         // but it involves just a bit of unnecessary overhead, and looks rather clumsy:
         // return (int)(x+dx+16)-16
         return (int)(x+dx);
      }
   }

   /// &lt;summary&gt;
   /// The vertical coordinate that the sprite is expected to be at on the next frame based on its
   /// current position and velocity, rounded toward zero to yield an integer pixel coordinate.
   /// &lt;seealso cref="y"/&gt;&lt;seealso cref="dy"/&gt;
   /// &lt;/summary&gt;
   public int ProposedPixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access ProposedPixelY on an inactive sprite");
         return (int)(y+dy);
      }
   }

   /// &lt;summary&gt;
   /// The horizontal pixel coordinate that the sprite was at on the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A pixel coordinate is the actual coordinate (&lt;see cref="oldX"/&gt; in this case)
   /// rounded toward zero to yield an integer.&lt;/remarks&gt;
   public int OldPixelX
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access OldPixelX on an inactive sprite");
         return (int)oldX;
      }
   }

   /// &lt;summary&gt;
   /// The vertical pixel coordinate that the sprite was at on the previous frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;A pixel coordinate is the actual coordinate (&lt;see cref="oldY"/&gt; in this case)
   /// rounded toward zero to yield an integer.&lt;/remarks&gt;
   public int OldPixelY
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access OldPixelY on an inactive sprite");
         return (int)oldY;
      }
   }

   /// &lt;summary&gt;
   /// Retrieves information about the state that the sprite is currently in.
   /// &lt;/summary&gt;
   public SpriteState CurrentState
   {
      get
      {
         Debug.Assert(this.isActive, "Attempted to access CurrentState on an inactive sprite");
         return this[state];
      }
   }

   /// &lt;summary&gt;
   /// Retrieves information about the layer in which the sprite resides.
   /// &lt;/summary&gt;
   public override LayerBase ParentLayer
   {
      get
      {
         return layer;
      }
   }
   #endregion

   #region Virtual members
   /// &lt;summary&gt;
   /// How many pixels wide is the solid area of this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The solid area of the sprite is the area that avoids overlapping
   /// solid areas of the map. The width is measured from the origin and
   /// extends rightward. &lt;seealso cref="SolidHeight"/&gt;&lt;/remarks&gt;
   public abstract int SolidWidth
   {
      [Description("Returns the width of the sprite's solid area")]
      get;
   }

   /// &lt;summary&gt;
   /// How many pixels high is the solid area of this sprite. 
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The solid area of the sprite is the area that avoids overlapping
   /// solid areas of the map. The height is measured from the origin and
   /// extends downward. &lt;seealso cref="SolidWidth"/&gt;&lt;/remarks&gt;
   public abstract int SolidHeight
   {
      [Description("Returns the height of the sprite's solid area")]
      get;
   }

   /// &lt;summary&gt;
   /// Returns information about a specified state of this sprite
   /// &lt;/summary&gt;
   /// &lt;example&gt;The following code shows how you might retrieve the height
   /// of a sprite's crouching state assuming it has one:
   /// &lt;code&gt;crouchHeight = this[State.Crouch].LocalBounds.Height;&lt;/code&gt;&lt;/example&gt;
   public abstract SpriteState this[int state]
   {
      get;
   }

   /// &lt;summary&gt;
   /// Executes all the rules associated with this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;see cref="ProcessRules"/&gt; is the recommended alternative to execute the sprite's
   /// rules only once per frame by only calling ExecuteRules when the sprites rules haven't
   /// already been executed this frame. &lt;seealso cref="Processed"/&gt;&lt;/remarks&gt;
   protected abstract void ExecuteRules();

   /// &lt;summary&gt;
   /// Resets all parameter values defined on the specific sprite definition to 0.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is helpful in resetting a sprite's state without knowing specifically
   /// what its parameters are.  Then the sprite can internally re-initialize itself when
   /// it sees that it's parameters have been reset to 0.&lt;/remarks&gt;
   public abstract void ClearParameters();

   /// &lt;summary&gt;
   /// Remove the sprite from its designated categories.
   /// USE ONLY on dynamically added sprites.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This is used by functions involved with the creation and deactivation of
   /// dynamically created sprites to ensure that a deactivated sprite no longer exists
   /// in any categories/collections. It's called by &lt;see cref="SpriteCollection.Clean"/&gt;,
   /// which is called by &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/remarks&gt;
   public abstract void RemoveFromCategories();

   #endregion

   #region Public Methods
   /// &lt;summary&gt;
   /// Returns information about the visual boundaries of the sprite's currently displayed frame(s).
   /// &lt;/summary&gt;
   /// &lt;returns&gt;Rectangle object containing layer-relative coordinates that encompass the
   /// sprite's current image.&lt;/returns&gt;
   public System.Drawing.Rectangle GetBounds()
   {
      Debug.Assert(this.isActive, "Attempted to execute GetBounds on an inactive sprite");
      System.Drawing.Rectangle result = CurrentState.LocalBounds;
      result.Offset(PixelX, PixelY);
      return result;
   }

   /// &lt;summary&gt;
   /// Get a list of frameset frames that the sprite is currently displaying
   /// &lt;/summary&gt;
   /// &lt;returns&gt;
   /// Array of Frame objects representing the currently displayed frames.
   /// &lt;/returns&gt;
   /// &lt;remarks&gt;The array will only have more than one element if the sprite
   /// is currently displaying a composite frame.  The frames are ordered from
   /// background to foreground.&lt;/remarks&gt;
   public Frame[] GetCurrentFramesetFrames()
   {
      Debug.Assert(this.isActive, "Attempted to execute GetCurrentFramesetFrames on an inactive sprite");
      SpriteState curstate = CurrentState;
      Frameset stateframes = curstate.Frameset;
      int[] subframes = curstate.GetFrame(frame);
      Frame[] result = new Frame[subframes.Length];
      for(int idx = 0; idx &lt; result.Length; idx++)
         result[idx] = stateframes[subframes[idx]];
      return result;
   }

   /// &lt;summary&gt;
   /// Execute the rules for this sprite if they have not already been executed this frame
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;This checks &lt;see cref="Processed"/&gt; and calls &lt;see cref="ExecuteRules"/&gt;
   /// if it's not set, then sets &lt;see cref="Processed"/&gt; to true.&lt;/remarks&gt;
   public void ProcessRules()
   {
      if (!Processed)
         ExecuteRules();
      Processed = true;
   }

   #endregion

   #region Sprite Interaction
   #region Rider Feature
   /// &lt;summary&gt;
   /// Stores the platform sprite (the sprite that this sprite rides on).
   /// If not set, then the sprite is not riding anything.
   /// &lt;/summary&gt;
   public SpriteBase RidingOn;
   /// &lt;summary&gt;
   /// Determines if this sprite's definition's rules have been processed yet this frame
   /// &lt;/summary&gt;
   [NonSerialized()]
   public bool Processed;

   /// &lt;summary&gt;
   /// Adjust this sprite's velocity according to the motion of the platform it is riding
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Apply this rule before &lt;see cref="ReactToSolid"/&gt; in order to prevent
   /// the platform from allowing the sprite to move through solids.&lt;/remarks&gt;
   [Description("Moves this sprite according to the motion of the platform it is riding.")]
   public void ReactToPlatform()
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToPlatform on an inactive sprite");
      if (RidingOn == null)
         return;

      // Don't try to process the platform's rules if it's already moved.
      // Even though this is already being checked in ProcessRules, circular
      // references (which shouldn't exist) would lead to deadlock.
      if (!RidingOn.Processed)
         // Ensure that the sprite that this sprite is riding moves first
         RidingOn.ProcessRules();

      if ((x+SolidWidth &lt; RidingOn.oldX) || (x &gt; RidingOn.oldX+RidingOn.SolidWidth) ||
         (y+SolidHeight &lt; RidingOn.oldY - 1) || (y+SolidHeight &gt;= RidingOn.oldY+RidingOn.SolidHeight))
      {
         StopRiding();
         return;
      }

      if (double.IsNaN(LocalDX))
         Debug.Fail("LocalDX is not a number");
      else
         dx = LocalDX + RidingOn.dx;
      dy = RidingOn.y - SolidHeight - y;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite is riding another sprite
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if this sprite is currently riding on another sprite&lt;/returns&gt;
   [Description("Determine if the sprite is riding another sprite")]
   public bool IsRidingPlatform()
   {
      Debug.Assert(this.isActive, "Attempted to execute IsRidingPlatform on an inactive sprite");
      return RidingOn != null;
   }

   /// &lt;summary&gt;
   /// Stop riding the sprite that this sprite is currently riding, if any.
   /// &lt;/summary&gt;
   [Description("Stop riding the sprite that this sprite is currently riding, if any.")]
   public void StopRiding()
   {
      Debug.Assert(this.isActive, "Attempted to execute StopRiding on an inactive sprite");
      LocalDX = double.NaN;
      RidingOn = null;
   }

   /// &lt;summary&gt;
   /// Tests to see if this sprite is landing on a platform (from above), and if so,
   /// make the sprite ride the platform.
   /// &lt;/summary&gt;
   /// &lt;param name="PlatformList"&gt;List of platform sprites to check&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite landed on a platform, False if it is already riding a platform or doesn't need to&lt;/returns&gt;
   /// &lt;remarks&gt;
   /// This should be called after sprites are moved, but before
   /// they are drawn.&lt;/remarks&gt;
   [Description("Tests to see if this sprite is landing on a platform (from above). If it is, the sprite will begin riding the platform.")]
   public bool LandDownOnPlatform(SpriteCollection PlatformList)
   {
      Debug.Assert(this.isActive, "Attempted to execute LandDownOnPlatform on an inactive sprite");
      if (RidingOn != null)
         return false;
      foreach(SpriteBase spr in PlatformList)
      {
         if (!spr.isActive)
            continue;
         if((oldY + SolidHeight &lt;= spr.oldY) &amp;&amp;
            (y + SolidHeight &gt; spr.y) &amp;&amp;
            (x + SolidWidth &gt; spr.x) &amp;&amp;
            (x &lt; spr.x + spr.SolidWidth))
         {
            RidingOn = spr;
            spr.ProcessRules();
            LocalDX = dx - spr.dx;
            dy = spr.y - SolidHeight - y;
            return true;
         }
      }
      return false;
   }
   #endregion
   
   /// &lt;summary&gt;
   /// Determine whether the sprite's collision mask is overlapping part of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Targets"&gt;A sprite category containing sprites that will be checked for collision
   /// with this sprite.&lt;/param&gt;
   /// &lt;returns&gt;The index of the sprite within the category if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;The collision mask is derived from the sprite's Mask Alpha Level setting.
   /// If both sprites have a collision mask, they are checked for overlapping solid bits.
   /// If one sprite has Mask Alpha Level set to 0, then a rectangular mask for that sprite
   /// is synthesized from the solid width and solid height using
   /// &lt;see cref="CollisionMask.GetRectangularMask"/&gt;.
   /// If both sprites have Mask Alpha Level set to 0, then a simple rectangular collision
   /// detection is performed (for improved performance).&lt;/remarks&gt;
   [Description("Determine whether the sprite's collision mask is overlapping part of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public int TestCollisionMask(SpriteCollection Targets)
   {
      if (!isActive)
         return -1;
      CollisionMask sourceMask = CurrentState.GetMask(frame);
      bool bSourceIsRectangle = false;
      System.Drawing.Rectangle sourceRect = new System.Drawing.Rectangle(PixelX, PixelY, SolidWidth, SolidHeight);
      if (sourceMask == null)
      {
         sourceMask = CollisionMask.GetRectangularMask(new System.Drawing.Size(SolidWidth, SolidHeight));
         bSourceIsRectangle = true;
      }
      for (int idx = 0; idx &lt; Targets.Count; idx++)
      {
         SpriteBase TargetSprite = Targets[idx];
         if (TargetSprite == this)
            continue;
         if (TargetSprite.isActive)
         {
            CollisionMask targetMask = TargetSprite.CurrentState.GetMask(TargetSprite.frame);
            if (targetMask == null)
            {
               if (bSourceIsRectangle)
               {
                  if (sourceRect.IntersectsWith(new System.Drawing.Rectangle(
                     TargetSprite.PixelX, TargetSprite.PixelY, TargetSprite.SolidWidth, TargetSprite.SolidHeight)))
                     return idx;
                  continue;
               }
               else
                  targetMask = CollisionMask.GetRectangularMask(new System.Drawing.Size(TargetSprite.SolidWidth, TargetSprite.SolidHeight));
            }
            if (sourceMask.TestCollisionWith(targetMask, TargetSprite.PixelX - PixelX, TargetSprite.PixelY - PixelY))
               return idx;
         }         
      }
      return -1;
   }

   /// &lt;summary&gt;
   /// Determine whether the solidity rectangle of the sprite overlaps that of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Targets"&gt;A sprite category containing sprites that will be checked for collision
   /// with this sprite.&lt;/param&gt;
   /// &lt;returns&gt;The index of the sprite within the category if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to force a simple rectangular collision test even if one or both
   /// sprites involved have a Mask Alpha level greater than 0.  This method is recommended
   /// for improved performance when pixel-perfect collision detection is not required.
   /// &lt;seealso cref="TestCollisionMask"/&gt;&lt;/remarks&gt;
   [Description("Determine whether the solidity rectangle of the sprite overlaps that of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public int TestCollisionRect(SpriteCollection Targets)
   {
      if (!isActive)
         return -1;
      for (int idx = 0; idx &lt; Targets.Count; idx++)
      {
         SpriteBase TargetSprite = Targets[idx];
         if (TargetSprite == this)
            continue;
         int x1 = PixelX;
         int w1 = SolidWidth;
         int x2 = TargetSprite.PixelX;
         int w2 = TargetSprite.SolidWidth;
         int y1 = PixelY;
         int h1 = SolidHeight;
         int y2 = TargetSprite.PixelY;
         int h2 = TargetSprite.SolidHeight;

         if ((x1+w1 &gt; x2) &amp;&amp; (x2+w2 &gt; x1) &amp;&amp; (y1+h1 &gt; y2) &amp;&amp; (y2+h2 &gt; y1))
            return idx;
      }
      return -1;
   }
   #endregion

   #region Movement
   /// &lt;summary&gt;
   /// Increment or decrement horizontal velocity 
   /// &lt;/summary&gt;
   /// &lt;param name="delta"&gt;Amount by which to change velocity in pixels per frame per frame&lt;/param&gt;
   [Description("Increment or decrement horizontal velocity")]
   public void AlterXVelocity(double delta)
   {
      Debug.Assert(this.isActive, "Attempted to execute AlterXVelocity on an inactive sprite");
      dx += delta;
   }

   /// &lt;summary&gt;
   /// Increment or decrement vertical velocity 
   /// &lt;/summary&gt;
   /// &lt;param name="delta"&gt;Amount by which to change velocity in pixels per frame per frame&lt;/param&gt;
   [Description("Increment or decrement vertical velocity")]
   public void AlterYVelocity(double delta)
   {
      Debug.Assert(this.isActive, "Attempted to execute AlterYVelocity on an inactive sprite");
      dy += delta;
   }

   /// &lt;summary&gt;
   /// Move this sprite according to its current velocity
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The &lt;see cref="oldX"/&gt; and &lt;see cref="oldY"/&gt; properties are
   /// set from the current position and a new position is calculated into
   /// &lt;see cref="x"/&gt; and &lt;see cref="y"/&gt; by adding &lt;see cref="dx"/&gt; and
   /// &lt;see cref="dy"/&gt; to them respectively.&lt;/remarks&gt;
   [Description("Move this sprite according to its current velocity")]
   public void MoveByVelocity()
   {
      Debug.Assert(this.isActive, "Attempted to execute MoveByVelocity on an inactive sprite");
      oldX = x;
      oldY = y;
      x += dx;
      y += dy;
   }

   /// &lt;summary&gt;
   /// If the velocity of the sprite is more than the specified maximum, normalize it so that
   /// it's going the same direction, but at no more that the specified maximum speed.
   /// &lt;/summary&gt;
   /// &lt;param name="Maximum"&gt;Specifies the maximum speed in pixels per frame&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;The speed of the sprite is calculated with the distance formula, so a sprite
   /// moving 3 pixels horizontally and 4 pixels vertically, for example, is considered to be
   /// moving 5 pixels.&lt;/para&gt;
   /// &lt;para&gt;If the sprite is riding a platform, the maximum velocity is applied relative to
   /// the platform. For example, if the platform is moving rightward at 3 pixels per frame,
   /// and the sprite is moving rightward at 5 pixels per frame relative to the platform (8
   /// pixels per frame in absolute terms), and the maximum is set to 4 pixels per frame,
   /// the sprite's &lt;see cref="LocalDX"/&gt; will be reduced to 4 rather than to 1&lt;/para&gt;.&lt;/remarks&gt;
   [Description("Limit the velocity of the sprite to the specified maximum pixels per frame (affects only local velocity when applicable)")]
   public void LimitVelocity(int Maximum)
   {
      Debug.Assert(this.isActive, "Attempted to execute LimitVelocity on an inactive sprite");
      double useDX, useDY;
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;
      double dist = useDX * useDX + useDY * useDY;
      if (dist &gt; Maximum * Maximum)
      {
         dist = Math.Sqrt(dist);
         useDX = useDX * Maximum / dist;
         useDY = useDY * Maximum / dist;
         if (double.IsNaN(LocalDX))
            dx = useDX;
         else
            LocalDX = useDX;
         if (double.IsNaN(LocalDY))
            dy = useDY;
         else
            LocalDY = useDY;
      }
   }

   /// &lt;summary&gt;
   /// Reduces the sprite's velocity to simulate friction.
   /// &lt;/summary&gt;
   /// &lt;param name="RetainPercentVertical"&gt;What percent (0 to 100) of the sprite's horizontal velocity
   /// (&lt;see cref="dx"/&gt;) is retained.&lt;/param&gt;
   /// &lt;param name="RetainPercentHorizontal"&gt;What percent (0 to 100) of the sprite's vertical
   /// velocity (&lt;see cref="dy"/&gt;) is retained.&lt;/param&gt;
   /// &lt;remarks&gt;Note that inertia may have unexpected side-effects on gravity.  For example,
   /// if RetainPercentVertical is set to zero, this will cause the sprite to start from a
   /// vertical velocity of 0 on every frame, which will result in gravity being unable to
   /// accumulate any effect.  It's best to set RetainPercentVertical to a high number or 100
   /// when gravity is in effect. A gravity effect is simply an automatic adjustment to the
   /// Y velocity with &lt;see cref="AlterYVelocity"/&gt;.&lt;/remarks&gt;
   [Description("Reduces the sprite's velocity to simulate friction.  RetainPercent is a number 0 to 100 indicating how much inertia is retained.")]
   public void ReactToInertia(int RetainPercentVertical, int RetainPercentHorizontal)
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToInertia on an inactive sprite");
      if (double.IsNaN(LocalDX))
      {
         if (Math.Abs(dx) &lt; .01)
            dx = 0;
         else
            dx *= RetainPercentHorizontal / 100.0f;
      }
      else
      {
         if (Math.Abs(LocalDX) &lt; .01)
            LocalDX = 0;
         else
            LocalDX *= RetainPercentHorizontal / 100.0f;
      }
      if (double.IsNaN(LocalDY))
      {
         if (Math.Abs(dy) &lt; .01)
            dy = 0;
         else
            dy *= RetainPercentVertical / 100.0f;
      }
      else
      {
         if (Math.Abs(LocalDY) &lt; .01)
            LocalDY = 0;
         else
            LocalDY *= RetainPercentVertical / 100.0f;
      }
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is moving in the specified direction at all.
   /// &lt;/summary&gt;
   /// &lt;param name="Direction"&gt;Determines which direction to check&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite has any movement in the specified direction, otherwise false.&lt;/returns&gt;
   [Description("Returns true if the sprite is moving in the specified direction")]
   public bool IsMoving(Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsMoving on an inactive sprite");
      double useDX, useDY;
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;

      switch(Direction)
      {
         case Direction.Left:
            return useDX &lt; 0;
         case Direction.Right:
            return useDX &gt; 0;
         case Direction.Up:
            return useDY &lt; 0;
         case Direction.Down:
            return useDY &gt; 0;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Accelerate a rotating sprite in the direction that it is aiming.
   /// &lt;/summary&gt;
   /// &lt;param name="Acceleration"&gt;Specifies acceleration amount in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;remarks&gt;The current angle of this sprite is calculated by assuming that the provided first state
   /// points rightward, and that each subsequent state rotates the sprite counter-clockwise in equal
   /// increments until StateCount states have resulted in one full rotation. The sprite's current state
   /// is somewhere in that progression, and determines the current angle. The actual formula is
   /// (state - FirstState) * pi * 2 / StateCount, which calculates the angle in radians.
   /// &lt;seealso cref="RotateVelocity"/&gt;&lt;/remarks&gt;
   [Description("Accelerate the sprite in a direction determined by its state, assuming the first state points rightward and the number of states rotate counterclockwise 360 degrees. Acceleration is in tenths of a pixel per frame per frame.")]
   public void PolarAccelerate(int Acceleration, [Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      Debug.Assert(this.isActive, "Attempted to execute PolarAccelerate on an inactive sprite");
      double angle = (state - FirstState) * Math.PI * 2 / (double)StateCount;
      double ddx = Math.Cos(angle) * Acceleration / 10.0d;
      double ddy = -Math.Sin(angle) * Acceleration / 10.0d;
      if (double.IsNaN(LocalDY))
         dy += ddy;
      else
         LocalDY += ddy;

      if (double.IsNaN(LocalDX))
         dx += ddx;
      else
         LocalDX += ddx;
   }
   
   /// &lt;summary&gt;
   /// Redirect this sprite's velocity to be 100% in the direction that it is facing.
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;paramref name="FirstState" /&gt; must represent the sprite in a rightward-aiming state, and each subsequent
   /// state must represent an equal counter-clockwise rotation until &lt;paramref name="StateCount" /&gt; states result in
   /// the sprite pointing almost rightward again. The sprite's current state must be one of the
   /// states in that range. This function is useful for car-type sprites where turning the sprite should automatically
   /// cause the sprite to be moving in that direction only (no drifting in the previous direction
   /// like a space ship would). &lt;seealso cref="PolarAccelerate"/&gt;&lt;/remarks&gt;
   [Description("Redirect this sprite's velocity to be 100% in the direction that it is facing, based on its state, where FirstState points rightward and the number of states rotate counterclockwise.")]
   public void RotateVelocity([Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      Debug.Assert(this.isActive, "Attepmted to execute RotateVelocity on an inactive sprite");
      Microsoft.DirectX.Vector2 oldVector;
      if (double.IsNaN(LocalDX))
         oldVector.X = (float)dx;
      else
         oldVector.X = (float)LocalDX;
      if (double.IsNaN(LocalDY))
         oldVector.Y = (float)dy;
      else
         oldVector.Y = (float)LocalDY;

      float angle = (float)((state - FirstState) * Math.PI * 2 / (float)StateCount);

      Microsoft.DirectX.Vector2 facingVector;
      facingVector.X = (float)Math.Cos(angle);
      facingVector.Y = -(float)Math.Sin(angle);
      facingVector.Multiply(Microsoft.DirectX.Vector2.Dot(oldVector, facingVector));

      if (double.IsNaN(LocalDX))
         dx = facingVector.X;
      else
         LocalDX = facingVector.X;

      if (double.IsNaN(LocalDY))
         dy = facingVector.Y;
      else
         LocalDY = facingVector.Y;
   }

   /// &lt;summary&gt;
   /// Scroll all layers on this sprite's layer's map so that the sprite is within visible area of the map.
   /// &lt;/summary&gt;
   /// &lt;param name="UseScrollMargins"&gt;If true, scroll the sprite into the scroll margins of the map. Otherwise just scroll the layers var enough so the sprite is within the edges of the display.&lt;/param&gt;
   /// &lt;remarks&gt;For a multi-player game where both players are in the same view, you may want to
   /// set UseScrollMargins to false in order to allow the players to get closer to the edge of the
   /// display when moving apart from one another. This function will not affect layers with a scroll
   /// rate of zero. &lt;seealso cref="PushSpriteIntoView"/&gt;
   /// &lt;/remarks&gt;
   [Description("Scroll all layers on this sprite's layer's map so that the sprite is within visible area of the map.  If UseScrollMargins is true, scroll the sprite into the scroll margins of the map.")]
   public void ScrollSpriteIntoView(bool UseScrollMargins)
   {
      ParentLayer.ScrollSpriteIntoView(this, UseScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter this sprite's velocity so that it remains within the map's visible area or
   /// within the scroll margins, according to this sprite's layer's position within the map.
   /// &lt;/summary&gt;
   /// &lt;param name="StayInScrollMargins"&gt;If true, the sprite will be pushed toward the center as
   /// soon as it comes within a minimum distance of the edge of the display, determined by the
   /// map's scroll margins (&lt;see cref="MapBase.ScrollMarginLeft"/&gt;, &lt;see cref="MapBase.ScrollMarginTop"/&gt;,
   /// &lt;see cref="MapBase.ScrollMarginRight"/&gt;, &lt;see cref="MapBase.ScrollMarginBottom"/&gt;). Otherwise
   /// the sprite will only be pushed when it reaches the edge of the display.&lt;/param&gt;
   /// &lt;remarks&gt;This takes into account the sprites &lt;see cref="LocalDX"/&gt; and &lt;see cref="LocalDY"/&gt;
   /// properties in case it is riding another sprite. If the sprite has somehow gone far off the
   /// edge of the map, it's velocity may be set to unreasonable values because it will attempt
   /// to enter the display in a single frame. This function will only set the velocity, not
   /// actually move the sprite (&lt;see cref="MoveByVelocity"/&gt; is used to move sprites). This
   /// allows you to make the sprite react to many forces before moving it. In a multi-player
   /// game with two players in the same view this is useful for ensuring that both players
   /// remain on screen.
   /// &lt;seealso cref="ScrollSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Alter this sprite's velocity so that it remains within the map's visible area or within the scroll margins, according to this sprite's layer's position within the map.")]
   public void PushSpriteIntoView(bool StayInScrollMargins)
   {
      ParentLayer.PushSpriteIntoView(this, StayInScrollMargins);
   }

   /// &lt;summary&gt;
   /// Compute the index of the nearest active sprite from the specified category and return it.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Sprite category whose sprites will be searched for sprites near this sprite.&lt;/param&gt;
   /// &lt;returns&gt;An integer representing the 0-based index of the nearest active sprite, or -1 if
   /// there are no active sprites in the specified category.&lt;/returns&gt;
   /// &lt;remarks&gt;The output of this function would commonly be stored in a sprite parameter for
   /// passing to &lt;see cref="PushTowardCategory "/&gt;.&lt;/remarks&gt;
   [Description("Compute the index of the nearest active sprite from the specified category and return it.")]
   public int GetNearestSpriteIndex(SpriteCollection Target)
   {
      int minDist = int.MaxValue;
      int result = -1;
      for(int i = 0; i &lt; Target.Count; i++)
      {
         if (!Target[i].isActive)
            continue;
         int xOff = Target[i].PixelX - PixelX;
         int yOff = Target[i].PixelY - PixelY;
         int dist = xOff * xOff + yOff * yOff;
         if (dist &lt; minDist)
         {
            minDist = dist;
            result = i;
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Push this sprite toward a sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies a category containint the target
   /// sprite toward which this sprite will be pushed.&lt;/param&gt;
   /// &lt;param name="Index"&gt;Specifies the 0-based index of a sprite in the specified category.
   /// Use &lt;see cref="GetNearestSpriteIndex"/&gt; to compute the index of the nearest sprite, which
   /// can then be passed to this parameter.  Pass -1 in this parameter to push the sprite toward
   /// the current nearest sprite rather than a pre-computed index.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Force in tenths of a pixel per frame per frame that will be applied.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was pushed, or false if there are no active sprites in the
   /// target category or the sprite is already overlapping the target.&lt;/returns&gt;
   /// &lt;remarks&gt;If there is no active sprite in the target category, or if the sprite is overlapping
   /// the target exactly, this function will have no effect.
   /// &lt;seealso cref="SetInputsTowardCategory"/&gt;
   /// &lt;seealso cref="PushTowardSprite"/&gt;
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;&lt;/remarks&gt;
   [Description("Push this sprite toward a sprite in the specified category. Use GetNearestSpriteIndex to compute the index of the nearest sprite and pass that to Index, or pass -1 to push toward the current nearest sprite. Force is in tenths of a pixel per frame per frame.")]
   public bool PushTowardCategory(SpriteCollection Target, int Index, int Force)
   {
      Debug.Assert(this.isActive, "Attepmted to execute PushTowardCategory on an inactive sprite");
      Debug.Assert(Index &lt; Target.Count, "Attempted to PushTowardCategory on an index beyond the bounds of a collection");

      if (Index &lt; 0)
         Index = GetNearestSpriteIndex(Target);
      if (Index &lt; 0)
         return false;

      return PushTowardSprite(Target[Index], Force);
   }

   /// &lt;summary&gt;
   /// Push this sprite toward a specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Sprite toward which this sprite is pushed.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Acceleration force in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is pushed or false if the sprite is already overlapping
   /// the target.
   /// &lt;seealso cref="PushTowardCategory"/&gt;
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;
   /// &lt;seealso cref="SetInputsTowardCategory"/&gt;&lt;/returns&gt;
   public bool PushTowardSprite(SpriteBase Target, int Force)
   {
      double vx = Target.PixelX - PixelX + (Target.SolidWidth - SolidWidth) / 2;
      double vy = Target.PixelY - PixelY + (Target.SolidHeight - SolidHeight) / 2;
      double dist = Math.Sqrt(vx * vx + vy + vy);
      if (dist &gt;= 1)
      {
         dx += vx * Force / dist / 10.0;
         dy += vy * Force / dist / 10.0;
         return true;
      }
      return false;
   }
   #endregion

   #region States and animation

   /// &lt;summary&gt;
   /// Advance the animation frame of this sprite according to its velocity or a constant rate.
   /// &lt;/summary&gt;
   /// &lt;param name="Correlation"&gt;Determines how and if the sprite's animation speed should be
   /// based on its movement.&lt;/param&gt;
   [Description("Advance the animation frame of this sprite according to its velocity or a constant rate")]
   public void Animate(SpriteAnimationType Correlation)
   {
      Debug.Assert(this.isActive, "Attempted to execute Animate on an inactive sprite");
      switch(Correlation)
      {
         case SpriteAnimationType.ByFrame:
            frame++;
            break;
         case SpriteAnimationType.ByHorizontalVelocity:
            if (double.IsNaN(LocalDX))
               frame += System.Math.Abs(ProposedPixelX - PixelX);
            else
               frame += System.Math.Abs((int)LocalDX);
            break;
         case SpriteAnimationType.ByVerticalVelocity:
            if (double.IsNaN(LocalDY))
               frame += System.Math.Abs(ProposedPixelY - PixelY);
            else
               frame += System.Math.Abs((int)LocalDY);
            break;
         case SpriteAnimationType.ByVectorVelocity:
         {
            int tmpDx = ProposedPixelX - PixelX;
            int tmpDy = ProposedPixelY - PixelY;
            frame += (int)(System.Math.Sqrt(tmpDx * tmpDx + tmpDy * tmpDy));
         }
            break;
      }
   }

   /// &lt;summary&gt;
   /// Calculate the state that a rotating sprite should use in order to point in the direction it is currently traveling
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Provide the first state of this sprite's group of states (representing the sprite pointing rightward).&lt;/param&gt;
   /// &lt;param name="StateCount"&gt;Provide the number of states this sprite takes to represent one full rotation.&lt;/param&gt;
   /// &lt;returns&gt;&lt;paramref name="FirstState" /&gt; must represent the sprite in a rightward-aiming state, and each subsequent
   /// state must represent an equal counter-clockwise rotation until &lt;paramref name="StateCount" /&gt; states result in
   /// the sprite pointing almost rightward again. The returned state number will be in that range.
   /// The result of this can be stored directly into &lt;see cref="state"/&gt; if you want the sprite
   /// to switch to that state.&lt;/returns&gt;
   [Description("Return the state that a rotating sprite should use in order to point in the direction it is currently traveling, assuming that FirstState points rightward and each subsequent state is one step counter-clockwise")]
   public int GetPolarStateByVector([Editor("SpriteState", "UITypeEditor")] int FirstState, int StateCount)
   {
      double useDX, useDY;
      Debug.Assert(this.isActive, "Attempted to execute GetPolarStateByVector on an inactive sprite");
      if (double.IsNaN(LocalDX))
         useDX = dx;
      else
         useDX = LocalDX;
      if (double.IsNaN(LocalDY))
         useDY = dy;
      else
         useDY = LocalDY;
      return FirstState + ((StateCount + (int)Math.Round(System.Math.Atan2(-useDY,useDX) * StateCount / Math.PI / 2f)) % StateCount);
   }

   /// &lt;summary&gt;
   /// Switch the sprite to the the specified state, ensuring that the sprite doesn't hit a solid.
   /// &lt;/summary&gt;
   /// &lt;param name="State"&gt;State to which the sprite will be switched&lt;/param&gt;
   /// &lt;param name="Alignment"&gt;Specifies a point within the sprite which will remain constant.  For example, RelativePosition.BottomCenter will ensure that the bottom center point of the new state aligns with the bottom center point of this state.&lt;/param&gt;
   /// &lt;returns&gt;True if the state could be switched, false if the new state's differing size would
   /// have caused the sprite the sprite to pass through a solid tile.&lt;/returns&gt;
   /// &lt;remarks&gt;This function is handy for performing action like switching from a crouching
   /// state to a standing state because it will prevent you from standing up if there is a low
   /// ceiling in the way. It also helps you align the two states properly. For example, if you
   /// switched from the crouching state to the standing state without moving the sprite at
   /// all, the origin (usually the top left corner of the sprite) would remain in the same place,
   /// which would cause the head to remain in the same place and the feet to stick through the
   /// floor. But by using the Alignment paremeter, you can make sure that the botton of the
   /// new state aligns with the bottom of the current state.&lt;/remarks&gt;
   [Description("Switch the sprite to the the specified state, ensuring that the specified alignment point in the new state lines up with the same point in the current state.  Returns false if the state could not switch due to solidity.")]
   public bool SwitchToState([Editor("SpriteState", "UITypeEditor")] int State, RelativePosition Alignment)
   {
      Debug.Assert(this.isActive, "Attempted to execute SwitchToState on an inactive sprite");
      System.Drawing.Rectangle oldRect = new System.Drawing.Rectangle(PixelX, PixelY, SolidWidth, SolidHeight);
      int newWidth = this[State].SolidWidth;
      int newHeight = this[State].SolidHeight;
      double newX, newY;
      switch(Alignment)
      {
         case RelativePosition.TopCenter:
         case RelativePosition.CenterMiddle:
         case RelativePosition.BottomCenter:
            newX = x + (oldRect.Width - newWidth) / 2f;
            break;
         case RelativePosition.TopRight:
         case RelativePosition.RightMiddle:
         case RelativePosition.BottomRight:
            newX = x + oldRect.Width - newWidth;
            break;
         default:
            newX = x;
            break;
      }
      switch(Alignment)
      {
         case RelativePosition.LeftMiddle:
         case RelativePosition.CenterMiddle:
         case RelativePosition.RightMiddle:
            newY = y + (oldRect.Height - newHeight) / 2f;
            break;
         case RelativePosition.BottomLeft:
         case RelativePosition.BottomCenter:
         case RelativePosition.BottomRight:
            newY = y + oldRect.Height - newHeight;
            break;
         default:
            newY = y;
            break;
      }

      if (((int)Math.Ceiling(newY + newHeight) &gt; oldRect.Bottom) &amp;&amp; (layer.GetTopSolidPixel(new System.Drawing.Rectangle(
         (int)newX, oldRect.Bottom, newWidth, (int)Math.Ceiling(newY) + newHeight - oldRect.Bottom), m_solidity) != int.MinValue))
         return false;

      if (((int)newY &lt; oldRect.Top) &amp;&amp; (layer.GetBottomSolidPixel(new System.Drawing.Rectangle(
         (int)newX, (int)newY, newWidth, oldRect.Top - (int)newY), m_solidity) != int.MinValue))
         return false;

      if (((int)newX &lt; oldRect.Left) &amp;&amp; (layer.GetRightSolidPixel(new System.Drawing.Rectangle(
         (int)newX, (int)newY, oldRect.Left - (int)newX, newHeight), m_solidity) != int.MinValue))
         return false;

      if (((int)Math.Ceiling(newX + newWidth) &gt; oldRect.Right) &amp;&amp; (layer.GetLeftSolidPixel(new System.Drawing.Rectangle(
         oldRect.Right, (int)newY, (int)Math.Ceiling(newX) + newWidth - oldRect.Right, newHeight), m_solidity) != int.MinValue))
         return false;

      x = newX;
      y = newY;
      state = State;
      return true;
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is in the specified range of states.
   /// &lt;/summary&gt;
   /// &lt;param name="FirstState"&gt;Minimum state number&lt;/param&gt;
   /// &lt;param name="LastState"&gt;Maximum state number&lt;/param&gt;
   /// &lt;returns&gt;Returns true if the sprite's current state is equal to &lt;paramref name="FirstState" /&gt; or
   /// &lt;paramref name="LastState" /&gt; or any state in between. False otherwise.&lt;/returns&gt;
   [Description("Determines if the sprite is in the specified range of states")]
   public bool IsInState([Editor("SpriteState", "UITypeEditor")] int FirstState, [Editor("SpriteState", "UITypeEditor")] int LastState)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsInState on an inactive sprite");
      return (state &gt;= FirstState) &amp;&amp; (state &lt;= LastState);
   }

   /// &lt;summary&gt;
   /// Affects the sprite's visibility.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, the sprite will be drawn half-transparent.
   /// By setting it to 255, it draws in the usual way (as defined). This value is
   /// merged with the ModulateAlpha value in the frames that make up the sprite.
   /// So if the frame is set to ModulateAlpha=128 and the sprite ModulateAlpha=128,
   /// then the final visibility of the frame will only be 25% (64).
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public int ModulateAlpha
   {
      get
      {
         return color &gt;&gt; 24;
      }
      set
      {
         color = color &amp; 0x00FFFFFF | (byte)(value%256) &lt;&lt; 24;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of red when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the red will be output, causing the
   /// sprite to appear more cyan (blue/green) than normal. This value is merged with
   /// the ModulateRed value in the frames that make up the sprite. So if the frame is
   /// set to ModulateRed=128 and the sprite ModulateRed=128, then the final image will
   /// only contain 25% of the original red.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public int ModulateRed
   {
      get
      {
         return (color &amp; 0x00FF0000) &gt;&gt; 16;
      }
      set
      {
         color = (int)(color &amp; 0xFF00FFFF) | (byte)(value%256) &lt;&lt; 16;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of green when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the green will be output, causing the
   /// sprite to appear more magenta (red+blue) than normal. This value is merged with
   /// the ModulateGreen value in the frames that make up the sprite. So if the frame is
   /// set to ModulateGreen=128 and the sprite ModulateGreen=128, then the final image will
   /// only contain 25% of the original red.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public int ModulateGreen
   {
      get
      {
         return (color &amp; 0x0000FF00) &gt;&gt; 8;
      }
      set
      {
         color = (int)(color &amp; 0xFFFF00FF) | (byte)(value%256) &lt;&lt; 8;
      }
   }

   /// &lt;summary&gt;
   /// Affects the output of blue when this sprite is drawn.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;By setting this to 128, only half the blue will be output, causing the
   /// sprite to appear more yellow (red+green) than normal. This value is merged with
   /// the ModulateBlue value in the frames that make up the sprite. So if the frame is
   /// set to ModulateBlue=128 and the sprite ModulateBlue=128, then the final image will
   /// only contain 25% of the original blue.
   /// &lt;seealso cref="color"/&gt;&lt;/remarks&gt;
   public int ModulateBlue
   {
      get
      {
         return color &amp; 0xFF;
      }
      set
      {
         color = (int)(color &amp; 0xFFFFFF00) | (byte)(value%256);
      }
   }
   #endregion

   #region Input Processing
   /// &lt;summary&gt;
   /// Determine if the specified input is being pressed for this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Input"&gt;Which of thes sprite's inputs should be checked&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If this is true, the result will only be true if the input has just been pressed and was not pressed before.&lt;/param&gt;
   /// &lt;returns&gt;If &lt;paramref name="InitialOnly" /&gt; is set, true only when the specified input on this
   /// sprite has just been turned on or pressed, otherwise true if the input is currently on or
   /// "pressed" regardless of the previous state of the input.&lt;/returns&gt;
   /// &lt;remarks&gt;This function uses &lt;see cref="oldinputs"/&gt; to determine whether an input
   /// was pressed before or not (when InitialOnly is true). &lt;see cref="oldinputs"/&gt;
   /// is automatically managed by the &lt;see cref="MapPlayerToInputs"/&gt; function.
   /// &lt;seealso cref="oldinputs"/&gt;&lt;/remarks&gt;
   [Description("Determine if the specified input is being pressed for this sprite.  InitialOnly causes this to return true only if the input has just been pressed and was not pressed before.")]
   public bool IsInputPressed(InputBits Input, bool InitialOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsInputPressed on an inactive sprite");
      return (0 != (inputs &amp; Input)) &amp;&amp; 
         (!InitialOnly || (0 == (oldinputs &amp; Input)));
   }

   /// &lt;summary&gt;
   /// Turns on or off the specified input on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Input"&gt;Indicates a particular input to be affected.&lt;/param&gt;
   /// &lt;param name="Press"&gt;True if the input should be turned on or "pressed", False if the
   /// input should be turned off or "released".&lt;/param&gt;
   /// &lt;remarks&gt;Although this function can be used to set a sprite's inputs based on rules,
   /// &lt;see cref="MapPlayerToInputs"/&gt; is the recommended means for setting inputs on a
   /// sprite. &lt;see cref="SetInputState"/&gt; does not affect &lt;see cref="oldinputs"/&gt;, so if
   /// you want to use this function with the InitialOnly feature of
   /// &lt;see cref="IsInputPressed"/&gt;, you will have to manage &lt;see cref="oldinputs"/&gt;
   /// manually.&lt;/remarks&gt;
   [Description("Turns on or off the specified input on this sprite.")]
   public void SetInputState(InputBits Input, bool Press)
   {
      Debug.Assert(this.isActive, "Attempted to execute SetInputState on an inactive sprite");
      if (Press)
         inputs |= Input;
      else
         inputs &amp;= ~Input;
   }

   /// &lt;summary&gt;
   /// Turns off all current inputs on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="SetOldInputs"&gt;True if you want to remember the current set of inputs
   /// as the inputs for the previous frame (&lt;see cref="oldinputs"/&gt;).
   /// False if you just want to clear the inputs.&lt;/param&gt;
   [Description("Turns off all current inputs on this sprite.")]
   public void ClearInputs(bool SetOldInputs)
   {
      Debug.Assert(this.isActive, "Attempted to execute ClearInputs on an inactive sprite");
      if (SetOldInputs)
         oldinputs = inputs;
      inputs = 0;
   }

   /// &lt;summary&gt;
   /// Associates the state of the specified keyboard key with the specified input on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="key"&gt;Which key should be tested&lt;/param&gt;
   /// &lt;param name="Input"&gt;Which sprite input should be affected&lt;/param&gt;
   /// &lt;remarks&gt;This function does not affect &lt;see cref="oldinputs"/&gt;.&lt;/remarks&gt;
   [Description("Associates the state of the specified keyboard key with the specified input on this sprite.")]
   public void MapKeyToInput(Microsoft.DirectX.DirectInput.Key key, InputBits Input)
   {
      Debug.Assert(this.isActive, "Attempted to execute MapKeyToInput on an inactive sprite");
      SetInputState(Input, Project.GameWindow.KeyboardState[key]);
   }

   /// &lt;summary&gt;
   /// Associate the state of the input device for the specified player with the inputs on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="PlayerNumber"&gt;Player number 1 through 4. The number must not exceed
   /// the maximum number of players specified in the project properties and stored in
   /// &lt;see cref="Project.MaxPlayers"/&gt;.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;Before the inputs are mapped from the player's input device to the sprite,
   /// the existing inputs are copied from &lt;see cref="inputs"/&gt; to &lt;see cref="oldinputs"/&gt;
   /// so other rules will be able to determine which inputs were pressed before.&lt;/para&gt;
   /// &lt;para&gt;The input device is defined by the player at runtime, and may come from a
   /// joystick, gamepad or keyboard.&lt;/para&gt;&lt;/remarks&gt;
   [Description("Associate the state of the input device for the specified player (1-4) with the inputs on this sprite.")]
   public void MapPlayerToInputs(int PlayerNumber)
   {
      Debug.Assert(this.isActive, "Attempted to execute MapPlayerToInput on an inactive sprite");
      if (PlayerNumber &gt; Project.MaxPlayers)
      {
         Debug.Fail("Attempted to map inactive player input");
         return;
      }
      oldinputs = inputs;
      IPlayer player = Project.GameWindow.Players[PlayerNumber-1];
      inputs = 0;
      if (player.Up) inputs |= InputBits.Up;
      if (player.Left) inputs |= InputBits.Left;
      if (player.Right) inputs |= InputBits.Right;
      if (player.Down) inputs |= InputBits.Down;
      if (player.Button1) inputs |= InputBits.Button1;
      if (player.Button2) inputs |= InputBits.Button2;
      if (player.Button3) inputs |= InputBits.Button3;
      if (player.Button4) inputs |= InputBits.Button4;
   }

   /// &lt;summary&gt;
   /// Accelerate this sprite according to which directional inputs are on/pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Acceleration"&gt;Specifies how much effect any input can have on acceleration in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;param name="Max"&gt;Specifies the maximum speed to which the sprite can accelerate along any particular axis in pixels per frame&lt;/param&gt;
   /// &lt;param name="HorizontalOnly"&gt;If this is true, only horizontal acceleration will be applied. (Often times in platform games,
   /// a sprite can move horizontally, but in order to move vertically, must jump.)&lt;/param&gt;
   /// &lt;remarks&gt;If the sprite's &lt;see cref="LocalDX"/&gt; or &lt;see cref="LocalDY"/&gt; properties are
   /// set (if the sprite is riding another sprite) this will affect the local velocity and
   /// affect &lt;see cref="dx"/&gt; and/or &lt;see cref="dy"/&gt; only indirectly.&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example would accelerate a sprite horizontally at 1 pixel per frame per frame
   /// up to a maximum of 5 pixels per frame.
   /// &lt;code&gt;AccelerateByInputs(10, 5, true)&lt;/code&gt;&lt;/example&gt;
   [Description("Accelerate this sprite according to which directional inputs are on.  Acceleration is in tenths of a pixel per frame squared.  Max is in pixels per frame.")]
   public void AccelerateByInputs(int Acceleration, int Max, bool HorizontalOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute AccelerateByInputs on an inactive sprite");
      if (!HorizontalOnly)
      {
         if (double.IsNaN(LocalDY))
         {
            if (0 != (inputs &amp; InputBits.Up))
               dy -= ((double)Acceleration)/10.0d;
            if (dy &lt; -(double)Max)
               dy = -(double)Max;
            if (0 != (inputs &amp; InputBits.Down))
               dy += ((double)Acceleration)/10.0d;
            if (dy &gt; (double)Max)
               dy = (double)Max;
         }
         else
         {
            if (0 != (inputs &amp; InputBits.Up))
               LocalDY -= ((double)Acceleration)/10.0d;
            if (LocalDY &lt; -(double)Max)
               LocalDY = -(double)Max;
            if (0 != (inputs &amp; InputBits.Down))
               LocalDY += ((double)Acceleration)/10.0d;
            if (LocalDY &gt; (double)Max)
               LocalDY = (double)Max;
         }
      }
      if (double.IsNaN(LocalDX))
      {
         if (0 != (inputs &amp; InputBits.Left))
            dx -= ((double)Acceleration)/10.0d;
         if (dx &lt; -(double)Max)
            dx = -(double)Max;
         if (0 != (inputs &amp; InputBits.Right))
            dx += ((double)Acceleration)/10.0d;
         if (dx &gt; (double)Max)
            dx = (double)Max;
      }
      else
      {
         if (0 != (inputs &amp; InputBits.Left))
            LocalDX -= ((double)Acceleration)/10.0d;
         if (LocalDX &lt; -(double)Max)
            LocalDX = -(double)Max;
         if (0 != (inputs &amp; InputBits.Right))
            LocalDX += ((double)Acceleration)/10.0d;
         if (LocalDX &gt; (double)Max)
            LocalDX = (double)Max;
      }
   }

   /// &lt;summary&gt;
   /// Set the state of the directional inputs on this sprite to move toward the specified sprite in a category.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite collection containing the sprite toward which this sprite will try to move.&lt;/param&gt;
   /// &lt;param name="Index"&gt;Use &lt;see cref="GetNearestSpriteIndex"/&gt; to compute this value or pass -1 to compute the current nearest sprite each time this is called.&lt;/param&gt;
   /// &lt;remarks&gt;This function assumes that the directional inputs on the sprite
   /// cause the sprite to move directly in the direction associated with the input.  It will
   /// not work if, for example, left arrow causes the sprite to turn left instead of move left.
   /// &lt;seealso cref="SetInputsTowardSprite"/&gt;
   /// &lt;seealso cref="PushTowardCategory"/&gt;
   /// &lt;seealso cref="GetNearestSpriteIndex"/&gt;&lt;/remarks&gt;
   [Description("Set the state of the directional inputs on this sprite to move toward the specified sprite in a category, assuming the input causes the sprite to move directly in its direction. Use GetNearestSpriteIndex to compute an Index or pass -1 to use the current nearest sprite.")]
   public void SetInputsTowardCategory(SpriteCollection Target, int Index)
   {
      Debug.Assert(this.isActive, "Attepmted to execute SetInputsTowardCategory on an inactive sprite");
      Debug.Assert(Index &lt; Target.Count, "Attempted to SetInputsTowardCategory on an index beyond the bounds of a collection");

      if (Index &lt; 0)
         Index = GetNearestSpriteIndex(Target);
      if (Index &lt; 0)
         return;

      SetInputsTowardSprite(Target[Index]);
   }

   /// &lt;summary&gt;
   /// Set the state of the directional inputs on this sprite to move toward the specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite collection containing the sprite toward which
   /// this sprite will try to move.&lt;/param&gt;
   /// &lt;remarks&gt;This function is not exposed as a rule function because it is intended to be
   /// called by a plan or other code that can provide a target sprite based on specific
   /// context whereas a sprite definition rule function is supposed to be generic.
   /// This is called by &lt;see cref="SetInputsTowardCategory"/&gt;.&lt;/remarks&gt;
   public void SetInputsTowardSprite(SpriteBase Target)
   {
      int targetCenter = Target.PixelX + Target.SolidWidth / 2;
      int myCenter = PixelX + SolidWidth / 2;

      if (targetCenter &lt; myCenter)
         inputs |= InputBits.Left;
      else if (targetCenter &gt; myCenter)
         inputs |= InputBits.Right;
      else
         inputs &amp;= ~(InputBits.Left | InputBits.Right);

      targetCenter = Target.PixelY + Target.SolidHeight / 2;
      myCenter = PixelY + SolidHeight / 2;
      if (targetCenter &lt; myCenter)
         inputs |= InputBits.Up;
      else if (targetCenter &gt; myCenter)
         inputs |= InputBits.Down;
      else
         inputs &amp;= ~(InputBits.Up | InputBits.Down);
   }
   #endregion

   #region Solidity
   /// &lt;summary&gt;
   /// Set the solidity rules to which the sprite is currently reacting.
   /// &lt;/summary&gt;
   /// &lt;param name="Solidity"&gt;Specified which solidity rules should adopt.&lt;/param&gt;
   /// &lt;remarks&gt;Since solidity is based on tile categories which in turn can contain
   /// tiles from multiple tilesets, the same solidity definition can apply to any
   /// number of maps with different tilesets. So this doesn't need to be called
   /// just to handle tiles from a different tileset, but could be called to make
   /// the sprite act differently to all tiles (for example, to suddenly be able to
   /// traverse any water).&lt;/remarks&gt;
   [Description("Set the solidity rules to which the sprite is currently reacting.")]
   public void SetSolidity(Solidity Solidity)
   {
      m_solidity = Solidity;
   }

   /// &lt;summary&gt;
   /// Alter the sprite's velocity to react to solid areas on the map.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;True if the sprite's velocity was altered; in other words, if it pushed
   /// against something solid. That doesn't necessarily mean the sprite was stoped by
   /// something solid because it may just be pushed uphill.&lt;/returns&gt;
   /// &lt;remarks&gt;It is recommended that this be the last rule applied to the sprite's velocity
   /// before &lt;see cref="MoveByVelocity"/&gt; is applied. This will help ensure that the sprite
   /// never goes through solids even if scrolling and platforms try to make it.&lt;/remarks&gt;
   [Description("Alter the sprite's velocity to react to solid areas on the map.  Returns true if velocity is affected by solid.")]
   public bool ReactToSolid()
   {
      Debug.Assert(this.isActive, "Attempted to execute ReactToSolid on an inactive sprite");
      bool hit = false;
      double dyOrig = dy;

      int ProposedPixelY2 = (int)Math.Ceiling(y+dy);
      int SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
      if (dy &gt; 0)
      {
         int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY+SolidHeight, SolidPixelWidth, ProposedPixelY2 - PixelY), m_solidity);
         if (ground != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ground - SolidHeight - y;
            hit = true;
         }
      } 
      else if (dy &lt; 0)
      {
         int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX, ProposedPixelY, SolidPixelWidth, PixelY - ProposedPixelY), m_solidity);
         if (ceiling != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ceiling + 1 - y;
            hit = true;
         }
      }

      if (dx &gt; 0)
      {
         int ProposedPixelX2 = (int)Math.Ceiling(x+dx);
         int PixelX2 = (int)Math.Ceiling(x);
         int rightwall = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, ProposedPixelY, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
         bool hitWall = false;
         if (rightwall != int.MinValue)
         {
            int maxSlopeProposedY = (int)(y + dy - dx);
            int slopedFloor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, maxSlopeProposedY + SolidHeight, ProposedPixelX2 - PixelX2, ProposedPixelY - maxSlopeProposedY), m_solidity);
            if (slopedFloor != int.MinValue)
            {
               int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX2, slopedFloor - SolidHeight, SolidWidth, ProposedPixelY + SolidHeight - slopedFloor), m_solidity);
               if ((ceiling == int.MinValue) &amp;&amp; (RidingOn == null))
               {
                  int rightwall2 = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, slopedFloor - SolidHeight, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
                  if (rightwall2 == int.MinValue)
                     // Do integer arithmetic before double otherwise strange rounding seems to happen
                     dy = dyOrig = slopedFloor - SolidHeight - 1 - y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
            {
               maxSlopeProposedY = (int)(y + dy + dx);
               int slopedCeiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, ProposedPixelY, ProposedPixelX2 - PixelX2, maxSlopeProposedY - ProposedPixelY), m_solidity);
               if (slopedCeiling != int.MinValue)
               {
                  slopedCeiling++;
                  int floor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX2, ProposedPixelY + SolidHeight, SolidWidth, slopedCeiling - ProposedPixelY), m_solidity);
                  if ((floor == int.MinValue) &amp;&amp; (RidingOn == null))
                  {
                     int rightwall2 = layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX2 + SolidWidth, slopedCeiling, ProposedPixelX2 - PixelX2, SolidHeight), m_solidity);
                     if (rightwall2 == int.MinValue)
                        dy = dyOrig = slopedCeiling - y;
                     else
                        hitWall = true;
                  }
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            if (hitWall)
            {
               // Do integer arithmetic before double otherwise strange rounding seems to happen
               dx = rightwall - SolidWidth - x;
            }
            hit = true;
         }
      }
      else if (dx &lt; 0)
      {
         int leftwall = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, PixelX - ProposedPixelX, SolidHeight), m_solidity);
         bool hitWall = false;
         if (leftwall != int.MinValue)
         {
            int maxSlopeProposedY = (int)(y + dy + dx);
            int slopedFloor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, maxSlopeProposedY + SolidHeight, PixelX - ProposedPixelX, ProposedPixelY - maxSlopeProposedY), m_solidity);
            if (slopedFloor != int.MinValue)
            {
               int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, slopedFloor - SolidHeight, SolidWidth, ProposedPixelY + SolidHeight - slopedFloor), m_solidity);
               if ((ceiling == int.MinValue) &amp;&amp; (RidingOn == null))
               {
                  int leftwall2 = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, slopedFloor - SolidHeight, PixelX - ProposedPixelX, SolidHeight), m_solidity);
                  if (leftwall2 == int.MinValue)
                     // Do integer arithmetic before double otherwise strange rounding seems to happen
                     dy = dyOrig = slopedFloor - SolidHeight - 1 - y;
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            else
            {
               maxSlopeProposedY = (int)(y + dy - dx);
               int slopedCeiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, PixelX - ProposedPixelX, maxSlopeProposedY - ProposedPixelY), m_solidity);
               if (slopedCeiling != int.MinValue)
               {
                  slopedCeiling++;
                  int floor = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY + SolidHeight, SolidWidth, slopedCeiling - ProposedPixelY), m_solidity);
                  if ((floor == int.MinValue) &amp;&amp; (RidingOn == null))
                  {
                     int leftwall2 = layer.GetRightSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, slopedCeiling, PixelX - ProposedPixelX, SolidHeight), m_solidity);
                     if (leftwall2 == int.MinValue)
                        dy = dyOrig = slopedCeiling - y;
                     else
                        hitWall = true;
                  }
                  else
                     hitWall = true;
               }
               else
                  hitWall = true;
            }
            if (hitWall)
            {
               // Do integer arithmetic before double otherwise strange rounding seems to happen
               dx = leftwall + 1 - x;
            }
            hit = true;
         }
      }

      dy = dyOrig;

      int ProposedSolidPixelWidth = SolidWidth + (int)Math.Ceiling(x+dx) - ProposedPixelX;
      if (dy &gt; 0)
      {
         ProposedPixelY2 = (int)Math.Ceiling(y+dy);
         int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, PixelY+SolidHeight, ProposedSolidPixelWidth, ProposedPixelY2 - PixelY), m_solidity);
         if (ground != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ground - SolidHeight - y;
            hit = true;
         }
      }
      else if (dy &lt; 0)
      {
         int ceiling = layer.GetBottomSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY, ProposedSolidPixelWidth, PixelY - ProposedPixelY), m_solidity);
         if (ceiling != int.MinValue)
         {
            // Do integer arithmetic before double otherwise strange rounding seems to happen
            dy = ceiling + 1 - y;
            hit = true;
         }
      }

      return hit;
   }

   /// &lt;summary&gt;
   /// Ensure the sprite stays in contact with the ground by altering its velocity
   /// to snap down onto the ground when it is close to the ground.
   /// &lt;/summary&gt;
   /// &lt;param name="Threshhold"&gt;The number of pixels that mey separate the sprite from the ground.
   /// If the sprite is within this threshhold distance, it will be "snapped".&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite was snapped to the ground.&lt;/returns&gt;
   /// &lt;remarks&gt;Note that this does not actually move the sprite, but rather just alters its
   /// velocity so that when &lt;see cref="MoveByVelocity"/&gt; is applied, it will be touching the
   /// ground, if the appropriate conditions are met. The purpose of this rule is to help sprites
   /// behave as desired when going downhill in case the force of gravity isn't enough to keep
   /// them "grounded" (which it often isn't with the simple physics model used for sprites).
   /// &lt;/remarks&gt;
   [Description("If the sprite's proposed position is within &lt;Threshhold&gt; pixels of the ground, alter its velocity so it will touch the ground.  Returns true if snap occurred.")]
   public bool SnapToGround(int Threshhold)
   {
      Debug.Assert(this.isActive, "Attempted to execute SnapToGround on an inactive sprite");

      int ProposedSolidPixelWidth = SolidWidth + (int)Math.Ceiling(x+dx) - ProposedPixelX;
      int ground = layer.GetTopSolidPixel(new System.Drawing.Rectangle(ProposedPixelX, ProposedPixelY+SolidHeight, ProposedSolidPixelWidth, Threshhold), m_solidity);
      if (ground != int.MinValue)
      {
         // Do integer arithmetic before double otherwise strange rounding seems to happen
         double newDy = ground - SolidHeight - y;
         if (newDy &gt; dy)
            dy = newDy;
         return true;
      }
      return false;
   }

   /// &lt;summary&gt;
   /// Determines if the sprite is blocked from moving freely in a particular direction by solidity on the layer.
   /// &lt;/summary&gt;
   /// &lt;param name="Direction"&gt;Which direction should be tested&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite's velocity will be affected or stopped when attempting
   /// to move in the specified direction.  False if the sprite can move freely in that
   /// direction.&lt;/returns&gt;
   /// &lt;remarks&gt;Note that this function only tests if there is any solidity in the specified
   /// direction, but does not indicate whether the sprite will be blocked by it or simply
   /// deflected (up or down a hill) by it.&lt;/remarks&gt;
   [Description("Determines if the sprite is blocked from moving freely in a particular direction by solidity on the layer.")]
   public bool Blocked(Direction Direction)
   {
      Debug.Assert(this.isActive, "Attempted to execute Blocked on an inactive sprite");

      int SolidPixelWidth;
      int SolidPixelHeight;
      switch(Direction)
      {
         case Direction.Up:
            SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
            return layer.GetBottomSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY-1, SolidPixelWidth, 1), m_solidity) != int.MinValue;
         case Direction.Right:
            SolidPixelHeight = SolidHeight + (int)Math.Ceiling(y) - PixelY;
            return layer.GetLeftSolidPixel(new System.Drawing.Rectangle(PixelX+SolidWidth, PixelY, 1, SolidPixelHeight), m_solidity) != int.MinValue;
         case Direction.Down:
            SolidPixelWidth = SolidWidth + (int)Math.Ceiling(x) - PixelX;
            return layer.GetTopSolidPixel(new System.Drawing.Rectangle(PixelX, PixelY+SolidHeight, SolidPixelWidth, 1), m_solidity) != int.MinValue;
         case Direction.Left:
            SolidPixelHeight = SolidHeight + (int)Math.Ceiling(y) - PixelY;
            return layer.GetRightSolidPixel(new System.Drawing.Rectangle(PixelX - 1, PixelY, 1, SolidPixelHeight), m_solidity) != int.MinValue;
      }
      return false;
   }

   #endregion

   #region Tile Interaction
   /// &lt;summary&gt;
   /// Tracks information about a tile for the purposes of processing interactions
   /// between a sprite and a tile that it is touching.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Instances of this class are created by &lt;see cref="TouchTiles"/&gt;.
   /// and added to &lt;see cref="TouchedTiles"/&gt;.&lt;/remarks&gt;
   public class TouchedTile
   {
      public int x;
      public int y;
      public int tileValue;
      public bool initial;
      public bool processed;

      public TouchedTile(int x, int y, int tileValue, bool initial)
      {
         this.x = x;
         this.y = y;
         this.tileValue = tileValue;
         this.initial = initial;
         processed = false;
      }
   }

   // Do not allocate appreciable memory unless this sprite
   // participates in tile interaction.
   /// &lt;summary&gt;
   /// A collection of tiles being processed by &lt;see cref="TouchTiles"/&gt; and other rules
   /// related to tile interactions.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;&lt;see cref="TouchTiles"/&gt; populates this object, and other touch-functions
   /// then process the data about tiles that the sprite is touching stored in this
   /// object. It's not usually necessary to refer to this object directly.&lt;/remarks&gt;
   [NonSerialized()]
   public System.Collections.ArrayList TouchedTiles = null;

   /// &lt;summary&gt;
   /// Collects information about tiles the sprite is currently touching.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;This should supply a tile category that includes all tiles that the sprite interacts with.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is touching any tiles in the supplied category.&lt;/returns&gt;
   /// &lt;remarks&gt;This must be called before performing most forms of tile interaction.
   /// By supplying a single category containing all tiles with which the sprite may need
   /// to interact, performance is optimized so that each tile touching the sprite only
   /// needs to be inspected once to check if it's relevant.  This also helps simplify the
   /// process of processing each tile exactly once by queuing a list of tiles to be
   /// processed and tracking which of those tiles have been processed.
   /// &lt;seealso cref="TileTake"/&gt;&lt;seealso cref="TileUseUp"/&gt;&lt;seealso cref="TileTouchingIndex"/&gt;
   /// &lt;seealso cref="TileActivateSprite"/&gt;&lt;seealso cref="TileAddSprite"/&gt;
   /// &lt;seealso cref="TileChange"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;This example will check to see if the current sprite is touching
   /// any tiles in a category named "Touchable" and then (assuming tile numbers 10
   /// and 11 are members of this category) take any tiles whose number is 10 as an
   /// inventory item represented by a counter named "Coins", and take any tiles whose
   /// number is 11 as an inventory item represented by a counter named "Keys".
   /// &lt;code lang="C#"&gt;
   /// if (TouchTiles(TileCategoryName.Touchable))
   /// {
   ///    TileTake(10,Counter.Coins))
   ///    TileTake(11,Counter.Keys))
   /// }&lt;/code&gt;&lt;/example&gt;
   [Description("Collects information about tiles the sprite is currently touching.  Category should include all tiles that the sprite interacts with.  Must be called before performing any tile interaction.")]
   public bool TouchTiles(TileCategoryName Category)
   {
      Debug.Assert(this.isActive, "Attempted to execute TouchTiles on an inactive sprite");
      
      if (TouchedTiles != null)
         TouchedTiles.Clear();

      int tw = layer.Tileset.TileWidth;
      int th = layer.Tileset.TileHeight;
      int minYEdge = (PixelY / th);
      int maxY = (PixelY + SolidHeight) / th;
      if (maxY &gt;= layer.VirtualRows)
         maxY = layer.VirtualRows -1;
      int maxYEdge = (PixelY + SolidHeight - 1) / th;
      int minX = (PixelX - 1)/ tw;
      int minXEdge = PixelX / tw;
      int maxX = (PixelX + SolidHeight) / tw;
      if (maxX &gt;= layer.VirtualColumns)
         maxX = layer.VirtualColumns - 1;
      int maxXEdge = (PixelX + SolidHeight - 1) / tw;
      for (int yidx = (PixelY - 1) / th; yidx &lt;= maxY; yidx++)
      {
         bool isYEdge = !((yidx &gt;= minYEdge) &amp;&amp; (yidx &lt;= maxYEdge));
         for (int xidx = (isYEdge ? minXEdge : minX);
            xidx &lt;= (isYEdge ? maxXEdge : maxX);
            xidx++)
         {
            if (layer.GetTile(xidx, yidx).IsMember(Category))
            {
               bool wasTouching;

               if ((OldPixelX &lt;= xidx * tw + tw) &amp;&amp;
                  (OldPixelX + SolidWidth &gt;= xidx * tw) &amp;&amp;
                  (OldPixelY &lt;= yidx * th + th) &amp;&amp;
                  (OldPixelY + SolidHeight &gt;= yidx * th))
               {
                  bool edgeX = (OldPixelX+SolidWidth == xidx * tw) || 
                     (OldPixelX == xidx * tw + tw);
                  bool edgeY = (OldPixelY+SolidHeight == yidx * th) ||
                     (OldPixelY == yidx * th + th);
                  if (edgeX &amp;&amp; edgeY)
                     wasTouching = false;
                  else
                     wasTouching = true;
               }
               else
                  wasTouching = false;
               
               if (TouchedTiles == null)
                  TouchedTiles = new System.Collections.ArrayList(10);
               TouchedTiles.Add(new TouchedTile(xidx, yidx, layer[xidx, yidx], !wasTouching));
            }
         }
      }
      if (TouchedTiles == null)
         return false;
      return TouchedTiles.Count &gt; 0;
   }

   /// &lt;summary&gt;
   /// Determine if the sprite is touching the specified tile, and if so,
   /// "take" it and increment a counter (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Index of the tile to look for.&lt;/param&gt;
   /// &lt;param name="Counter"&gt;Counter to be checked and incremented when the specified tile is found.
   /// If the counter's maximum value has been reached, the tile will not be taken.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function will search through all tiles that have been touched (collected
   /// by &lt;see cref="TouchTiles"/&gt;, and for each tile that it finds that matches the specified
   /// &lt;paramref name="TileValue" /&gt;, it will check &lt;paramref name="Counter" /&gt;, and, if it
   /// has not yet reached the maximum value, increment the counter and replace the tile with
   /// tile number 0.&lt;/para&gt;&lt;para&gt;
   /// Only unprocessed tiles are considered. Once this function (or similar functions)
   /// affects the tile, it is marked as processed. It is only marked as processed if
   /// it is affected (if the counter changes).&lt;/para&gt;&lt;/remarks&gt;
   [Description("When the sprite is touching the specified tile, and the specified counter is not maxed, clear the tile value to 0 and increment the specified counter/parameter. Returns the number of tiles affected. (Must run TouchTiles first.)")]
   public int TileTake(int TileValue,  Counter Counter)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileTake on an inactive sprite");

      if (TouchedTiles == null)
         return 0 ;

      int result = 0;

      for (int i=0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = (TouchedTile)TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed))
         {
            if (Counter.CurrentValue &lt; Counter.MaxValue)
            {
               Counter.CurrentValue++;
               layer[tt.x, tt.y] = tt.tileValue = 0;
               tt.processed = true;
               result++;
            }
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Make the specified tile behave like it is "using up" one of the items tracked by the specified counter (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Index of the tile to look for&lt;/param&gt;
   /// &lt;param name="Counter"&gt;Specifies a counter that will be affected. If this counter's value is
   /// greater than 0, it will be decremented and the tile removed.&lt;/param&gt;
   /// &lt;param name="NewValue"&gt;Specifies a new tile value that will replace the touched tile when
   /// it is removed. This value is commonly 0, which usually represents a tileset's empty tile.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function will search through all tiles that have been touched (collected
   /// by &lt;see cref="TouchTiles"/&gt;, and for each tile that it finds that matches the specified
   /// &lt;paramref name="TileValue" /&gt;, it will check &lt;paramref name="Counter" /&gt;, and, if it
   /// is greater than 0, decrement the counter and replace the tile with tile number
   /// &lt;paramref name="NewValue"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;Only unprocessed tiles are considered. Once this function (or similar functions)
   /// affects the tile, it is marked as processed. It is only marked as processed if
   /// it is affected (if the counter changes).&lt;/para&gt;&lt;/remarks&gt;
   [Description("When the sprite is touching the specified tile, and the specified counter is greater than 0, decrement the counter and clear the tile value to 0. Returns the number of tiles affected. (Must run TouchTiles first.)")]
   public int TileUseUp(int TileValue,  Counter Counter, int NewValue)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileUseUp on an inactive sprite");

      if (TouchedTiles == null)
         return 0;

      int result = 0;

      for (int i=0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = (TouchedTile)TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed))
         {
            if (Counter.CurrentValue &gt; 0)
            {
               Counter.CurrentValue--;
               layer[tt.x, tt.y] = tt.tileValue = NewValue;
               tt.processed = true;
               result++;
            }
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Find the next unprocessed tile of the specified type (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="TileValue"&gt;Tile index to search for&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If this is true, the tile will only be considered if the sprite
   /// just started touching it (was not touching it before).&lt;/param&gt;
   /// &lt;param name="MarkAsProcessed"&gt;If this is true, the tile that is returned is immediately
   /// marked as processed, otherwise it is left as unprocessed and may still be affected by
   /// other tile interaction functions.&lt;/param&gt;
   /// &lt;returns&gt;The index of the next unprocessed tile in &lt;see cref="TouchedTiles"/&gt; if one
   /// exists with the specified &lt;paramref name="TileValue" /&gt;, or -1 if no such tile exists.
   /// &lt;/returns&gt;
   /// &lt;remarks&gt;While &lt;see cref="TileUseUp"/&gt; and &lt;see cref="TileTake"/&gt; provide simple
   /// access to common behaviors related to tile interactions, they aren't expected to cover
   /// all behaviors you might want to implement related to tile interactions.  This function
   /// provides a piece of functionality that will be useful in more detailed control over
   /// tile interactions.&lt;seealso cref="TouchTiles"/&gt;&lt;seealso cref="TileActivateSprite"/&gt;
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example demonstrates how you could activate the next inactive instance of
   /// a sprite in the "Points" category at the location of any tile whose tile number is 10
   /// when the sprite touches the tile, only when the sprite first touches the tile. Performing
   /// this in a while loop ensures that all such tiles that the sprite is initially touching get
   /// processed at once, which is important because it won't be initially touching them any more
   /// in the next frame. TempNum is any temporary numeric variable, such as a sprite parameter.
   /// &lt;code&gt;
   /// if (TouchTiles(TileCategoryName.Touchable))
   /// {
   ///    TempNum = TileTouchingIndex(10, true, true);
   ///    while(TempNum &gt; 0)
   ///    {
   ///       TileActivateSprite(TempNum, ParentLayer.m_SpriteCategories.Points, true);
   ///       TempNum = TileTouchingIndex(10, true, true);
   ///    }
   /// }
   /// &lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Return the index of the next unprocessed tile with the specified value from the list of tiles the sprite is touching. If InitialOnly is set, only return tiles that the sprite wasn't already touching. Return -1 if no tiles are being touched. (Must run TouchTiles first.)")]
   public int TileTouchingIndex(int TileValue, bool InitialOnly, bool MarkAsProcessed)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileTouchingIndex on an inactive sprite");

      if (TouchedTiles == null)
         return -1;

      for (int i=0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = (TouchedTile)TouchedTiles[i];
         if ((tt.tileValue == TileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!InitialOnly || tt.initial))
         {
            tt.processed = MarkAsProcessed;
            return i;
         }
      }
      
      return -1;
   }

   /// &lt;summary&gt;
   /// Activate the next inactive sprite from a category at the coordinates of a tile being touched by the sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="TouchingIndex"&gt;Index of the tile in the array of tiles to process (&lt;see cref="TouchedTiles"/&gt;).
   /// This can be acquired using &lt;see cref="TileTouchingIndex"/&gt;.&lt;/param&gt;
   /// &lt;param name="Category"&gt;Category containing sprites that can be activated.&lt;/param&gt;
   /// &lt;param name="ClearParameters"&gt;True if the newly activated sprite's parameters should
   /// all be set to zero.&lt;/param&gt;
   /// &lt;returns&gt;The index of the newly activated sprite, if a sprite was activated (this
   /// value will be greater than or equal to zero) or -1 if all sprites in the specified
   /// category are already activate.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function allows you to treat a number of sprites within a category
   /// as kind of a dynamic collection of sprites which can be activated one after the other.
   /// Each time this is called, it will find and activate the next inactive sprite within
   /// the category. This limits the number of sprites that can be activated by this function
   /// to the number of actual sprite instances in the specified category on the layer where
   /// the function is executed. For a truly dynamic collection of sprites, see
   /// &lt;see cref="TileAddSprite"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;Clearing the parameters of a newly activated sprite can be very useful in initializing
   /// the sprite as soon as it is activated because the activated sprite can check to see
   /// when a particular parameter is zero. If it sees that it's zero, it can immediately set
   /// it to some other value and perform whatever initialization it needs to (such as offsetting
   /// its position from the tile by some pre-set distance).&lt;/para&gt;&lt;/remarks&gt;
   [Description("Activate the next inactive sprite from a category at the coordinates of a tile being touched by the sprite.  Use TileTouchingIndex to acquire TouchingIndex.  Returns the index into the category of the sprite that was activated, or -1 if all sprites in the category were already active.")]
   public int TileActivateSprite(int TouchingIndex, SpriteCollection Category, bool ClearParameters)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileActivateSprite on an inactive sprite");

      for(int i=0; i&lt;Category.Count; i++)
      {
         if (!Category[i].isActive)
         {
            Category[i].isActive = true;
            TouchedTile tt = (TouchedTile)TouchedTiles[TouchingIndex];
            Category[i].x = tt.x * layer.Tileset.TileWidth;
            Category[i].y = tt.y * layer.Tileset.TileHeight;
            if (ClearParameters)
            {
               Category[i].frame = 0;
               Category[i].state = 0;
               Category[i].ClearParameters();
            }
            Category[i].ProcessRules();
            return i;
         }
      }
      return -1;
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite type at the coordinates
   /// of a tile being touched by the player.
   /// &lt;/summary&gt;
   /// &lt;param name="TouchingIndex"&gt;Refers to a tile in &lt;see cref="TouchedTiles"/&gt; by index.
   /// &lt;see cref="TileTouchingIndex"/&gt; can be used to acquire this value.&lt;/param&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite that will be created.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;As opposed to &lt;see cref="TileActivateSprite"/&gt;, which activates a pre-defined
   /// instance of a sprite, this function will actually create a new sprite instance on the
   /// fly (referred to as a "dynamic" sprite instance). Dynamic sprites cannot be referred
   /// to directly by other rules because they don't have names associated with them, therefore
   /// it's recommended that &lt;see cref="TileActivateSprite"/&gt; be used when more control is
   /// desired. However, for common sprites that may be created on any map, this is ideal
   /// because it doesn't require you to pre-define each possible instance.&lt;/para&gt;
   /// &lt;para&gt;Dynamic sprites are added to the end of each category that they belong to
   /// (categories are defined in terms of sprite definitions, so a dynamic sprite knows
   /// the categories in which it should participate). This happens as the sprite is created.
   /// When the sprite is deactivated, it will automatically be removed from all categories
   /// as part of &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;The maximum number of sprites that can be active on a layer at once is
   /// defined by &lt;see cref="SpriteCollection.maxCollectionSize"/&gt;. This includes static
   /// sprites as well as dynamic sprites. The purpose of this maximum is not a technical
   /// limitation (feel free to change the code in SpriteCollection.cs to increase the maximum
   /// all you like). It only exists to help developers realize when sprite instances are
   /// "leaking" (not being cleaned up or deactivated properly) or when more sprites than
   /// necessary are being created. In many cases, the engine can actually handle quite a
   /// bit more than 100 sprites without significant performance impact.&lt;/para&gt;
   /// &lt;para&gt;Because the sprite instances being created are not activations of already
   /// existing instances (as is the case with &lt;see cref="TileActivateSprite"/&gt;), there
   /// is no need for a parameter to reset all the sprite's parameters. All parameters of
   /// a newly created sprite instance are always initialized to zero.&lt;/para&gt;
   /// &lt;para&gt;New sprite instances will not refer to any solidity, and will begin in the first
   /// frame of the first state, but you can use rules to affect &lt;see cref="GeneralRules.lastCreatedSprite"/&gt;
   /// to set values of the new sprite, or define rules on the created sprite type to make it
   /// initialize itself appropriately.&lt;/para&gt;
   /// &lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="AddSpriteHere"/&gt;&lt;/remarks&gt;
   [Description("Create a new (dynamic) instance of the specified sprite type at the coordinates of a tile being touched by the player.  Use TileTouchingIndex to acquire TouchingIndex.")]
   public void TileAddSprite(int TouchingIndex, [Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileAddSprite on an inactive sprite");

      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });
      TouchedTile tt = (TouchedTile)TouchedTiles[TouchingIndex];
      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         layer, tt.x * layer.Tileset.TileWidth, tt.y * layer.Tileset.TileHeight, 0, 0, 0, 0, true, layer.ParentMap.Display, null, -1, true
      });
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite positioned such that HotSpot on the created sprite overlaps Location on this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite to create&lt;/param&gt;
   /// &lt;param name="Location"&gt;Specifies a point in the current sprite, relative to which the new
   /// sprite will be created.&lt;/param&gt;
   /// &lt;param name="HotSpot"&gt;Specifies a point within the created sprite that will be used to
   /// position the sprite (the location of the "handle" by which it is positioned).&lt;/param&gt;
   /// &lt;remarks&gt;See &lt;see cref="TileAddSprite"/&gt; for more information about dynamically added sprites.
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;seealso cref="PlanBase.AddSpriteAtPlan"/&gt;
   /// &lt;seealso cref="GeneralRules.lastCreatedSprite"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following code will create an instance of a sprite named "Bullet" such that the left side
   /// of the bullet matches up with the right side of the current sprite. (The bullet will be
   /// immediately to the right of this sprite, overlapping by 1 pixel.)
   /// &lt;code&gt;AddSpriteHere(typeof(Sprites.Bullet), RelativePosition.RightMiddle, RelativePosition.LeftMiddle);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Create a new (dynamic) instance of the specified sprite positioned such that HotSpot on the created sprite overlaps Location on this sprite.")]
   public void AddSpriteHere([Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition, RelativePosition Location, RelativePosition HotSpot)
   {
      Debug.Assert(this.isActive, "Attempted to execute AddSpriteHere on an inactive sprite");

      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });

      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         layer, 0, 0, 0, 0, 0, 0, true, layer.ParentMap.Display, null, -1, true
      });

      System.Drawing.Point ptLocation = GetRelativePosition(Location);
      System.Drawing.Point ptHotSpot = lastCreatedSprite.GetRelativePosition(HotSpot);
      lastCreatedSprite.x = ptLocation.X - ptHotSpot.X;
      lastCreatedSprite.y = ptLocation.Y - ptHotSpot.Y;
   }

   /// &lt;summary&gt;
   /// Change tiles of the specified type that the sprite is touching to another tile (requires &lt;see cref="TouchTiles"/&gt;).
   /// &lt;/summary&gt;
   /// &lt;param name="OldTileValue"&gt;Index of the tile type to search for&lt;/param&gt;
   /// &lt;param name="NewTileValue"&gt;Which tile should these tiles be changed to&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;If true, only affect tiles that the player just started touching.&lt;/param&gt;
   /// &lt;returns&gt;The number of tiles affected.&lt;/returns&gt;
   [Description("Change the specified tile that the sprite is touching to another tile. Return the number of tiles affected. (Must run TouchTiles first.)")]
   public int TileChange(int OldTileValue, int NewTileValue, bool InitialOnly)
   {
      Debug.Assert(this.isActive, "Attempted to execute TileChange on an inactive sprite");

      if (TouchedTiles == null)
         return 0;

      int result = 0;

      for (int i=0; i &lt; TouchedTiles.Count; i++)
      {
         TouchedTile tt = (TouchedTile)TouchedTiles[i];
         if ((tt.tileValue == OldTileValue) &amp;&amp; (!tt.processed) &amp;&amp; (!InitialOnly || tt.initial))
         {
            tt.processed = true;
            layer[tt.x, tt.y] = tt.tileValue = NewTileValue;
            result++;
         }
      }
      return result;
   }

   /// &lt;summary&gt;
   /// Calculate the absolute position of a specified &lt;see cref="RelativePosition"/&gt; value with respect to this sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="RelativePosition"&gt;Which position within this sprite should be retrieved.&lt;/param&gt;
   /// &lt;returns&gt;A point relative to the sprite's layer that represents the requested position in the sprite.&lt;/returns&gt;
   /// &lt;remarks&gt;This cannot be applied as a rule function because it returns a point object,
   /// which is not supported by the SGDK2 IDE as an output type.&lt;/remarks&gt;
   public System.Drawing.Point GetRelativePosition(RelativePosition RelativePosition)
   {
      System.Drawing.Point rp = new System.Drawing.Point(PixelX, PixelY);

      switch (RelativePosition)
      {
         case RelativePosition.TopCenter:
            rp.X = (int)(PixelX + SolidWidth / 2);
            break;
         case RelativePosition.TopRight:
            rp.X = PixelX + SolidWidth - 1;
            break;
         case RelativePosition.LeftMiddle:
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.CenterMiddle:
            rp.X = PixelX + (int)(SolidWidth / 2);
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.RightMiddle:
            rp.X = PixelX + SolidWidth - 1;
            rp.Y = PixelY + (int)(SolidHeight / 2);
            break;
         case RelativePosition.BottomLeft:
            rp.Y = PixelY + SolidHeight -1;
            break;
         case RelativePosition.BottomCenter:
            rp.X = PixelX + (int)(SolidWidth / 2);
            rp.Y = PixelY + SolidHeight - 1;
            break;
         case RelativePosition.BottomRight:
            rp.X = PixelX + SolidWidth - 1;
            rp.Y = PixelY + SolidHeight - 1;
            break;
      }
      return rp;
   }

   /// &lt;summary&gt;
   /// Determines if a tile at the sprite's current position is a member of the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Tile category against which the tile will be checked.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;The sprite may be on multiple tiles at once. This parameter
   /// indicates which part of the sprite to look at, and gets the tile from the layer at
   /// the specified position.&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point in the sprite is on a tile in the specified category, false otherwise.&lt;/returns&gt;
   [Description("Examines the tile on the layer at the sprite's current position and determines if it is a member of the specified category. The RelativePosition parameter determines which part of the sprite to use when identifying a location on the layer. (TouchTiles is not necessary for this function.)")]
   public bool IsOnTile(TileCategoryName Category, RelativePosition RelativePosition)
   {
      Debug.Assert(this.isActive, "Attempted to execute IsOnTile on an inactive sprite");

      System.Drawing.Point rp = GetRelativePosition(RelativePosition);
      return layer.GetTile((int)(rp.X / layer.Tileset.TileWidth), (int)(rp.Y / layer.Tileset.TileHeight)).IsMember(Category);
   }
   #endregion

   #region Activation
   /// &lt;summary&gt;
   /// Deactivate this sprite.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Deactivated sprites are no longer be drawn and their rules are not processed.
   /// In debug mode, attempting to refer to inactive sprites from active rules (or otherwise
   /// attempting to execute functions on inactive sprites) will display errors. If the
   /// sprite was added as a dynamic sprite by &lt;see cref="TileAddSprite"/&gt;, deactivating it
   /// will cause &lt;see cref="LayerBase.ProcessSprites"/&gt; to remove the sprite from all
   /// categories so it cannot even be considered for re-activation.
   /// &lt;seealso cref="TileAddSprite"/&gt;&lt;seealso cref="TileActivateSprite"/&gt;&lt;/remarks&gt;
   [Description("Deactivate this sprite.  It will no longer be drawn, and in debug mode, will display errors if rules try to execute on it.")]
   public void Deactivate()
   {
      isActive = false;
   }
   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="PlanBase.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using System.ComponentModel;
using System.Drawing;
using Microsoft.DirectX;

/// &lt;summary&gt;
/// Base class for "plans", which consist of map coordinates and rules
/// &lt;/summary&gt;
[Serializable()]
public abstract class PlanBase : GeneralRules, System.Collections.IEnumerable
{
   /// &lt;summary&gt;
   /// This is provided as a temporary storage area for numbers while processing
   /// plan rules.
   /// &lt;/summary&gt;
   public static int SharedTemp1;

   /// &lt;summary&gt;
   /// This value is used by &lt;see cref="CheckNextCoordinate"/&gt; to determine how close a
   /// sprite must be to a coordinate before heading to the next coordinate.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The default value for this property is 5 pixels.&lt;/remarks&gt;
   [Description("How close must a sprite be to a coordinate in this plan before heading to the next (default=5)")]
   public int TargetDistance = 5;

   protected PlanBase()
   {
   }

   /// &lt;summary&gt;
   /// Stores information about a coordinate within a &lt;see cref="PlanBase"/&gt;.
   /// &lt;/summary&gt;
   [Serializable()]
   public struct Coordinate
   {
      /// &lt;summary&gt;
      /// The horizontal aspect of this coordinate
      /// &lt;/summary&gt;
      public int x;
      /// &lt;summary&gt;
      /// The vercial aspect of this coordinate 
      /// &lt;/summary&gt;
      public int y;
      /// &lt;summary&gt;
      /// Can be used to store any additional piece of information about this coordinate,
      /// but &lt;see cref="PlanBase.CheckNextCoordinate"/&gt; will use it to define a wait period
      /// for a sprite arriving at this coordinate before proceeding to the next.
      /// &lt;/summary&gt;
      public int weight;
      /// &lt;summary&gt;
      /// Creates a new coordinate given all its properties
      /// &lt;/summary&gt;
      /// &lt;param name="x"&gt;Provides the &lt;see cref="x"/&gt; value for this coordinate&lt;/param&gt;
      /// &lt;param name="y"&gt;Provides the &lt;see cref="y"/&gt; value for this coordinate&lt;/param&gt;
      /// &lt;param name="weight"&gt;Provides the &lt;see cref="weight"/&gt; calue for this coordinate&lt;/param&gt;
      public Coordinate(int x, int y, int weight)
      {
         this.x = x;
         this.y = y;
         this.weight = weight;
      }
      /// &lt;summary&gt;
      /// Allows a path coordinate to be automatically used as a Point
      /// &lt;/summary&gt;
      public static implicit operator Point(Coordinate value)
      {
         return new Point(value.x, value.y);
      }
   }

   /// &lt;summary&gt;
   /// Returns the rectangle defined by a plan
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Plans with 2 points define a rectanglular area that can be used
   /// for a variety of purposes. This property will return the plan defined by
   /// the plan's two points for such plans.  It will return an empty regtangle
   /// if the plan does not have exactly 2 points.&lt;/remarks&gt;
   public virtual Rectangle PlanRectangle
   {
      get
      {
         return Rectangle.Empty;
      }
   }


   #region Sprites
   /// &lt;summary&gt;
   /// Make the specified sprite active.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite instance to activate&lt;/param&gt;
   /// &lt;remarks&gt;If the specified sprite instance is already active, this has
   /// no effect.&lt;/remarks&gt;
   [Description("Make the specified sprite active.")]
   public void ActivateSprite(SpriteBase Target)
   {
      Target.isActive = true;
   }

   /// &lt;summary&gt;
   /// Make the specified sprite inactive.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite instance to deactivate&lt;/param&gt;
   /// &lt;remarks&gt;If the specified sprite instance is already inactive, this
   /// has no effect.&lt;/remarks&gt;
   [Description("Make the specified sprite inactive.")]
   public void DeactivateSprite(SpriteBase Target)
   {
      Target.isActive = false;
   }

   /// &lt;summary&gt;
   /// Set the position of the target sprite to match that of the source sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies the sprite whose position will change.&lt;/param&gt;
   /// &lt;param name="Source"&gt;Specifies the sprite whose position is copied.&lt;/param&gt;
   /// &lt;remarks&gt;This very simply copies the position from the source sprite to that
   /// of the target sprite. No tests are performed for solidity and no velocity is
   /// changed. The old position of the target sprite, however, is tracked, so it's
   /// still possible to determine if the sprite was touching a tile or plan before
   /// it moved with a function like &lt;see cref="WasSpriteTouching"/&gt;.
   /// &lt;seealso cref="TransportToPoint"/&gt;
   /// &lt;seealso cref="TransportToPlan"/&gt;&lt;/remarks&gt;
   [Description("Set the position of the target sprite to match that of the source sprite.")]
   public void MatchSpritePosition(SpriteBase Target, SpriteBase Source)
   {
      Target.oldX = Target.x;
      Target.oldY = Target.y;
      Target.x = Source.x;
      Target.y = Source.y;
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite is touching this plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite's solidity rectangle is touching this plan's rectangle,
   /// otherwise false.&lt;/returns&gt;
   /// &lt;remarks&gt;"Touching" means one rectangle is overlapping the other, or the borders
   /// are immediately adjacent. The rectangles are not considered touching if the corners
   /// are only diagonally adjacent (kitty-corner). There must be some length of adjecent
   /// edge. This ensures that a plan that is blocked off by two diagonally-arranged
   /// solid blocks can't be touched (and thus potentially "activated") through the crack.
   /// &lt;/remarks&gt;
   [Description("Returns true if the specified sprite is touching this plan's rectangle")]
   public bool IsSpriteTouching(SpriteBase sprite)
   {
      if (!sprite.isActive)
         return false;

      Rectangle spriteRect = new Rectangle(sprite.PixelX, sprite.PixelY, sprite.SolidWidth, sprite.SolidHeight);
      Rectangle targetRect = PlanRectangle;
      if (!spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,2)))
         return false;
      if (spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,0)) ||
         spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,0,2)))
         return true;
      else
         return false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified part of the specified sprite is within the plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite whose position will be tested&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies a point within the sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the specified point within the specified sprite's solidity rectangle is
   /// within the plan's rectangle.&lt;/returns&gt;
   /// &lt;remarks&gt;Unlike &lt;see cref="IsSpriteTouching"/&gt;, this can only return true when the sprite
   /// and the plan's rectangle actually overlap because the point is inside the sprite's
   /// rectangle, and must also be inside the plan's rectangle to return true.&lt;/remarks&gt;
   [Description("Returns true if the specified part of the specified sprite is within the plan's rectangle")]
   public bool IsSpriteWithin(SpriteBase sprite, RelativePosition RelativePosition)
   {
      System.Drawing.Point rp = sprite.GetRelativePosition(RelativePosition);
      Rectangle targetRect = PlanRectangle;
      return targetRect.Contains(rp);
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite was touching this plan's rectangle in the previous frame.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite to test&lt;/param&gt;
   /// &lt;returns&gt;True if the specified sprite was touching this plan's rectangle previously, or false
   /// if it wasn't.&lt;/returns&gt;
   /// &lt;remarks&gt;This function is identical to &lt;see cref="IsSpriteTouching"/&gt; except that it operates
   /// on the sprite's previous position instead of its current position. This is useful for
   /// determining if the sprite just started touching a plan's rectangle or was already touching
   /// it. Often times it's desirable to perform an automated action like a message only
   /// when a sprite initially touches a plan's rectangle. It's not as desirable for plan rules
   /// that also require other conditions to activate.
   /// Consider, for example, a plan that displays
   /// a message when the sprite touches it. This plan can automatically display the message only
   /// when the sprite first touches the plan, and everything will be fine. But what happens if
   /// it's also required that a button be pressed to activate the rule?  The player may start
   /// touching the plan without touching the button.  Then when the player presses the button,
   /// the rule won't activate because this is no longer the frame when the sprite initially
   /// started touching the plan, so the plan may never get activated.
   /// &lt;/remarks&gt;
   [Description("Returns true if the specified sprite was touching this plan's rectangle in the previous frame")]
   public bool WasSpriteTouching(SpriteBase sprite)
   {
      Rectangle spriteRect = new Rectangle(sprite.OldPixelX, sprite.OldPixelY, sprite.SolidWidth, sprite.SolidHeight);
      Rectangle targetRect = PlanRectangle;
      if (!spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,2)))
         return false;
      if (spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,2,0)) ||
         spriteRect.IntersectsWith(Rectangle.Inflate(targetRect,0,2)))
         return true;
      else
         return false;
   }


   /// &lt;summary&gt;
   /// Scroll all layers on this plan's layer's map so that the specified sprite is within the visible area of the map.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Specified which sprite will be scrolled into view.&lt;/param&gt;
   /// &lt;param name="UseScrollMargins"&gt;If true, the layer will scroll the sprite into the scroll margins
   /// of the map, otherwise it will only be scrolled just far enough for the sprite to be fully visible
   /// on the display.&lt;/param&gt;
   /// &lt;remarks&gt;For multi-player games, it may be desirable to set UseScrollMargins to false
   /// to allow at least one player to get closer to the edge of the screen without trying to
   /// keep it scrolled so strictly within the scroll margin area.
   /// &lt;seealso cref="PushSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Scroll all layers on this plan's layer's map so that the specified sprite is within the visible area of the map.  If UseScrollMargins is true, the layer will scroll the sprite into the scroll margins of the map.")]
   public void ScrollSpriteIntoView(SpriteBase Sprite, bool UseScrollMargins)
   {
      ParentLayer.ScrollSpriteIntoView(Sprite, UseScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter a sprite's velocity so that it remains within the map's visible area.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that should be pushed&lt;/param&gt;
   /// &lt;param name="StayInScrollMargins"&gt;True to push the sprite until it is within the scroll
   /// margins of the map or false to push it only until it is fully visible.&lt;/param&gt;
   /// &lt;remarks&gt;This can be useful in multi-player games to not only ensure that the view
   /// remains focused on a particular sprite, but also to ensure that another sprite
   /// (another player) can't leave the view (in cases where both players are shown in
   /// the same view). &lt;seealso cref="ScrollSpriteIntoView"/&gt;&lt;/remarks&gt;
   [Description("Alter a sprite's velocity so that it remains within the map's visible area or within the scroll margins.")]
   public void PushSpriteIntoView(SpriteBase Sprite, bool StayInScrollMargins)
   {
      ParentLayer.PushSpriteIntoView(Sprite, StayInScrollMargins);
   }

   /// &lt;summary&gt;
   /// Alter the velocity of the specified sprite to go toward a coordinate associated with the current plan.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose velocity will be affected&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;Indicates the 0-based index of the coordinate in the current plan toward which the sprite will be pushed&lt;/param&gt;
   /// &lt;param name="Force"&gt;How hard to push the sprite in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;remarks&gt;Use this in combination with &lt;see cref="CheckNextCoordinate"/&gt; to make a
   /// sprite follow a series of coordinates in a path. This function is identical to
   /// &lt;see cref="PushSpriteTowardPoint"/&gt; except that it is designed only to operate on
   /// coordinates within the current plan (designated by coordinate index).&lt;/remarks&gt;
   /// &lt;example&gt;
   /// See &lt;see cref="StopSprite"/&gt; for an example.
   /// &lt;/example&gt;
   [Description("Alter the velocity of the specified sprite to go toward a coordinate associated with the current plan.  CoordinateIndex indicates which coordinate in the plan to head toward, and Force is how hard to push the sprite in tenths of a pixel per frame per frame")]
   public void PushSpriteTowardCoordinate(SpriteBase Sprite, int CoordinateIndex, int Force)
   {
      PushSpriteTowardPoint(Sprite, this[CoordinateIndex], Force);
   }

   /// &lt;summary&gt;
   /// Alter the velocity of the specified sprite to go toward a specified location.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;The sprite whose velocity will be affected&lt;/param&gt;
   /// &lt;param name="Target"&gt;Specifies a point toward which the sprite will be pushed&lt;/param&gt;
   /// &lt;param name="Force"&gt;How hard to push the sprite in tenths of a pixel per frame per frame&lt;/param&gt;
   /// &lt;remarks&gt;This function is a more generalized form of &lt;see cref="PushSpriteTowardCoordinate"/&gt;.
   /// Rather than pushing a sprite toward a coordinate in the current plan, it can push it toward
   /// any location that can be represented as a point.&lt;/remarks&gt;
   /// &lt;example&gt;
   /// This example pushes the sprite toward the mouse location.
   /// &lt;code&gt;PushSpriteTowardPoint(m_ParentLayer.m_Plasma_1, ParentLayer.GetMousePosition(), 40);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Alter the velocity of the specified sprite to go toward a specified location.  Force is how hard to push the sprite in tenths of a pixel per frame per frame")]
   public void PushSpriteTowardPoint(SpriteBase Sprite, Point Target, int Force)
   {
      double dx = Target.X - Sprite.PixelX;
      double dy = Target.Y - Sprite.PixelY;

      // Normalize target vector to magnitude of Force parameter
      double dist = Math.Sqrt(dx * dx + dy * dy);
      if (dist &gt; 0)
      {
         dx = dx * Force / dist / 10;
         dy = dy * Force / dist / 10;

         // Push sprite
         Sprite.dx += dx;
         Sprite.dy += dy;
      }
   }

   /// &lt;summary&gt;
   /// Make a sprite move toward the next coordinate in the plan when appropriate.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that is following coordinates in this plan&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;Zero-based index of the coordinate within the plan toward which the sprite is currently heading.&lt;/param&gt;
   /// &lt;param name="WaitCounter"&gt;A variable that is used to count frames while this sprite is waiting at a coordinate for a time period specified by the coordinate's &lt;see cref="Coordinate.weight"/&gt; to elapse.&lt;/param&gt;
   /// &lt;returns&gt;The index of the coordinate toward which the sprite should be heading.&lt;/returns&gt;
   /// &lt;remarks&gt;&lt;para&gt;This function determines if the sprite should head toward the next coordinate by
   /// checking if the sprite is within this plan's &lt;see cref="TargetDistance"/&gt; of the specified
   /// coordinate. If it is, then it checks the coordinate's &lt;see cref="Coordinate.weight"/&gt;,
   /// to see if the sprite is supposed to wait at this coordinate.  If it's not supposed to wait,
   /// the function returns the next coordinate index right away. If it is supposed to wait,
   /// the function will only return the next coordinate index if the sprite has waited the
   /// specified number of frames at the current coordinate.&lt;/para&gt;
   /// &lt;para&gt;Normally two sprite parameters are used in conjunction with a sprite that follows
   /// a series of coordinates in a plan, and they are both passed into this function. One
   /// parameter tracks the index of the coordinate toward which the the sprite is currently
   /// heading. The other tracks how long the sprite has waited at the current coordinate.
   /// The coordinate parameter is passed in as the the input for &lt;paramref name="CoordinateIndex"/&gt;
   /// and also specified to receive the output of the function. The wait counter is passed for
   /// the last parameter and is automatically updated when needed because it is passed by reference.
   /// &lt;/para&gt;&lt;seealso cref="PushSpriteTowardCoordinate"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// This example demonstrates the common usage of this function on a sprite named "Plasma 1".
   /// &lt;code&gt;m_ParentLayer.m_Plasma_1.CoordIndex = CheckNextCoordinate(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, ref m_ParentLayer.m_Plasma_1.WaitCounter);&lt;/code&gt;
   /// For a more complete example, see &lt;see cref="StopSprite"/&gt;.
   /// &lt;/example&gt;
   [Description("Determine whether the sprite is within the TargetDistance of the specified coordinate, and has waited for the number of frames determined by the coordinate's weight based on the specified WaitCounter after reaching it.  If so, return the next CoordinateIndex, otherwise return the current CoordinateIndex.")]
   public int CheckNextCoordinate(SpriteBase Sprite, int CoordinateIndex, ref int WaitCounter)
   {
      if (WaitCounter &gt; 0)
      {
         if (++WaitCounter &gt; this[CoordinateIndex].weight)
         {
            WaitCounter = 0;
            return (CoordinateIndex + 1) % Count;
         }
         else
            return CoordinateIndex;
      }
      int dx = this[CoordinateIndex].x - Sprite.PixelX;
      int dy = this[CoordinateIndex].y - Sprite.PixelY;
      if (Math.Sqrt(dx * dx + dy * dy) &lt; TargetDistance)
      {
         if (this[CoordinateIndex].weight &gt; 0)
            WaitCounter++;
         else
            return (CoordinateIndex + 1) % Count;
      }
      return CoordinateIndex;
   }

   /// &lt;summary&gt;
   /// Cause the specified sprite to follow the coordinates in this plan as a path.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite that will follow this plan's path.&lt;/param&gt;
   /// &lt;param name="CoordinateIndex"&gt;0-based index of the coordinate in this plan toward which the sprite is currently heading.  This is usually a parameter of the sprite.&lt;/param&gt;
   /// &lt;param name="WaitCounter"&gt;Counter that tracks how long a sprite has waited at a particular coordinage. This is usualyl a parameter of the sprite.&lt;/param&gt;
   /// &lt;remarks&gt;This function combines a number of other path-following rule functions into a single
   /// simple function that you can use to make a sprite follow a path with just a single rule.
   /// The following rule functions are combined within this function:
   /// &lt;see cref="IsSpriteActive"/&gt;,
   /// &lt;see cref="PushSpriteTowardCoordinate"/&gt;,
   /// &lt;see cref="StopSprite"/&gt;
   /// &lt;see cref="CheckNextCoordinate"/&gt;,
   /// &lt;note type="caution"&gt;When using this function to follow a path, the sprite definition
   /// itself is responsible for limiting the speed (see &lt;see cref="SpriteBase.LimitVelocity"/&gt;) and
   /// performing the actual movement (see &lt;see cref="SpriteBase.MoveByVelocity"/&gt;).&lt;/note&gt;
   /// &lt;/remarks&gt;
   [Description("Cause the specified sprite to follow the coordinates in this plan as a path, provided some parameters where the current point index and wait counter can be stored.")]
   public void FollowPath(SpriteBase Sprite, ref int CoordinateIndex, ref int WaitCounter)
   {
      if (Sprite.isActive)
      {
         if (WaitCounter == 0)
            PushSpriteTowardCoordinate(Sprite, CoordinateIndex, 10);
         else
            StopSprite(Sprite);
         CoordinateIndex = CheckNextCoordinate(Sprite, CoordinateIndex, ref WaitCounter);
      }
   }

   /// &lt;summary&gt;
   /// Stops the sprite's current motion
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite to be stopped&lt;/param&gt;
   /// &lt;remarks&gt;This stops the current sprite from moving by setting its
   /// &lt;see cref="SpriteBase.dx"/&gt; and &lt;see cref="SpriteBase.dy"/&gt; values
   /// to zero. This may be desired when a sprite reaches a coordinate in
   /// a path where it's supposed to wait, otherwise the sprite may continue
   /// to drift while it waits. One easy way to determine when a sprite is
   /// waiting at a coordinate is to check if the sprite's wait counter parameter
   /// is zero. The wait counter will only be non-zero when the sprite is waiting.
   /// &lt;seealso cref="CheckNextCoordinate"/&gt;
   /// &lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example shows the code used for a sprite named "Plasma 1" that
   /// follows a path and stops and waits at coordinates that have a non-zero weight.
   /// &lt;code lang="C#"&gt;
   /// // If active
   /// if (&lt;see cref="IsSpriteActive"/&gt;(m_ParentLayer.m_Plasma_1))
   /// {
   ///    // If not waiting
   ///    if ((m_ParentLayer.m_Plasma_1.WaitCounter == 0))
   ///    {
   ///       // Move sprite towards coordinate
   ///       &lt;see cref="PushSpriteTowardCoordinate"/&gt;(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, 40);
   ///    }
   ///    else
   ///    {
   ///       // Else stop sprite
   ///       &lt;see cref="StopSprite"/&gt;(m_ParentLayer.m_Plasma_1);
   ///    }
   ///    // Move to next coordinate
   ///   m_ParentLayer.m_Plasma_1.CoordIndex = &lt;see cref="CheckNextCoordinate"/&gt;(m_ParentLayer.m_Plasma_1, m_ParentLayer.m_Plasma_1.CoordIndex, ref m_ParentLayer.m_Plasma_1.WaitCounter);
   /// }
   /// &lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Set the velocity of the specified sprite to zero")]
   public void StopSprite(SpriteBase Sprite)
   {
      Sprite.dx = Sprite.dy = 0;
   }

   /// &lt;summary&gt;
   /// Determines whether the specified sprite's collision mask is overlapping part of any
   /// sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="SourceSprite"&gt;A sprite that will be checked for collisions&lt;/param&gt;
   /// &lt;param name="Targets"&gt;A category of sprites against which collisions will be tested&lt;/param&gt;
   /// &lt;returns&gt;The 0-based index of the sprite within &lt;paramref name="Targets"/&gt; if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;The collision mask is derived from the sprite's Mask Alpha Level setting.
   /// If both sprites being tested have a collision mask, they are checked for overlapping solid bits.
   /// If one sprite has Mask Alpha Level set to 0, then a rectangular mask for that sprite
   /// is synthesized from the solid width and solid height using
   /// &lt;see cref="CollisionMask.GetRectangularMask"/&gt;.
   /// If both sprites have Mask Alpha Level set to 0, then a simple rectangular collision
   /// detection is performed (for improved performance).&lt;/remarks&gt;
   [Description("Determine whether the specified sprite's collision mask is overlapping part of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public int TestCollisionMask(SpriteBase SourceSprite, SpriteCollection Targets)
   {
      return SourceSprite.TestCollisionMask(Targets);
   }

   /// &lt;summary&gt;
   /// Determines whether the solidity rectangle of the specified sprite overlaps that
   /// of any sprite in the specified category.
   /// &lt;/summary&gt;
   /// &lt;param name="SourceSprite"&gt;A sprite that will be checked for collisions&lt;/param&gt;
   /// &lt;param name="Targets"&gt;A category of sprites against which collisions will be tested&lt;/param&gt;
   /// &lt;returns&gt;The 0-based index of the sprite within &lt;paramref name="Targets"/&gt; if a collision is occurring, otherwise -1.&lt;/returns&gt;
   /// &lt;remarks&gt;This can be used to force a simple rectangular collision test even if one or both
   /// sprites involved have a Mask Alpha level greater than 0.  This method is recommended
   /// for improved performance when pixel-perfect collision detection is not required.
   /// &lt;seealso cref="TestCollisionMask"/&gt;&lt;/remarks&gt;
   [Description("Determine whether the solidity rectangle of the specified sprite overlaps that of any sprite in the specified category. Return the index of the sprite within the category if a collision is occurring, otherwise return -1.")]
   public int TestCollisionRect(SpriteBase SourceSprite, SpriteCollection Targets)
   {
      return SourceSprite.TestCollisionRect(Targets);
   }

   /// &lt;summary&gt;
   /// Deactivate a sprite within a category given the sprite's index within the category.
   /// &lt;/summary&gt;
   /// &lt;param name="Category"&gt;Category containing the sprite to deactivate&lt;/param&gt;
   /// &lt;param name="Index"&gt;Zero-based index within the category of the sprite to be deactivated&lt;/param&gt;
   /// &lt;remarks&gt;This can be used in conjunction with the result of a function like
   /// &lt;see cref="TestCollisionRect"/&gt; or &lt;see cref="TestCollisionMask"/&gt; to deactivate the
   /// target sprite when a collision occurs.
   /// &lt;seealso cref="DeactivateSprite"/&gt;&lt;/remarks&gt;
   [Description("Deactivate a sprite within a category given the sprite's index within the category")]
   public void DeactivateCategorySprite(SpriteCollection Category, int Index)
   {
      Category[Index].isActive = false;
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite instace is active.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite instance to test&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is active, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The main differences between an active sprite and an inactive
   /// sprite are than only active sprites are drawn when they are in the visible
   /// part of the map, and only active sprites' rules are processed. Using
   /// IsSpriteActive is a good way to determine if a sprite is currently valid
   /// for use because inactive sprites should not have any functions running on
   /// them except to activate them. Most functions will trigger an error message
   /// in debug mode if they find that they are operating on an inactive sprite.
   /// &lt;/remarks&gt;
   /// &lt;example&gt;See &lt;see cref="StopSprite"/&gt; for an example of
   /// IsSpriteActive.&lt;/example&gt;
   [Description("Determines if the specified sprite instace is active.")]
   public bool IsSpriteActive(SpriteBase Sprite)
   {
      return Sprite.isActive;
   }

   /// &lt;summary&gt;
   /// Moves the specified sprite to the specified coordinate.
   /// &lt;/summary&gt;
   /// &lt;param name="sprite"&gt;Sprite instance to be moved&lt;/param&gt;
   /// &lt;param name="target"&gt;Location to which the sprite will be moved&lt;/param&gt;
   /// &lt;remarks&gt;This very simply sets the position of the sprite to a specified
   /// coordinate. No tests are performed for solidity and no velocity is
   /// changed. The old position of the target sprite, however, is tracked, so it's
   /// still possible to determine if the sprite was touching a tile or plan before
   /// it moved with a function like &lt;see cref="WasSpriteTouching"/&gt;.
   /// &lt;seealso cref="MatchSpritePosition"/&gt;
   /// &lt;seealso cref="TransportToPlan"/&gt;&lt;/remarks&gt;
   /// &lt;example&gt;
   /// The following example could be used to move a sprite to the mouse's location
   /// to make it behave like a mouse cursor.
   /// &lt;code&gt;TransportToPoint(m_ParentLayer.m_Plasma_1, ParentLayer.GetMousePosition());&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Moves the specified sprite to the specified coordinate.")]
   public void TransportToPoint(SpriteBase sprite, Point target)
   {
      sprite.oldX = sprite.x;
      sprite.oldY = sprite.y;
      sprite.x = target.X;
      sprite.y = target.Y;
   }

   /// &lt;summary&gt;
   /// Moves the specified sprite to the specified plan's rectangle, aligned to the specified corner/edge.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite to be moved&lt;/param&gt;
   /// &lt;param name="Plan"&gt;Specifies a target location&lt;/param&gt;
   /// &lt;param name="Alignment"&gt;Specifies how the sprite's solidity rectangle will be aligned with the target plan's rectangle&lt;/param&gt;
   /// &lt;remarks&gt;The specified &lt;paramref name="Plan"/&gt; must be a 2-point plan (specifying a rectangle)
   /// or the function will ignore the request (and display an error in debug mode).
   /// The sprite will be aligned inside the rectangle according to &lt;paramref name="Alignment"/&gt;,
   /// so, for example, if RelativePosition.RightMiddle is specified, the midpoint of the
   /// right side of the sprite's solidity rectangle will be aligned to the midpoint of the
   /// right side of the plan's rectangle.&lt;/remarks&gt;
   [Description("Moves the specified sprite to the specified plan's rectangle, aligned to the specified corner/edge.")]
   public void TransportToPlan(SpriteBase Sprite, PlanBase Plan, RelativePosition Alignment)
   {
      System.Diagnostics.Debug.Assert(!Plan.PlanRectangle.IsEmpty, "TransportToPlan was called on a plan that does not have a rectangle defined.");
      if (Plan.PlanRectangle.IsEmpty)
         return;
      switch(Alignment)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.TopCenter:
         case RelativePosition.TopRight:
            Sprite.y = Plan.PlanRectangle.Y;
            break;
         case RelativePosition.LeftMiddle:
         case RelativePosition.CenterMiddle:
         case RelativePosition.RightMiddle:
            Sprite.y = Plan.PlanRectangle.Y + (int)((Plan.PlanRectangle.Height - Sprite.SolidHeight)/2);
            break;
         default:
            Sprite.y = Plan.PlanRectangle.Y + Plan.PlanRectangle.Height - Sprite.SolidHeight;
            break;
      }
      switch(Alignment)
      {
         case RelativePosition.TopLeft:
         case RelativePosition.LeftMiddle:
         case RelativePosition.BottomLeft:
            Sprite.x = Plan.PlanRectangle.X;
            break;
         case RelativePosition.TopCenter:
         case RelativePosition.CenterMiddle:
         case RelativePosition.BottomCenter:
            Sprite.x = Plan.PlanRectangle.X + (int)((Plan.PlanRectangle.Width - Sprite.SolidWidth)/2);
            break;
         default:
            Sprite.x = Plan.PlanRectangle.X + Plan.PlanRectangle.Width - Sprite.SolidWidth;
            break;
      }
   }
   
   /// &lt;summary&gt;
   /// Associate the state of the input device for the specified player with the inputs on the specified sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="PlayerNumber"&gt;A number from 1 to &lt;see cref="Project.MaxPlayers"/&gt; indicating which
   /// player's input settings to use.&lt;/param&gt;
   /// &lt;param name="Target"&gt;Specifies which sprite the player should control&lt;/param&gt;
   /// &lt;remarks&gt;This is the basic means by which the input device, as customized for a
   /// particular player, is associated with a sprite, so that the input will control
   /// the sprite for that player. In many cases, it may be easier to use the sprite
   /// definition's version of &lt;see cref="SpriteBase.MapPlayerToInputs"/&gt; so that this
   /// doesn't have to be repeated on every map, however in a multi-player game, it may be
   /// easier or necessary to distinguish the individual players on each map if each player
   /// uses the same sprite definition.&lt;/remarks&gt;
   [Description("Associate the state of the input device for the specified player (1-4) with the inputs on the specified sprite.")]
   public void MapPlayerToInputs(int PlayerNumber, SpriteBase Target)
   {
      Target.MapPlayerToInputs(PlayerNumber);
   }

   #endregion

   /// &lt;summary&gt;
   /// Retrieves a list of coordinates contained in this plan
   /// &lt;/summary&gt;
   protected virtual Coordinate[] Coordinates
   {
      get
      {
         return null;
      }
   }

   /// &lt;summary&gt;
   /// Retrieves the coordinate specified by a 0-based index for this plan
   /// &lt;/summary&gt;
   /// &lt;example&gt;
   /// The following code shows how you might limit the value of a coordinate so that
   /// it doesn't exceed the value of the weight assigned to the first coordinate in
   /// a plan. This indexer property ("this[]") is used to access the coordinates.
   ///&lt;code&gt;if (Counter.AnimationCounter.CurrentValue &gt; this[0].weight)
   ///   Counter.AnimationCounter.CurrentValue = this[0].weight;&lt;/code&gt;
   ///&lt;/example&gt;
   public Coordinate this[int index]
   {
      get
      {
         return Coordinates[index];
      }
   }

   /// &lt;summary&gt;
   /// Retrieves the number of coordinates that this plan contains
   /// &lt;/summary&gt;
   public int Count
   {
      get
      {
         if (Coordinates == null)
            return 0;
         return Coordinates.Length;
      }
   }

   /// &lt;summary&gt;
   /// Executes this plan's rules if any exist.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;An error is raised if no rules exist on this plan.&lt;/remarks&gt;
   public virtual void ExecuteRules()
   {
      throw new NotImplementedException("Attempted to execute rules on plan " + this.GetType().Name + " without any rules");
   }

   /// &lt;summary&gt;
   /// Specifies one of the 4 color channels: alpha, red, green or blue.
   /// &lt;/summary&gt;
   public enum ColorChannel
   {
      Blue,
      Green,
      Red,
      Alpha
   }

   /// &lt;summary&gt;
   /// Modulate/scale the specified color channel of the specified sprite to the specified level.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose appearance will be altered/restored&lt;/param&gt;
   /// &lt;param name="Channel"&gt;Which color channel will be affected&lt;/param&gt;
   /// &lt;param name="Level"&gt;Specifies the level to which the channel will be modulated&lt;/param&gt;
   /// &lt;remarks&gt;Modulating a color channel means that its output will be scaled down to the
   /// specified level&lt;/remarks&gt;
   /// &lt;example&gt;The following example scales the blue channel to 128 (half) which will cause the
   /// sprite to appear more yellow, green or red than normal:
   /// &lt;code&gt;ModulateColor(m_ParentLayer.m_Player_1, ColorChannel.Blue, 128);&lt;/code&gt;
   /// The following example scales the alpha channel to 128 (half) which will cause the
   /// sprite to appear semi-transparent:
   /// &lt;code&gt;ModulateColor(m_ParentLayer.m_Player_1, ColorChannel.Alpha, 128);&lt;/code&gt;
   /// &lt;/example&gt;
   [Description("Modulate/scale the specified color channel of the specified sprite to the specified level (0-255)")]
   public void ModulateColor(SpriteBase Sprite, ColorChannel Channel, int Level)
   {
      switch(Channel)
      {
         case ColorChannel.Blue:
            Sprite.ModulateBlue = Level;
            break;
         case ColorChannel.Green:
            Sprite.ModulateGreen = Level;
            break;
         case ColorChannel.Red:
            Sprite.ModulateRed = Level;
            break;
         case ColorChannel.Alpha:
            Sprite.ModulateAlpha = Level;
            break;
      }
   }

   
   #region Inventory / Overlay
   /// &lt;summary&gt;
   /// Specifies a drawing style for inventory/status-type bars drawn with &lt;see cref="DrawCounterAsTile"/&gt;.
   /// &lt;/summary&gt;
   public enum DrawStyle
   {
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched to fill the width of plan, and the right side
      /// is cropped according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches the maximum, the full tile is drawn, otherwise
      /// the clipping size is scaled according to the ratio of the counter's current value to
      /// its maximum value. The tile image is only stretched horizontally. The vertical size
      /// remains at the tile's original height.&lt;/remarks&gt;
      ClipRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched rightward according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will fill the plan rectangle's width.
      /// Otherwise the image is scaled down horizontally to fill the left portion of the plan
      /// rectangle as determined by the ratio of the counter's current value to its
      /// maximum value.&lt;/remarks&gt;
      StretchRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is draw unscaled from left to right, repeated according
      /// to the counter value and plan size.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will be repeated from the
      /// plan's left side to its right side, as many whole copies as can fit in the plan
      /// rectangle.  Otherwise, the number of copies of the tile that are drawn is based
      /// on the counter value and the maximum number than can be drawn in the plan rectangle.
      /// The result is rounded to a whole number (partial tiles are not drawn). Because of
      /// the way this style works, you will probably want to make sure the number of copies
      /// of the tile that can fit in the plan rectangle exactly matches the counter's maximum
      /// value.&lt;/remarks&gt;
      RepeatRightToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched to fill the height of the plan, and the top is
      /// cropped according to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches the maximum, the full tile is drawn, otherwise
      /// the clipping size is scaled according to the ratio of the counter's current value to
      /// its maximum value. The tile image is only stretched vertically. The horizontal size
      /// remains at the tile's original width.&lt;/remarks&gt;
      ClipTopToCounter,
      /// &lt;summary&gt;
      /// The specified tile is drawn stretched upward from the bottom of the plan according
      /// to the counter value.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will fill the plan rectangle's height.
      /// Otherwise the image is scaled down vertically to fill the bottom portion of the plan
      /// rectangle as determined by the ratio of the counter's current value to its
      /// maximum value.&lt;/remarks&gt;
      StretchTopToCounter,
      /// &lt;summary&gt;
      /// The specified tile is draw unscaled from bottom to top, repeated according
      /// to the counter value and plan size.
      /// &lt;/summary&gt;
      /// &lt;remarks&gt;When the counter reaches its maximum, the tile will be repeated from the
      /// plan's bottom to its top, as many whole copies as can fit in the plan rectangle.
      /// Otherwise, the number of copies of the tile that are drawn is based on the counter
      /// value and the maximum number than can be drawn in the plan rectangle.
      /// The result is rounded to a whole number (partial tiles are not drawn). Because of
      /// the way this style works, you will probably want to make sure the number of copies
      /// of the tile that can fit in the plan rectangle exactly matches the counter's maximum
      /// value.&lt;/remarks&gt;
      RepeatUpToCounter
   }

   /// &lt;summary&gt;
   /// Draw the value of a counter as a bar filled with a tile's image.
   /// &lt;/summary&gt;
   /// &lt;param name="TileIndex"&gt;Specifies the index of a tile from this plan's layer&lt;/param&gt;
   /// &lt;param name="counter"&gt;Specifies which counter's value is being drawn&lt;/param&gt;
   /// &lt;param name="style"&gt;Specifies a style with which the tile will fill the bar&lt;/param&gt;
   /// &lt;remarks&gt;The size of the plan determines the maximum proportions of the bar.
   /// The counter value determines the drawn/current size of the bar.
   /// See &lt;see cref="DrawStyle"/&gt; for details about the different ways in which the bar
   /// can be filled.&lt;/remarks&gt;
   [Description("Draw the specified tile from the layer's tileset in this plan's rectangle according to the specified counter value")]
   public void DrawCounterAsTile(int TileIndex, Counter counter, DrawStyle style)
   {
      System.Diagnostics.Debug.Assert(!PlanRectangle.IsEmpty, "DrawCounterAsTile was called on a plan that does not have a rectangle defined");
      if (PlanRectangle.IsEmpty)
         return;
      if (counter.CurrentValue == 0)
         return;
      MapBase map = ParentLayer.ParentMap;
      Display disp = map.Display;
      Tileset ts = ParentLayer.Tileset;
      Frameset fr = ts.GetFrameset(ParentLayer.ParentMap.Display);

      Rectangle CurrentView = ParentLayer.ParentMap.CurrentView;

      switch(style)
      {
         case DrawStyle.ClipRightToCounter:
            disp.Device.RenderState.ScissorTestEnable = true;
            disp.Device.ScissorRectangle = new Rectangle(
               PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
               PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
               PlanRectangle.Width * counter.CurrentValue / counter.MaxValue,
               PlanRectangle.Height);
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               disp.Sprite.Transform = Matrix.Multiply(Matrix.Multiply(
                  fr[frameIndex].Transform,
                  Matrix.Scaling(PlanRectangle.Width / (float)ts.TileWidth, 1, 1)),
                  Matrix.Translation(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
                  0));
               disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                  Vector3.Empty, Vector3.Empty, -1);
            }
            break;
         case DrawStyle.StretchRightToCounter:
            disp.Device.RenderState.ScissorTestEnable = false;
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               disp.Sprite.Transform = Matrix.Multiply(Matrix.Multiply(
                  fr[frameIndex].Transform,
                  Matrix.Scaling(PlanRectangle.Width * counter.CurrentValue / (float)counter.MaxValue / (float)ts.TileWidth, 1, 1)),
                  Matrix.Translation(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
                  0));
               disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                  Vector3.Empty, Vector3.Empty, -1);
            }
            break;
         case DrawStyle.RepeatRightToCounter:
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               int FillWidth = PlanRectangle.Width * counter.CurrentValue / counter.MaxValue;
               disp.Device.RenderState.ScissorTestEnable = false;
               disp.Device.ScissorRectangle = new Rectangle(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
                  FillWidth, PlanRectangle.Height);
               for (int repeat=0; repeat &lt; (int)Math.Ceiling(FillWidth / (float)ts.TileWidth); repeat++)
               {
                  disp.Sprite.Transform = Matrix.Multiply(
                     fr[frameIndex].Transform,
                     Matrix.Translation(
                     PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X + repeat * ts.TileWidth,
                     PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
                     0));
                  disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                     Vector3.Empty, Vector3.Empty, -1);
               }
            }
            break;
         case DrawStyle.ClipTopToCounter:
         {
            disp.Device.RenderState.ScissorTestEnable = true;
            int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
            disp.Device.ScissorRectangle = new Rectangle(
               PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
               PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y +
               PlanRectangle.Height - FillHeight, PlanRectangle.Width, FillHeight);
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               disp.Sprite.Transform = Matrix.Multiply(Matrix.Multiply(
                  fr[frameIndex].Transform,
                  Matrix.Scaling(1, PlanRectangle.Height / (float)ts.TileHeight, 1)),
                  Matrix.Translation(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y,
                  0));
               disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                  Vector3.Empty, Vector3.Empty, -1);
            }
         }
            break;
         case DrawStyle.StretchTopToCounter:
         {
            disp.Device.RenderState.ScissorTestEnable = false;
            int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               disp.Sprite.Transform = Matrix.Multiply(Matrix.Multiply(
                  fr[frameIndex].Transform,
                  Matrix.Scaling(1, FillHeight / (float)ts.TileHeight, 1)),
                  Matrix.Translation(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y + PlanRectangle.Height - FillHeight,
                  0));
               disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                  Vector3.Empty, Vector3.Empty, -1);
            }
         }
            break;
         case DrawStyle.RepeatUpToCounter:
            foreach(int frameIndex in ts[TileIndex].CurrentFrame)
            {
               int FillHeight = PlanRectangle.Height * counter.CurrentValue / counter.MaxValue;
               disp.Device.RenderState.ScissorTestEnable = false;
               disp.Device.ScissorRectangle = new Rectangle(
                  PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                  PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y +
                  PlanRectangle.Height - FillHeight, PlanRectangle.Width, FillHeight);
               for (int repeat=0; repeat &lt; (int)Math.Ceiling(FillHeight / (float)ts.TileHeight); repeat++)
               {
                  disp.Sprite.Transform = Matrix.Multiply(
                     fr[frameIndex].Transform,
                     Matrix.Translation(
                     PlanRectangle.X + ParentLayer.CurrentPosition.X + CurrentView.X,
                     PlanRectangle.Y + ParentLayer.CurrentPosition.Y + CurrentView.Y + PlanRectangle.Height - repeat * ts.TileHeight - ts.TileHeight,
                     0));
                  disp.Sprite.Draw(fr[frameIndex].GraphicSheetTexture.Texture, fr[frameIndex].SourceRect,
                     Vector3.Empty, Vector3.Empty, -1);
               }
            }
            break;
      }
      disp.Sprite.Flush();
   }

   /// &lt;summary&gt;
   /// Display a counter value as a number with a label in the current plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Label"&gt;String containing the text of the label&lt;/param&gt;
   /// &lt;param name="counter"&gt;Counter whose value will be displayed&lt;/param&gt;
   /// &lt;param name="color"&gt;Color of the label and quantity text&lt;/param&gt;
   /// &lt;remarks&gt;The label and quantity are merged into a single string of
   /// text and drawn at the top left corner of the plan's rectangle.&lt;/remarks&gt;
   [Description("Display a counter value as a number with a label in the current plan's rectangle")]
   public void DrawCounterWithLabel(string Label, Counter counter, System.Drawing.KnownColor color)
   {
      System.Diagnostics.Debug.Assert(!PlanRectangle.IsEmpty, "DrawCounterAsTile was called on a plan that does not have a rectangle defined");
      if (PlanRectangle.IsEmpty)
         return;
      
      Display disp = ParentLayer.ParentMap.Display;
      disp.Device.RenderState.ScissorTestEnable = false;
      disp.Sprite.Transform = Matrix.Identity;
      disp.D3DFont.DrawText(disp.Sprite, Label.ToString() + counter.CurrentValue.ToString(), PlanRectangle, Microsoft.DirectX.Direct3D.DrawTextFormat.Left, System.Drawing.Color.FromKnownColor(color));
      disp.Sprite.Flush();
   }
   #endregion

   private void CopyTiles(PlanBase Source, PlanBase Target, RelativePosition RelativePosition)
   {
      int src_left = (int)(Source.PlanRectangle.X / Source.ParentLayer.Tileset.TileWidth);
      int src_top = (int)(Source.PlanRectangle.Y / Source.ParentLayer.Tileset.TileHeight);
      int src_right = (int)((Source.PlanRectangle.X + Source.PlanRectangle.Width - 1) / Source.ParentLayer.Tileset.TileWidth);
      int src_bottom = (int)((Source.PlanRectangle.Y + Source.PlanRectangle.Height - 1) / Source.ParentLayer.Tileset.TileHeight);

      int dst_left = (int)(Target.PlanRectangle.X / Target.ParentLayer.Tileset.TileWidth);
      int dst_top = (int)(Target.PlanRectangle.Y / Target.ParentLayer.Tileset.TileHeight);
      int dst_right = (int)((Target.PlanRectangle.X + Target.PlanRectangle.Width - 1) / Target.ParentLayer.Tileset.TileWidth);
      int dst_bottom = (int)((Target.PlanRectangle.Y + Target.PlanRectangle.Height - 1) / Target.ParentLayer.Tileset.TileHeight);

      for (int y = src_top; y &lt;= src_bottom; y++)
      {
         int targety;
         switch(RelativePosition)
         {
            case RelativePosition.TopLeft:
            case RelativePosition.TopCenter:
            case RelativePosition.TopRight:
               targety = dst_top + y - src_top;
               break;
            case RelativePosition.LeftMiddle:
            case RelativePosition.CenterMiddle:
            case RelativePosition.RightMiddle:
               targety = y + (int)(dst_top + dst_bottom - src_top - src_bottom) / 2;
               break;
            default:
               targety = dst_bottom + y - src_bottom;
               break;
         }
         if (targety &lt; 0)
            continue;
         if (targety &gt;= Target.ParentLayer.VirtualRows)
            break;
         for (int x = src_left; x &lt;= src_right; x++)
         {
            int targetx;
            switch(RelativePosition)
            {
               case RelativePosition.TopLeft:
               case RelativePosition.LeftMiddle:
               case RelativePosition.BottomLeft:
                  targetx = dst_left + x - src_left;
                  break;
               case RelativePosition.TopCenter:
               case RelativePosition.CenterMiddle:
               case RelativePosition.BottomCenter:
                  targetx = x + (int)(dst_left + dst_right - src_left - src_right) / 2;
                  break;
               default:
                  targetx = dst_right + x - src_right;
                  break;
            }
            if (targetx &lt; 0)
               continue;
            if (targetx &gt;= Target.ParentLayer.VirtualColumns)
               break;
            
            Target.ParentLayer[targetx,targety] = Source.ParentLayer[x,y];
         }
      }
   }

   /// &lt;summary&gt;
   /// Copy tiles from this plan's rectangle to another plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Target"&gt;Specifies another plan specifying a location to which tiles will be copied&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies the alignment of the tiles in the target rectangle if
   /// this plan's rectangle is a different size&lt;/param&gt;
   /// &lt;remarks&gt;If the source rectangle is larger than the target rectangle, the copy
   /// locations will be aligned according to RelativePosition, and the copied tiles
   /// will be allowed to overflow the target rectangle.  For example, if the alignment
   /// is &lt;see cref="RelativePosition.RightMiddle"/&gt;, the right middle tile of the source
   /// rectangle will be copied into the right middle tile of the target rectangle, and
   /// build around there regardless of the target rectangle's size.&lt;/remarks&gt;
   [Description("Copy tiles from this plan's rectangle to another plan's rectangle.")]
   public void CopyTo(PlanBase Target, RelativePosition RelativePosition)
   {
      CopyTiles(this, Target, RelativePosition);
   }

   /// &lt;summary&gt;
   /// Copy tiles from the specified plan's rectangle to this plan's rectangle.
   /// &lt;/summary&gt;
   /// &lt;param name="Source"&gt;Specifies another plan specifying a location from which tiles will be copied&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specifies the alignment of the tiles in this plan's rectangle if
   /// the source plan's rectangle is a different size&lt;/param&gt;
   /// &lt;remarks&gt;If the source rectangle is larger than the target rectangle, the copy
   /// locations will be aligned according to RelativePosition, and the copied tiles
   /// will be allowed to overflow the target rectangle.  For example, if the alignment
   /// is &lt;see cref="RelativePosition.RightMiddle"/&gt;, the right middle tile of the source
   /// rectangle will be copied into the right middle tile of the target rectangle, and
   /// build around there regardless of the target rectangle's size.&lt;/remarks&gt;
   [Description("Copy tiles from the specified plan's rectangle to this plan's rectangle.")]
   public void CopyFrom(PlanBase Source, RelativePosition RelativePosition)
   {
      CopyTiles(Source, this, RelativePosition);
   }

   /// &lt;summary&gt;
   /// Determines if the specified sprite's specified input is pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose inputs will be examined&lt;/param&gt;
   /// &lt;param name="Input"&gt;Specifies which input will be examined&lt;/param&gt;
   /// &lt;param name="InitialOnly"&gt;When true only return true if the input has just been pressed and was not pressed before&lt;/param&gt;
   /// &lt;returns&gt;True if the input is pressed, false otherwise.&lt;/returns&gt;
   /// &lt;remarks&gt;The &lt;see cref="SpriteBase.IsInputPressed"/&gt; function for sprite definitions is
   /// more commonly used, but this allows you to test a specific sprite's inputs on a specific
   /// layer.&lt;/remarks&gt;
   [Description("Determine if the specified sprite's specified input is pressed.  InitialOnly causes this to return true only if the input has just been pressed and was not pressed before.")]
   public bool IsInputPressed(SpriteBase Sprite, SpriteBase.InputBits Input, bool InitialOnly)
   {
      return Sprite.IsInputPressed(Input, InitialOnly);
   }

   /// &lt;summary&gt;
   /// Ensure that all the inputs currently being pressed on the specified sprite are henceforth processed as already pressed.
   /// &lt;/summary&gt;
   /// &lt;param name="Sprite"&gt;Sprite whose inputs will be shifted.&lt;/param&gt;
   /// &lt;remarks&gt;This is usually handled by &lt;see cref="MapPlayerToInputs"/&gt;, but if you
   /// have customized the factors that affect the inputs, you may need to manually
   /// shift the current inputs into the old inputs to allow correct handling for
   /// "InitialOnly" parameters.&lt;/remarks&gt;
   [Description("Ensure that all the inputs currently being pressed on the specified sprite are henceforth processed as already pressed.")]
   public void CopyInputsToOld(SpriteBase Sprite)
   {
      Sprite.oldinputs = Sprite.inputs;
   }

   /// &lt;summary&gt;
   /// Create a new (dynamic) instance of the specified sprite type at the first coordinate
   /// in this plan.
   /// &lt;/summary&gt;
   /// &lt;param name="SpriteDefinition"&gt;Specifies the type of sprite that will be created.&lt;/param&gt;
   /// &lt;param name="RelativePosition"&gt;Specified a coordinate within the sprite that should be
   /// matched up with the first coordinate of the plan.&lt;/param&gt;
   /// &lt;remarks&gt;&lt;para&gt;As opposed to &lt;see cref="ActivateSprite"/&gt;, which activates a pre-defined
   /// instance of a sprite, this function will actually create a new sprite instance on the
   /// fly (referred to as a "dynamic" sprite instance). Dynamic sprites cannot be referred
   /// to directly by other rules because they don't have names associated with them, therefore
   /// it's recommended that &lt;see cref="ActivateSprite"/&gt; be used when more control is
   /// desired. However, &lt;see cref="AddSpriteAtPlan"/&gt; doesn't require you to pre-define each
   /// possible instance.&lt;/para&gt;
   /// &lt;para&gt;Dynamic sprites are added to the end of each category that they belong to
   /// (categories are defined in terms of sprite definitions, so a dynamic sprite knows
   /// the categories in which it should participate). This happens as the sprite is created.
   /// When the sprite is deactivated, it will automatically be removed from all categories
   /// as part of &lt;see cref="LayerBase.ProcessSprites"/&gt;.&lt;/para&gt;
   /// &lt;para&gt;The maximum number of sprites that can be active on a layer at once is
   /// defined by &lt;see cref="SpriteCollection.maxCollectionSize"/&gt;. This includes static
   /// sprites as well as dynamic sprites. The purpose of this maximum is not a technical
   /// limitation (feel free to change the code in SpriteCollection.cs to increase the maximum
   /// all you like). It only exists to help developers realize when sprite instances are
   /// "leaking" (not being cleaned up or deactivated properly) or when more sprites than
   /// necessary are being created. In many cases, the engine can actually handle quite a
   /// bit more than 100 sprites without significant performance impact.&lt;/para&gt;
   /// &lt;para&gt;All parameters of a newly created sprite instance are always initialized
   /// to zero. Furthermore, new sprite instances will not refer to any solidity,
   /// and will begin in the first
   /// frame of the first state, but you can use rules to affect &lt;see cref="GeneralRules.lastCreatedSprite"/&gt;
   /// to set values of the new sprite, or define rules on the created sprite type to make it
   /// initialize itself appropriately.&lt;/para&gt;
   /// &lt;para&gt;If this plan has no coordinates, the sprite is created at the top left corner of
   /// the layer, and not adjusted according to &lt;paramref name="RelativePosition"/&gt;.
   /// &lt;/para&gt;&lt;seealso cref="SpriteBase.AddSpriteHere"/&gt;&lt;seealso cref="SpriteBase.TileAddSprite"/&gt;&lt;/remarks&gt;
   [Description("Add a new instance of the specified sprite type to this plan's layer such that the specified position within the sprite corresponds to the first coordinate in this plan")]
   public void AddSpriteAtPlan([Editor("SpriteDefinition", "UITypeEditor")] System.Type SpriteDefinition, RelativePosition RelativePosition)
   {
      System.Reflection.ConstructorInfo constructor = SpriteDefinition.GetConstructor(new System.Type[]
      {
         typeof(LayerBase), typeof(double), typeof(double), typeof(double), typeof(double), typeof(int), typeof(int), typeof(bool), typeof(Display), typeof(Solidity), typeof(int), typeof(bool)
      });
      lastCreatedSprite = (SpriteBase)constructor.Invoke(new object[]
      {
         ParentLayer, 0, 0, 0, 0, 0, 0, true, ParentLayer.ParentMap.Display, null, -1, true
      });
      if (Count &gt; 0)
      {
         System.Drawing.Point offset = lastCreatedSprite.GetRelativePosition(RelativePosition);
         lastCreatedSprite.x = Coordinates[0].x - offset.X;
         lastCreatedSprite.y = Coordinates[0].y - offset.Y ;
      }
   }

   /// &lt;summary&gt;
   /// Push the specified Source sprite toward the specified Target sprite.
   /// &lt;/summary&gt;
   /// &lt;param name="Source"&gt;Sprite to push.&lt;/param&gt;
   /// &lt;param name="Target"&gt;Sprite toward which to push.&lt;/param&gt;
   /// &lt;param name="Force"&gt;Acceleration in tenths of a pixel per frame per frame.&lt;/param&gt;
   /// &lt;returns&gt;True if the sprite is pushed, false if the sprites are already a the same location.&lt;/returns&gt;
   [Description("Push the specified Source sprite toward the specified Target sprite. Force is in tenths of a pixel per frame per frame.")]
   public bool PushSpriteTowardSprite(SpriteBase Source, SpriteBase Target, int Force)
   {
      return Source.PushTowardSprite(Target, Force);
   }
   #region IEnumerable Members

   /// &lt;summary&gt;
   /// Allows a the coordinates of a plan to be enumerated with a foreach loop.
   /// &lt;/summary&gt;
   /// &lt;returns&gt;An object that enumerates this plan's coordinates.&lt;/returns&gt;
   public System.Collections.IEnumerator GetEnumerator()
   {
      if (Coordinates == null)
         new System.Collections.ArrayList().GetEnumerator();
      return Coordinates.GetEnumerator();
   }

   #endregion
}</Text>
  </SourceCode>
  <SourceCode Name="Player.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;
using Microsoft.DirectX.DirectInput;

/// &lt;summary&gt;
/// Defines a common interface by which a sprite can receive input from a player
/// or some object simulating a player.
/// &lt;/summary&gt;
public interface IPlayer
{
   /// &lt;summary&gt;
   /// Returns true when the player is pressing up, or false otherwise.
   /// &lt;/summary&gt;
   bool Up
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing left, or false otherwise.
   /// &lt;/summary&gt;
   bool Left
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing right, or false otherwise.
   /// &lt;/summary&gt;
   bool Right
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing down, or false otherwise.
   /// &lt;/summary&gt;
   bool Down
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 1, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 1" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button1
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 2, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 2" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button2
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 3, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 3" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button3
   {
      get;
   }

   /// &lt;summary&gt;
   /// Returns true when the player is pressing button 4, or false otherwise.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 4" simply refers to one of 4 customizable inputs
   /// on a sprite. There is no pre-defined meaning to the buttons.&lt;/remarks&gt;
   bool Button4
   {
      get;
   }
}

/// &lt;summary&gt;
/// Represents interactions between the game and a player via the keyboard
/// &lt;/summary&gt;
[Serializable()]
public class KeyboardPlayer : IPlayer
{
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing left.
   /// &lt;/summary&gt;
   public Key key_left;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing up.
   /// &lt;/summary&gt;
   public Key key_up;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing right.
   /// &lt;/summary&gt;
   public Key key_right;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to the notion of pressing down.
   /// &lt;/summary&gt;
   public Key key_down;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 1.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 1" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button1;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 2.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 2" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button2;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 3.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 3" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button3;
   /// &lt;summary&gt;
   /// Specifies which keyboard key maps to button 4.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;The term "button 4" simply refers to 1 of 4 customizable inputs.&lt;/remarks&gt;
   public Key key_button4;

   /// &lt;summary&gt;
   /// Constructs a new player given the key mappings it will use.
   /// &lt;/summary&gt;
   /// &lt;param name="up"&gt;Initial value for &lt;see cref="key_up"/&gt;&lt;/param&gt;
   /// &lt;param name="left"&gt;Initial value for &lt;see cref="key_left"/&gt;&lt;/param&gt;
   /// &lt;param name="right"&gt;Initial value for &lt;see cref="key_right"/&gt;&lt;/param&gt;
   /// &lt;param name="down"&gt;Initial value for &lt;see cref="key_down"/&gt;&lt;/param&gt;
   /// &lt;param name="button1"&gt;Initial value for &lt;see cref="key_button1"/&gt;&lt;/param&gt;
   /// &lt;param name="button2"&gt;Initial value for &lt;see cref="key_button2"/&gt;&lt;/param&gt;
   /// &lt;param name="button3"&gt;Initial value for &lt;see cref="key_button3"/&gt;&lt;/param&gt;
   /// &lt;param name="button4"&gt;Initial value for &lt;see cref="key_button4"/&gt;&lt;/param&gt;
   private void InitializeKeys(Key up, Key left, Key right, Key down,
      Key button1, Key button2, Key button3, Key button4)
   {
      key_up = up;
      key_left = left;
      key_right = right;
      key_down = down;
      key_button1 = button1;
      key_button2 = button2;
      key_button3 = button3;
      key_button4 = button4;
   }

   /// &lt;summary&gt;
   /// Constructs a new player based on one of 4 possible sets of default key mappings
   /// &lt;/summary&gt;
   /// &lt;param name="defaultSet"&gt;Number 0 through 3 indicating which set of defaults to use.
   /// Default set number 0 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Up Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Down Arrow&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Ctrl&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Space&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Return&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Right Shift&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 1 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;W&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;A&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;D&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;S&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Shift&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Left Ctrl&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Q&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;E&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 2 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Up/8&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Left/4&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Right/6&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Down/2&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 5&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 0&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad Enter&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;Numeric Keypad 7&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// Default set number 3 is mapped as follows:
   /// &lt;list type="table"&gt;
   /// &lt;listheader&gt;&lt;term&gt;Key&lt;/term&gt;&lt;description&gt;Mapped to&lt;/description&gt;&lt;/listheader&gt;
   /// &lt;item&gt;&lt;term&gt;I&lt;/term&gt;&lt;description&gt;&lt;see cref="key_up"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;J&lt;/term&gt;&lt;description&gt;&lt;see cref="key_left"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;L&lt;/term&gt;&lt;description&gt;&lt;see cref="key_right"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;K&lt;/term&gt;&lt;description&gt;&lt;see cref="key_down"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;U&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button1"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;O&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button2"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;M&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button3"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;item&gt;&lt;term&gt;,&lt;/term&gt;&lt;description&gt;&lt;see cref="key_button4"/&gt;&lt;/description&gt;&lt;/item&gt;
   /// &lt;/list&gt;
   /// &lt;/param&gt;
   public KeyboardPlayer(int defaultSet)
   {
      switch(defaultSet)
      {
         case 0:
            InitializeKeys(
               Microsoft.DirectX.DirectInput.Key.UpArrow,
               Microsoft.DirectX.DirectInput.Key.LeftArrow,
               Microsoft.DirectX.DirectInput.Key.RightArrow,
               Microsoft.DirectX.DirectInput.Key.DownArrow,
               Microsoft.DirectX.DirectInput.Key.RightControl,
               Microsoft.DirectX.DirectInput.Key.Space,
               Microsoft.DirectX.DirectInput.Key.Return,
               Microsoft.DirectX.DirectInput.Key.RightShift);
            break;
         case 1:
            InitializeKeys(
               Microsoft.DirectX.DirectInput.Key.W,
               Microsoft.DirectX.DirectInput.Key.A,
               Microsoft.DirectX.DirectInput.Key.D,
               Microsoft.DirectX.DirectInput.Key.S,
               Microsoft.DirectX.DirectInput.Key.LeftShift,
               Microsoft.DirectX.DirectInput.Key.LeftControl,
               Microsoft.DirectX.DirectInput.Key.Q,
               Microsoft.DirectX.DirectInput.Key.E);
            break;
         case 2:
            InitializeKeys(
               Microsoft.DirectX.DirectInput.Key.NumPad8,
               Microsoft.DirectX.DirectInput.Key.NumPad4,
               Microsoft.DirectX.DirectInput.Key.NumPad6,
               Microsoft.DirectX.DirectInput.Key.NumPad2,
               Microsoft.DirectX.DirectInput.Key.NumPad5,
               Microsoft.DirectX.DirectInput.Key.NumPad0,
               Microsoft.DirectX.DirectInput.Key.NumPadEnter,
               Microsoft.DirectX.DirectInput.Key.NumPad7);
            break;
         default:
            InitializeKeys(
               Microsoft.DirectX.DirectInput.Key.I,
               Microsoft.DirectX.DirectInput.Key.J,
               Microsoft.DirectX.DirectInput.Key.L,
               Microsoft.DirectX.DirectInput.Key.K,
               Microsoft.DirectX.DirectInput.Key.U,
               Microsoft.DirectX.DirectInput.Key.O,
               Microsoft.DirectX.DirectInput.Key.M,
               Microsoft.DirectX.DirectInput.Key.Comma);
            break;
      }
   }

   #region IPlayer Members

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Up"/&gt;.
   /// &lt;/summary&gt;
   public bool Up
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_up];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Left"/&gt;.
   /// &lt;/summary&gt;
   public bool Left
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_left];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Right"/&gt;.
   /// &lt;/summary&gt;
   public bool Right
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_right];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Down"/&gt;.
   /// &lt;/summary&gt;
   public bool Down
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_down];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button1"/&gt;.
   /// &lt;/summary&gt;
   public bool Button1
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button1];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button2"/&gt;.
   /// &lt;/summary&gt;
   public bool Button2
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button2];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button3"/&gt;.
   /// &lt;/summary&gt;
   public bool Button3
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button3];
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button4"/&gt;.
   /// &lt;/summary&gt;
   public bool Button4
   {
      get
      {
         return Project.GameWindow.KeyboardState[key_button4];
      }
   }

   #endregion
}

/// &lt;summary&gt;
/// Represents interactions between the game and a player via a joystick/gamepad
/// &lt;/summary&gt;
[Serializable()]
public class ControllerPlayer : IPlayer
{
   public int deviceNumber;

   /// &lt;summary&gt;
   /// Constructs a player object that links input from the specified game controller device
   /// to game input.
   /// &lt;/summary&gt;
   /// &lt;param name="deviceNumber"&gt;Device number as defined in user's Control Panel&lt;/param&gt;
   public ControllerPlayer(int deviceNumber)
   {
      this.deviceNumber = deviceNumber;
   }

   #region IPlayer Members

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Up"/&gt;.
   /// &lt;/summary&gt;
   public bool Up
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).Y &lt; 0x4000;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Left"/&gt;.
   /// &lt;/summary&gt;
   public bool Left
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).X &lt; 0x4000;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Right"/&gt;.
   /// &lt;/summary&gt;
   public bool Right
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).X &gt; 0xC000;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Down"/&gt;.
   /// &lt;/summary&gt;
   public bool Down
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).Y &gt; 0xC000;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button1"/&gt;.
   /// &lt;/summary&gt;
   public bool Button1
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).GetButtons()[0] != 0;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button2"/&gt;.
   /// &lt;/summary&gt;
   public bool Button2
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).GetButtons()[1] != 0;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button3"/&gt;.
   /// &lt;/summary&gt;
   public bool Button3
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).GetButtons()[2] != 0;
      }
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="IPlayer.Button4"/&gt;.
   /// &lt;/summary&gt;
   public bool Button4
   {
      get
      {
         return Project.GameWindow.GetControllerState(deviceNumber).GetButtons()[3] != 0;
      }
   }

   #endregion
}
</Text>
  </SourceCode>
  <SourceCode Name="TileShapes.cs" IsCustomObject="false">
    <Text>/*
 * Created using Scrolling Game Development Kit 2.0
 * See Project.cs for copyright/licensing details
 */
using System;

/// &lt;summary&gt;
/// Associates a category of tiles with a solidity shape to which sprites can react.
/// &lt;/summary&gt;
[Serializable()]
public struct SolidityMapping : System.Runtime.Serialization.ISerializable
{
   /// &lt;summary&gt;
   /// Designates the category of tiles to which a shape is applied.
   /// &lt;/summary&gt;
   public TileCategoryName category;
   /// &lt;summary&gt;
   /// Designates the shape of the tiles in the associated category.
   /// &lt;/summary&gt;
   public TileShape shape;

   /// &lt;summary&gt;
   /// Constructs a SolidityMapping given all its parameters
   /// &lt;/summary&gt;
   /// &lt;param name="category"&gt;Initial value for &lt;see cref="category"/&gt;&lt;/param&gt;
   /// &lt;param name="shape"&gt;Initial value for &lt;see cref="shape"/&gt;&lt;/param&gt;
   public SolidityMapping(TileCategoryName category, TileShape shape)
   {
      this.category = category;
      this.shape = shape;
   }

   private SolidityMapping(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      category = (TileCategoryName)info.GetInt32("TileCategoryName");
      shape = (TileShape)System.Type.GetType(info.GetString("TileShapeName"), true, false).GetProperty("Value",
         System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Static |
         System.Reflection.BindingFlags.Public).GetValue(null, null);
   }

   /// &lt;summary&gt;
   /// This is provided to allow the object to be serialized for the purposes of saving and loading game data.
   /// &lt;/summary&gt;
   public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
   {
      info.AddValue("TileCategoryName", (System.Int32)category);
      info.AddValue("TileShapeName", shape.GetType().Name);
   }
}

/// &lt;summary&gt;
/// Defines a particular shape that a tile can have at any/all sizes
/// &lt;/summary&gt;
public abstract class TileShape
{
   public TileShape()
   {
   }
   /// &lt;summary&gt;
   /// Gets the vertical coordinate of the top-most solid pixel of a tile shape between two horizontal offsets.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Horizontal offset of the left side of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Horizontal offset of the right side of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and height-1, inclusive, or short.MaxValue if there is no solid&lt;/returns&gt;
   public abstract short GetTopSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the vertical coordinate of the bottom-most solid pixel of a tile shape between two horizontal offsets.
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Horizontal offset of the left side of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Horizontal offset of the right side of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and height-1, inclusive, or short.MinValue if there is no solid&lt;/returns&gt;
   public abstract short GetBottomSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the horizontal coordinate of the left-most solid pixel of a tile shape between two vertical offsets
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Vertical offset of the top of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Vertical offset of the bottom of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and width-1, inclusive, or short.MaxValue if there is no solid&lt;/returns&gt;
   public abstract short GetLeftSolidPixel(short width, short height, short min, short max);
   /// &lt;summary&gt;
   /// Gets the horizontal coordinate of the right-most solid pixel of a tile shape between two vertical offsets
   /// &lt;/summary&gt;
   /// &lt;param name="width"&gt;Width of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="height"&gt;Height of the tile to which the shape is being applied&lt;/param&gt;
   /// &lt;param name="min"&gt;Vertical offset of the top of the range to test&lt;/param&gt;
   /// &lt;param name="max"&gt;Vertical offset of the bottom of the range to test&lt;/param&gt;
   /// &lt;returns&gt;A value between 0 and width-1, inclusive, or short.MinValue if there is no solid&lt;/returns&gt;
   public abstract short GetRightSolidPixel(short width, short height, short min, short max);
}

/// &lt;summary&gt;
/// Represents an empty tile (nothing solid)
/// &lt;/summary&gt;
public class EmptyTileShape : TileShape
{
   private static EmptyTileShape m_Value = new EmptyTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static EmptyTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public EmptyTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }
}

/// &lt;summary&gt;
/// Represents a solid tile (flat solid on all 4 sides)
/// &lt;/summary&gt;
public class SolidTileShape : TileShape
{
   private static SolidTileShape m_Value = new SolidTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static SolidTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public SolidTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width-1);
   }
}

/*
   +--------+
   |       X|
   |      XX|
   |     XXX|
   |    XXXX|
   |   XXXXX|
   |  XXXXXX|
   | XXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents an "uphill" shape with a slope leading from the lower left corner
/// to the upper right corner with the lower right half of the tile being solid.
/// &lt;/summary&gt;
public class UphillTileShape : TileShape
{
   private static UphillTileShape m_Value = new UphillTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width-max-1) / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width * (height-max-1) / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width-1);
   }
}

/*
   +--------+
   |X       |
   |XX      |
   |XXX     |
   |XXXX    |
   |XXXXX   |
   |XXXXXX  |
   |XXXXXXX |
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents a "downhill" shape with a slope leading from the upper left corner
/// to the lower right corner with the lower left half of the tile being solid.
/// &lt;/summary&gt;
public class DownhillTileShape : TileShape
{
   private static DownhillTileShape m_Value = new DownhillTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * height / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - (height - max - 1) * width / height - 1);
   }
}

/*
   +--------+
   |XXXXXXXX|
   |XXXXXXX |
   |XXXXXX  |
   |XXXXX   |
   |XXXX    |
   |XXX     |
   |XX      |
   |X       |
   +--------+
*/
/// &lt;summary&gt;
/// Represents an "upward ceiling" shape with a slope leading from the lower left corner
/// to the upper right corner with the upper left half of the tile being solid.
/// &lt;/summary&gt;
public class UpCeilingTileShape : TileShape
{
   private static UpCeilingTileShape m_Value = new UpCeilingTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UpCeilingTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UpCeilingTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((width - min) * height - 1) / width);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((height - min) * width - 1) / height);
   }
}

/*
   +--------+
   |XXXXXXXX|
   | XXXXXXX|
   |  XXXXXX|
   |   XXXXX|
   |    XXXX|
   |     XXX|
   |      XX|
   |       X|
   +--------+
*/
/// &lt;summary&gt;
/// Represents a "downward ceiling" shape with a slope leading from the upper left corner
/// to the lower right corner with the upper right half of the tile being solid.
/// &lt;/summary&gt;
public class DownCeilingTileShape : TileShape
{
   private static DownCeilingTileShape m_Value = new DownCeilingTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownCeilingTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownCeilingTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - (width - max - 1) * height / width - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * width / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - 1);
   }
}

/*
   +--------+
   |      XX|
   |    XXXX|
   |  XXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the right half of a gradual "uphill" tile with a slope leading from the
/// middle left to the upper right corner with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public class UphillRightTileShape : TileShape
{
   private static UphillRightTileShape m_Value = new UphillRightTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillRightTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillRightTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width - max - 1) / width / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)((max * 2 &gt;= height - 2) ? 0 : width * (height - max * 2 - 2) / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(width - 1);
   }
}

/*
   +--------+
   |        |
   |        |
   |        |
   |        |
   |      XX|
   |    XXXX|
   |  XXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the left half of a gradual "uphill" tile with a slope leading from the
/// lower left corner to the middle right with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public class UphillLeftTileShape : TileShape
{
   private static UphillLeftTileShape m_Value = new UphillLeftTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static UphillLeftTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public UphillLeftTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height * (width - max - 1) / width / 2 + height / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height - 1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height)?short.MaxValue:width * (height - max - 1) * 2 / height);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height)?short.MinValue:width - 1);
   }
}

/*
   +--------+
   |XX      |
   |XXXX    |
   |XXXXXX  |
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the left half of a gradual "downhill" tile with a slope leading from the
/// upper left corner to the middle right with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public class DownhillLeftTileShape : TileShape
{
   private static DownhillLeftTileShape m_Value = new DownhillLeftTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillLeftTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillLeftTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)(min * height / width / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &gt; height) ? width - 1 : width * 2 - (height - max - 1) * width * 2 / height - 1);
   }
}

/*
   +--------+
   |        |
   |        |
   |        |
   |        |
   |XX      |
   |XXXX    |
   |XXXXXX  |
   |XXXXXXXX|
   +--------+
*/
/// &lt;summary&gt;
/// Represents the right half of a gradual "downhill" tile with a slope leading from the
/// middle left to the lower right corner with the lower portion of the tile being solid.
/// &lt;/summary&gt;
public class DownhillRightTileShape : TileShape
{
   private static DownhillRightTileShape m_Value = new DownhillRightTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static DownhillRightTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public DownhillRightTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return (short)((height + min * height / width) / 2);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return (short)(height-1);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((min + 1) * 2 &lt;= height) ? short.MaxValue : (short)0);
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return (short)(((max + 1) * 2 &lt;= height) ? short.MinValue : width - (height - max - 1) * 2 * width / height - 1);
   }
}


/*
   +--------+
   |^^^^^^^^|
   |        |
   |        |
   |        |
   |        |
   |        |
   |        |
   |        |
   +--------+
   (Top is solid only from above)
*/
/// &lt;summary&gt;
/// Represents a tile that is only solid from above. A sprite can move freely through this tile
/// in any direction unless the sprite is fully above the tile in which case it cannot penetrate
/// the top.
/// &lt;/summary&gt;
public class TopSolidTileShape : TileShape
{
   private static TopSolidTileShape m_Value = new TopSolidTileShape();

   /// &lt;summary&gt;
   /// Returns the default instance of this class.
   /// &lt;/summary&gt;
   /// &lt;remarks&gt;Objects derived from &lt;see cref="TileShape"/&gt; generally have a default
   /// instance that all code can refer to because they are just a set of functions
   /// and don't have any instance-specific data.  So all code can share one instance
   /// rather than each case dealing with creating its own.&lt;/remarks&gt;
   public static TopSolidTileShape Value
   {
      get
      {
         return m_Value;
      }
   }

   public TopSolidTileShape()
   {
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetTopSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetTopSolidPixel(short width, short height, short min, short max)
   {
      return 0;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetBottomSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetBottomSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetLeftSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetLeftSolidPixel(short width, short height, short min, short max)
   {
      return short.MaxValue;
   }

   /// &lt;summary&gt;
   /// See &lt;see cref="TileShape.GetRightSolidPixel"/&gt;.
   /// &lt;/summary&gt;
   public override short GetRightSolidPixel(short width, short height, short min, short max)
   {
      return short.MinValue;
   }
}

</Text>
  </SourceCode>
  <Project DisplayMode="m640x480x24" Windowed="true" TitleText="Default SGDK2 Project" MaxPlayers="1" MaxViews="1" Credits="SGDK2 Engine: http://sgdk2.sf.net">
    <Comments />
  </Project>
  <TileCategory Name="Solid" />
</ProjectDataset>